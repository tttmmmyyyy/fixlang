module Main;

import Random;
import CPLib.Trait;
import CPLib.Segtree;

main : IO ();
main = (
    // n=10^5個の要素を持つSegtreeを生成し、n回程度ランダムにクエリを投げる。
    // もしn^2実装になっていたらこのテストは終わらない。
    let n = 1e5;
    let rng = Random::init_by_seed(0_U64);
    let tree = Segtree::init(n) : Segtree I64Max;
    let ((tree, rng, fold_sum), time) = consumed_time_while_lazy(|_| range(0, n).fold((tree, rng, 0), |_, (tree, rng, fold_sum)| (
        // set
        let (rng, i) = rng.generate_I64_nonneg;
        let (rng, v) = rng.generate_I64_nonneg;
        let i = i % n; // 0 <= i < n
        let tree = tree.set(i, I64Max::make(v));

        // fold
        let (rng, k) = rng.generate_I64_nonneg;
        let (rng, l) = rng.generate_I64_nonneg;
        let k = k % n; // 0 <= k < n
        let l = l % n; // 0 <= l < n
        let v = tree.fold(k, l);

        let fold_sum = fold_sum.max(v.@v);

        (tree, rng, fold_sum)
    )));
    assert_eq(|_|"test_speed", fold_sum, 9223241343006558035);;
    println $ "[CPLib.Segtree.Test] Segtree({}): {}".populate([n.to_string, time.to_string]);;

    pure $ ()
);

// 最大値モノイド
type I64Max = struct { v : I64 };
namespace I64Max {
    make : I64 -> I64Max;
    make = |v| I64Max { v : v };
}
impl I64Max : Monoid {
    unit = make(I64::minimum);
    op = |lhs, rhs| make $ lhs.@v.max(rhs.@v);
}