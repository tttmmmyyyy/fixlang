module Main;

import Random;
import CPLib.Trait;
import CPLib.Arithmetic;
import CPLib.Segtree;
import CPLib.LSegtree;
import CPLib.UnionFind;
import CPLib.Graph;
import CPLib.ZP;
import CPLib.Convolution;
import CPLib.Bipartite;
import CPLib.Graph;

test_prime_list : IO ();
test_prime_list = (
    let n = 1e8;
    assert_eq(|_|"test_prime_list 1", create_prime_list(20).map(to_I64), [2, 3, 5, 7, 11, 13, 17, 19]);;
    let (res, time) = consumed_time_while_lazy(|_| create_prime_list(n));

    assert_eq(|_|"test_prime_list 2", res.get_size, 5761455);;
    println $ "[CPLib.Arithmetic.Test] create_prime_list({}): {}".populate([n.to_string, time.to_string]);;
    pure()
);

test_segtree_speed : IO ();
test_segtree_speed = (
    // n=10^5個の要素を持つSegtreeを生成し、n回程度ランダムにクエリを投げる。
    // もしn^2実装になっていたらこのテストは終わらない。
    let n = 1e5;
    let rng = Random::init_by_seed(0_U64);
    let tree = Segtree::init(n) : Segtree I64Max;
    let ((tree, rng, fold_sum), time) = consumed_time_while_lazy(|_| range(0, n).fold((tree, rng, 0), |_, (tree, rng, fold_sum)| (
        // set
        let (rng, i) = rng.generate_I64_nonneg;
        let (rng, v) = rng.generate_I64_nonneg;
        let i = i % n; // 0 <= i < n
        let tree = tree.set(i, I64Max::make(v));

        // fold
        let (rng, k) = rng.generate_I64_nonneg;
        let (rng, l) = rng.generate_I64_nonneg;
        let k = k % n; // 0 <= k < n
        let l = l % n; // 0 <= l < n
        let v = tree.fold(k, l);

        let fold_sum = fold_sum.max(v.@v);

        (tree, rng, fold_sum)
    )));
    assert_eq(|_|"test_speed", fold_sum, 9223241343006558035);;
    println $ "[CPLib.Segtree.Test] Segtree({}): {}".populate([n.to_string, time.to_string]);;

    pure $ ()
);

test_lsegtree_speed : IO ();
test_lsegtree_speed = (
    // n=10^5個の要素を持つSegtreeを生成し、n回程度ランダムにクエリを投げる。
    // もしn^2実装になっていたらこのテストは終わらない。
    let n = 1e5;
    let rng = Random::init_by_seed(0_U64);
    let tree = LSegtree::init(n) : LSegtree I64Max I64Add;
    let ((tree, rng, fold_sum), time) = consumed_time_while_lazy(|_| range(0, n).fold((tree, rng, 0), |_, (tree, rng, fold_sum)| (
        // set
        let (rng, i) = rng.generate_I64_nonneg;
        let (rng, v) = rng.generate_I64_nonneg;
        let i = i % n; // 0 <= i < n
        let tree = tree.set(i, I64Max::make(v));

        // act_range
        let (rng, l) = rng.generate_I64_nonneg;
        let (rng, r) = rng.generate_I64_nonneg;
        let l = l % n; // 0 <= l < n
        let r = l + r % (n - l + 1);
        let (rng, a) = rng.generate_I64_nonneg;
        let tree = tree.act_range(l, r, I64Add::make(a));

        // fold
        let (rng, k) = rng.generate_I64_nonneg;
        let (rng, l) = rng.generate_I64_nonneg;
        let k = k % n; // 0 <= k < n
        let l = l % n; // 0 <= l < n
        let (tree, v) = tree.fold(k, l);

        let fold_sum = fold_sum.max(v.@v);

        (tree, rng, fold_sum)
    )));
    assert_eq(|_|"test_speed", fold_sum, 9223363321965027598);;
    println $ "[CPLib.LSegtree.Test] LSegtree({}): {}".populate([n.to_string, time.to_string]);;

    pure $ ()
);

test_unionfind_speed : IO ();
test_unionfind_speed = (
    // n=10^5個の要素を持つUnionFind木を生成し、n回程度ランダムにクエリを投げる。
    // もしn^2実装になっていたらこのテストは終わらない。
    let n = 1e5;
    let rng = Random::init_by_seed(0_U64);
    let uf = UnionFind::create(n);
    let ((uf, rng), time) = consumed_time_while_lazy(|_| range(0, n).fold((uf, rng), |_, (uf, rng)| (
        // unite
        let (rng, i) = rng.generate_I64_nonneg;
        let (rng, j) = rng.generate_I64_nonneg;
        let i = i % n; // 0 <= i < n
        let j = j % n; // 0 <= j < n
        let uf = uf.unite(i, j);

        // is_united
        let (rng, k) = rng.generate_I64_nonneg;
        let (rng, l) = rng.generate_I64_nonneg;
        let k = k % n; // 0 <= k < n
        let l = l % n; // 0 <= l < n
        let (uf, is_united) = uf.is_united(k, l);

        (uf, rng)
    )));
    let (uf, grps) = uf.get_groups;
    assert_eq(|_|"test_speed", grps.get_size, 16102);;
    println $ "[CPLib.UnionFind.Test] UnionFind({}): {}".populate([n.to_string, time.to_string]);;

    pure()
);

test_dijkstra_speed : IO ();
test_dijkstra_speed = (
    let n = 1e5;
    let rng = Random::init_by_seed(0_U64);
    let graph = Graph::create(n);
    let (graph, rng) = range(0, n).fold((graph, rng), |i, (graph, rng)|
        let (rng, j) = rng.generate_I64_nonneg;
        let j = j % n;
        let (rng, c) = rng.generate_I64_nonneg;
        let c = c % 100 + 1; // 1 <= c < 100
        let graph = graph.add_edge(i, j, c);

        let (rng, j) = rng.generate_I64_nonneg;
        let j = j % n;
        let (rng, c) = rng.generate_I64_nonneg;
        let c = c % 100 + 1; // 1 <= c < 100
        let graph = graph.add_edge(j, i, c);

        (graph, rng)
    );
    let (dist, time) = consumed_time_while_lazy(|_| graph.dijkstra(0, I64::maximum));
    assert_eq(|_|"test_dijkstra_speed", dist.@(1), 391);;
    println $ "[CPLib.Graph.Test] dijkstra({}): {}".populate([n.to_string, time.to_string]);;
    pure()
);

test_scc_speed : IO (); 
test_scc_speed = (
    // n個の頂点を持つグラフをランダムに生成
    let n = 1e5;
    let rng = Random::init_by_seed(0_U64);
    let graph = Graph::create(n) : Graph ();
    let (graph, rng) = range(0, n).fold((graph, rng), |i, (graph, rng)|
        let (rng, i) = rng.generate_I64_nonneg;
        let i = i % n;
        let (rng, j) = rng.generate_I64_nonneg;
        let j = j % n;
        (graph.add_edge(i, j, ()), rng)
    );
    // 強連結成分を計算
    let (sccs, time) = consumed_time_while_lazy(|_| graph.calc_sccs);
    assert_eq(|_|"test_scc_speed", sccs.get_size, 99999);;
    println("[CPLib.Graph.Test] calc_sccs({}): {}".populate([n.to_string, time.to_string]));;
    pure()
);


test_conv_zp_speed : IO ();
test_conv_zp_speed = (
    // ベンチマーク
    let n = 1e5;
    let x = range(0, n).map(ZP::make).to_array : Array (ZP P998244353);
    let y = range(0, n).map(ZP::make).to_array : Array (ZP P998244353);
    let (z, time) = consumed_time_while_lazy(|_| convolve_zp(x, y));
    let ans_n1 = range(0, n).fold(ZP::make(0), |i, acc| acc + x.@(i) * y.@(n-1-i));
    assert_eq(|_|"[test_zp] case 15", z.@(n-1), ans_n1);;
    println $ "[CPLib.Convolution.Test] convolve_zp({}): {}".populate([n.to_string, time.to_string]);;

    pure()
);

test_bipartite_speed : IO ();
test_bipartite_speed = (
    // ベンチマーク
    let n = 1e4;
    let m = 1e4;
    let rng = Random::init_by_seed(0_U64);
    let bg = BipartiteGraph::create(n, n);
    let (bg, rng) = range(0, m).fold((bg, rng), |_, (bg, rng)| (
        let (rng, i) = rng.generate_I64_nonneg;
        let i = i % n;
        let (rng, j) = rng.generate_I64_nonneg;
        let j = j % n;
        let bg = bg.BipartiteGraph::add_edge(i, j);
        (bg, rng)
    ));
    let (matching, time) = consumed_time_while_lazy(|_| bg.maximize_flow.get_max_matching);
    assert_eq(|_|"test_speed", matching.to_iter.filter(|v|v).get_size, 5466);;
    println $ "[CPLib.Bipartite.Test] BipartiteGraph({}, {}): {}".populate([n.to_string, m.to_string, time.to_string]);;

    pure()
);

main : IO ();
main = (
    test_prime_list;;
    test_segtree_speed;;
    test_lsegtree_speed;;
    test_unionfind_speed;;
    test_dijkstra_speed;;
    test_scc_speed;;
    test_conv_zp_speed;;
    test_bipartite_speed;;
    pure()
);

// 最大値モノイド
type I64Max = struct { v : I64 };
namespace I64Max {
    make : I64 -> I64Max;
    make = |v| I64Max { v : v };
}
impl I64Max : Monoid {
    unit = make(I64::minimum);
    op = |lhs, rhs| make $ lhs.@v.max(rhs.@v);
}

// 加法モノイド
type I64Add = struct { v : I64 };
namespace I64Add {
    make : I64 -> I64Add;
    make = |v| I64Add { v : v };
}
impl I64Add : Monoid {
    unit = make(0);
    op = |lhs, rhs| make $ lhs.@v + rhs.@v;
}

// 加法モノイドの最大値モノイドに対する作用
impl I64Add : Action {
    type Set I64Add = I64Max; // 作用を受ける集合の型
    act = |a, x| I64Max::make(x.@v + a.@v);
}