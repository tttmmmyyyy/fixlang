/*
# Eta expansion transform.

## Overview

This transformation converts expressions that "generate and return a lambda expression" into the lambda expression itself.

Specifically, consider the following global definition:

```
f : T;
f = {expr};
```

Given `n`, eta expansion first transforms the above definition as follows:

```
f : T;
f = |x1,...,x_n| {expr}(x_1,...,x_n);
```

and then performs application inlining transformation on the generated expression to obtain the final result.

## Purpose

This transformation is necessary to uncurry optimize functions and generate functions that take `n` arguments.

## Scope

Since this transformation is intended to be applied before uncurry optimization, it does not support expressions containing multi-parameter lambdas generated by uncurry optimization.

## Example

```
g = |x| e2;
f = if c { |x| e1 } else { g };
```
is transformed to:
```
f = |y| if c { e1[x:=y] } else { g(y) };
```

## Issues

If there is a definition like:

```
f = let arr = Array::fill(1e6, 0); in |i| arr.@(i);
```

and `f` is frequently referenced in the program, `Array::fill(1e6, 0)` may be evaluated multiple times, potentially causing significant performance degradation.

## Notes

### Compatibility with `Std::fix`

This transformation should not be applied to the definition of `fix`.
`fix` is defined as `|f||x| LLVM[fix(f,x)]`, and within `LLVM[fix(f,x)]`, it uses `get_insert_block().get_parent()` to obtain the implementation of `fix(f)`, which is `|x| LLVM[fix(f,x)]`.
If eta expansion is applied to `fix` and it is transformed to `|f||x||p| LLVM[fix(f,x)](p)`, then `get_insert_block().get_parent()` would obtain the implementation of `|p| LLVM[fix(f,x)](p)`, causing incorrect behavior.

*/

use std::sync::Arc;

use crate::{
    ast::{
        expr::{var_var, ExprNode},
        name::FullName,
    },
    expr_abs_typed, expr_app_typed, expr_var,
    misc::Map,
    optimization::{application_inlining, let_elimination},
};

// Perform eta expansion to take `n` arguments.
//
// If the type does not allow taking `n` arguments, return None.
pub fn run_on_expr(expr: Arc<ExprNode>, n: usize) -> Option<Arc<ExprNode>> {
    let ty = expr.type_.clone().unwrap();

    // Count the number of arguments that can be taken from the type.
    let (doms_tys, _codom_ty) = ty.collect_app_src(usize::MAX);
    if doms_tys.len() < n {
        return None;
    }

    // Determine the names of the new parameters.
    let mut new_params = vec![];
    for i in 0..n {
        new_params.push(FullName::local(&format!("#v{}", i)));
    }

    // Create the new lambda expression.
    let mut body = expr;
    for (i, param) in new_params.iter().enumerate() {
        // Get the type of the additional parameter.
        let var_ty = doms_tys[i].clone();

        // Create the variable expression of the additional parameter.
        let var = expr_var(param.clone(), None).set_type(var_ty);

        // Create the application expression `{body}({var})`.
        body = expr_app_typed(body, vec![var]);
    }

    // Abstract `body` by `params` in reverse order.
    let mut expr = body;
    for (var, ty) in new_params.into_iter().zip(doms_tys.into_iter()).rev() {
        expr = expr_abs_typed(var_var(var), ty, expr);
    }

    // Apply application inlining to the generated expression.
    let mut expr = application_inlining::run_on_expr(expr);
    let_elimination::run_on_expr_once(&mut expr, &Map::default());

    Some(expr)
}
