use std::{rc::Rc, sync::Arc};

use crate::{
    ast::{
        expr::{
            expr_abs_typed, expr_app_typed, expr_let_typed, expr_make_struct, expr_var, var_local,
            var_var, ExprNode,
        },
        name::FullName,
        pattern::PatternNode,
        program::{Program, Symbol},
        traverse::{EndVisitResult, ExprVisitor, StartVisitResult},
        typedecl::Field,
        types::{kind_star, type_fun, type_tycon, TyCon, TyConInfo, TypeNode},
    },
    constants::{CAP_NAME, DECAP_NAME, STD_NAME},
    misc::{Map, Set},
    optimization::{pull_let, rename::rename_free_names},
    stopwatch::StopWatch,
};

use super::{
    find_usage_of_name::{self, UsageType},
    inline::{self},
    uncurry::internalize_let_to_var_at_head,
    unique_local_names,
};

/*
# Decapturing optimization

## Overview

### Decapturing

For each lambda expression, a structure is defined that summarizes the values captured by that lambda expression.
And the lambda expression is defined as a global function.

For example, consider the following lambda expression:
```
let f = |x| x + n;
```

Then, the following structure and global function are defined:
```
type #DecapF = unbox struct { n: I64 };

#lamf : #DecapF -> I64 -> I64;
#lamf = |{ n : n }, x| x + n;
```

The creation of the lambda value is replaced with `#DecapF { n : n }`.
```
let f = #DecapF { n : n };
```

### Rewriting the usage of the lambda

The call of the decaptured lambda expression `f(x)` is transformed into the following code.
```
#lamf(f, x)
```

In principle, `f` is replaced with `#lamf(f)` in places where `f` appears alone (i.e., not in a call expression).
However, in cases where "closure specialization" can be applied, `f` is left as is.

### Closure specialization

Consider the case where a lambda is given as an argument to a global function.
As an example, consider the case where `f` is passed as the second argument to `fold`.

```
fold : S -> (A -> S -> S) -> Iter -> S;
fold = |s, op, iter| (
    match iter.advance {
        none() => s,
        some((iter, a)) => iter.fold(op(a, s), op)
    }
);
```

```
it.fold(s0, f)
```

In this case, the following code is generated.
This is called as "closure specialization".

```
fold#lamf : S -> #DecapF -> Iter -> S;
fold#lamf = |s, op, iter| (
    match iter.advance {
        none() => s,
        some((iter, a)) => iter.fold#lamf(#lamf(op, a, s), op)
    }
);
```

```
it.fold#lamf(s0, f)
```

## Applicable range and limitations

### The path from defining a lambda to using it

If a lambda is defined and used as is, decapturing optimization is applied.
Example: `iter.fold(s0, |acm, i| acm + i)`

If a lambda is defined in the right-hand side of a let statement and its name is used, decapturing optimization is applied.
Example: `let f = |acm, i| acm + i; iter.fold(s0, f)`

However, if the path from defining a lambda to using it is more complex than this, this optimization is not applied.
Example: `let (_, f) = (0, |acm, i| acm + i); iter.fold(s0, f)`

## Relations to other optimizations

* We perform `pull-let` transformation before decapturing optimization.
* Inline expansion should be performed before this optimization. For example, the expression `f >> g` is replaced with a lambda expression by inline expansion, making it a target of this optimization.
* It may be worth performing inline expansion after this optimization. This is because global functions are generated by this optimization, and inline expansion may be performed on them.
* It may be worth performing inline expansion before this optimization. This is because the number of arguments that can be specialized increases due to eta expansion.
* To improve the performance of global functions generated by this optimization, uncurrying should be performed after this optimization.
*/

pub fn run(prg: &mut Program, show_build_times: bool) {
    let mut stable_symbols = Set::default();
    while run_one(prg, &mut stable_symbols, show_build_times) {}
}

// Run optimization on all symbols.
// If any optimization is performed, return `true`.
//
// * `stable_symbols`: A set of symbols that are known to be stable (i.e., will not be optimized further).
pub fn run_one(
    prg: &mut Program,
    stable_symbols: &mut Set<FullName>,
    show_build_times: bool,
) -> bool {
    let _sw = StopWatch::new("decapturing::run_one", show_build_times);

    // Whether optimization has been performed on any symbol.
    let mut changed = false;

    // Compute the set of specializable functions.
    let specializable_funcs = specializable_functions(prg);
    let specializable_funcs = Rc::new(specializable_funcs);

    let symbols = std::mem::take(&mut prg.symbols);
    let mut new_tycons = Map::default();

    // Create a set of global names
    let mut global_names = Set::default();
    for (name, _) in &symbols {
        global_names.insert(name.clone());
    }

    // Perform decapturing optimization on each symbol
    let mut new_symbols: Map<FullName, Symbol> = Map::default();
    let mut specializations: Vec<SpecializationRequest> = Vec::new();

    let sw = StopWatch::new("decapturing::run_one first loop", show_build_times);

    for (name, mut sym) in symbols {
        // Skip symbols that are already known to be stable and will not change.
        if stable_symbols.contains(&name) {
            new_symbols.insert(name.clone(), sym.clone());
            continue;
        }

        let mut visitor = DecapturingVisitor::new(
            name.clone(),
            specializable_funcs.clone(),
            global_names.clone(),
        );

        // Perform decapturing optimization
        let expr = sym.expr.as_ref().unwrap();
        let sw = StopWatch::new(
            "decapturing::run_one pull_let::run_on_expr",
            show_build_times,
        );
        let expr = pull_let::run_on_expr(expr); // Increase the number of places where decapturing optimization can be applied.
        drop(sw);

        let sw = StopWatch::new(
            &format!(
                "decapturing::run_one unique_local_names::run_on_expr on {}",
                &name.to_string()
            ),
            show_build_times,
        );
        let expr = unique_local_names::run_on_expr(&expr, Set::default()); // Ensure preconditions for implementation of decapturing optimization.
        drop(sw);

        let sw = StopWatch::new(
            &format!(
                "decapturing::run_one visitor.traverse on {}",
                &name.to_string()
            ),
            show_build_times,
        );
        let trav_res = visitor.traverse(&expr);
        drop(sw);

        if !trav_res.changed {
            // When no optimization is performed,
            stable_symbols.insert(name.clone());
            new_symbols.insert(name.clone(), sym.clone());
            continue;
        }

        changed = true;
        sym.expr = Some(trav_res.expr);
        specializations.append(&mut visitor.required_specializations); // Specialization requests are processed later

        // Extract the generated decaptured lambdas and type constructors
        for decap_lam in visitor.decap_lambdas {
            let decap_lam_sym = decap_lam.make_symbol();
            global_names.insert(decap_lam_sym.name.clone());
            new_symbols.insert(decap_lam_sym.name.clone(), decap_lam_sym);
            new_tycons.insert(decap_lam.tycon, decap_lam.tycon_info);
        }

        new_symbols.insert(name.clone(), sym.clone());
    }
    drop(sw);

    let mut symbols = new_symbols;

    let sw = StopWatch::new("decapturing::run_one second loop", show_build_times);
    // Process specialization requests
    while specializations.len() > 0 {
        let mut new_specializations = Vec::new();
        for specialize_info in &specializations {
            // Generate the name and type of the specialized function
            let specialized_func_name = specialize_info.specialized_func_name();
            let specialized_func_ty = specialize_info.specialized_func_ty();

            // If it is already implemented, skip
            if symbols.contains_key(&specialized_func_name) {
                continue;
            }

            let expr = symbols
                .get(&specialize_info.org_func_name)
                .unwrap()
                .expr
                .as_ref()
                .unwrap()
                .clone();
            let expr = unique_local_names::run_on_expr(&expr, Set::default()); // Preconditions for decapturing optimization

            // Generate a map from argument names to `DecapturedLambdaInfo`
            let mut local_decap_lambdas = Map::default();
            let (args, _) = expr.destructure_lam_sequence();
            for (i, decap_lam) in &specialize_info.specialized_args {
                assert!(*i < args.len());
                assert_eq!(args[*i].len(), 1);
                let arg_name = &args[*i][0].name;
                local_decap_lambdas.insert(arg_name.clone(), decap_lam.clone());
            }

            // Perform specialization
            let mut visitor = DecapturingVisitor::new(
                specialized_func_name.clone(),
                specializable_funcs.clone(),
                global_names.clone(),
            );
            visitor.local_decap_lambdas = local_decap_lambdas;
            let trav_res = visitor.traverse(&expr);
            let expr = trav_res.expr;

            // Extract the generated decaptured lambdas and type constructors
            for decap_lam in visitor.decap_lambdas {
                let decap_lam_sym = decap_lam.make_symbol();
                global_names.insert(decap_lam_sym.name.clone());
                symbols.insert(decap_lam_sym.name.clone(), decap_lam_sym);
                new_tycons.insert(decap_lam.tycon, decap_lam.tycon_info);
            }

            // Register the specialized function
            let specialized_func = Symbol {
                name: specialized_func_name.clone(),
                generic_name: specialize_info.org_func_name.clone(),
                ty: specialized_func_ty,
                expr: Some(expr),
            };
            symbols.insert(specialized_func_name.clone(), specialized_func);
            global_names.insert(specialized_func_name.clone());

            // Register the new specialization requests.
            new_specializations.append(&mut visitor.required_specializations);
        }
        specializations = new_specializations;
    }
    drop(sw);

    prg.type_env.add_tycons(new_tycons);
    prg.symbols = symbols;
    changed
}

// Compute the set of specializable functions.
//
// More precisely, it calculates whether a certain parameter of a function is specializable or not.
//
// Specialization can cause infinite loops.
// For example, suppose a function `f` takes a closure `p` as its first parameter. `f` creates a new closure `q` that captures `p` and calls `f(q)`.
// In this case, if the parameter `p` of `f` is specialized, it will require an infinite number of specializations for different types.
//
// To avoid infinite loops, we only specialize a parameter `p` of a function `f` that satisfies the following conditions:
// - If `f` calls a function `g` other than itself, there should not be a path from `g` to `f` in the call graph.
// - Assume that `p` is the i-th index of `f`. The call to `f` in `f` must also pass `p` as the i-th index.
//
// This is only a sufficient condition to avoid infinite loops. More generally, we should solve the following problem:
// Consider a graph consisting of all parameters (of function type) of all functions.
// In other words, each node is a pair `(f, p)` where `f` is a function and `p` is a parameter that has a function type.
// An edge from `(f, p)` to `(g, q)` exists if `f` calls `g`, and the expression given to parameter `q` directly or indirectly captures lambda `p`.
// Finally, assign a weight of 0 or 1 to the edge: if the capture list types of `p` and `q` are the same, the weight is 0; otherwise, it is 1.
//
// If there is a cycle with positive cost in this graph, an infinite loop will occur.
// Choosing specializable arguments is equivalent to removing some nodes from this graph so that there is no cycle with positive cost.
// This is a more difficult problem than the Feedback Vertex Set problem, so we need to rely on heuristics.
//
// Finally, even if a parameter is a specializable, if it is not worth specializing or the inline cost of the function is high, it is returned as impossible to specialize.
fn specializable_functions(prg: &Program) -> Map<FullName, SpecializableFunctionInfo> {
    let inline_costs = inline::calculate_inline_costs(prg);
    let call_graph = prg.call_graph();
    let call_graph_scc = call_graph.compute_sccs();

    // Sort the indices of the nodes in the call graph in the order from downstream to upstream of the SCC to which they belong.
    let mut call_graph_indices = (0..call_graph.len()).collect::<Vec<_>>();
    call_graph_indices.sort_by(|a, b| {
        let a_scc = call_graph_scc[*a];
        let b_scc = call_graph_scc[*b];
        b_scc.cmp(&a_scc)
    });

    let mut specializable_funcs: Map<FullName, SpecializableFunctionInfo> = Map::default();
    for call_graph_idx in call_graph_indices {
        let sym_name = call_graph.get(call_graph_idx);
        let sym = prg.symbols.get(sym_name).unwrap();
        let expr = sym.expr.as_ref().unwrap();

        // If `sym` calls other nodes in the same SCC, avoid specialization to prevent the risk of an infinite loop.
        let mut prevent_specialization = false;
        for other_sym in expr.free_vars() {
            let other_sym_idx = call_graph.find_index(&other_sym).unwrap();
            if call_graph_scc[call_graph_idx] != call_graph_scc[other_sym_idx] {
                assert!(call_graph_scc[call_graph_idx] < call_graph_scc[other_sym_idx]);
                continue;
            }
            if call_graph_idx != other_sym_idx {
                prevent_specialization = true;
                break;
            }
        }
        if prevent_specialization {
            continue;
        }

        // Compute information on how `sym` calls itself.
        let self_usages = find_usage_of_name::run(expr, &sym_name);
        let self_recursive = self_usages.len() > 0;

        // Check if each parameter of `sym` is specializable.
        let (params, body) = expr.destructure_lam_sequence();
        let params = params
            .iter()
            .map(|may_multi_param| {
                assert_eq!(may_multi_param.len(), 1);
                may_multi_param[0].name.clone()
            })
            .collect::<Vec<_>>();
        let param_tys = sym.ty.collect_app_src(usize::MAX).0;
        let mut specializable_arg_indices = Vec::new();
        for param_idx in 0..params.len() {
            // Determine whether the parameter of `sym` is specializable.

            // A specializable argument must have a type of function.
            if !param_tys[param_idx].is_closure() {
                continue;
            }

            // If a call to `sym` is made with a different argument than `param`, it is not specializable.
            let mut specializable = true;
            for self_usage in self_usages.iter() {
                match self_usage {
                    UsageType::FunctionArgument(_, _) => {
                        continue;
                    }
                    UsageType::CalledAsFunction(args) => {
                        if args.len() <= param_idx {
                            continue;
                        }
                        let arg = &args[param_idx];
                        if arg.is_var() && arg.get_var().name == params[param_idx] {
                            continue;
                        }
                        specializable = false;
                        break;
                    }
                }
            }
            if !specializable {
                continue;
            }

            // Collect the usage information of the parameter.
            let param_name = &params[param_idx];
            let param_is_shadowd_by_another_param = params[param_idx + 1..]
                .iter()
                .any(|name| name == param_name);
            let usages = if param_is_shadowd_by_another_param {
                // If the parameter is shadowed by another parameter, it is not used.
                vec![]
            } else {
                find_usage_of_name::run(&body, param_name)
            };

            // Check each usage of the parameter.
            let mut passed_to_specializable_parameter = false;
            let mut called = false;
            for usage in usages {
                match usage {
                    UsageType::CalledAsFunction(_) => {
                        called = true;
                        continue;
                    }
                    UsageType::FunctionArgument(fun, idx) => {
                        if fun.is_local() {
                            continue;
                        }
                        if let Some(specialization) = specializable_funcs.get(&fun) {
                            if specialization.specializable_arg_indices.contains(&idx) {
                                passed_to_specializable_parameter = true;
                            }
                        }
                    }
                }
            }

            let inline_cost = inline_costs.costs.get(sym_name).unwrap();
            let worth_specialized = (self_recursive || inline_cost.inline_at_call_site())
                && (called || passed_to_specializable_parameter);

            if !worth_specialized {
                continue;
            }

            // After all, this parmeter is specializable!
            specializable_arg_indices.push(param_idx);
        }
        if specializable_arg_indices.is_empty() {
            continue;
        }
        specializable_funcs.insert(
            sym_name.clone(),
            SpecializableFunctionInfo {
                specializable_arg_indices,
            },
        );
    }
    specializable_funcs
}

// Expression visitor for decapturing optimization
struct DecapturingVisitor {
    /* Decapturing */
    // Information of decaptured lambdas generated by this optimization
    decap_lambdas: Vec<DecapturedLambdaInfo>,
    // When a decaptured lambda is given a local name, it is stored here.
    local_decap_lambdas: Map<FullName, DecapturedLambdaInfo>,

    /* Specialization */
    // Specializable functions
    specializable_funcs: Rc<Map<FullName, SpecializableFunctionInfo>>,
    // Specialization requests generated by decapturing
    required_specializations: Vec<SpecializationRequest>,

    /* Fields related to name generation of lambda function */
    // Counter used to generate lambda function names
    lam_func_counter: u32,
    // Name of the symbol currently being optimized
    // Used to generate the names of lambda functions.
    current_symbol: FullName,
    // Set of global names
    // Used to avoid name collisions when generating new global names.
    global_names: Set<FullName>,
}

impl DecapturingVisitor {
    // Create a new visitor
    fn new(
        current_symbol: FullName,
        specializable_funcs: Rc<Map<FullName, SpecializableFunctionInfo>>,
        global_names: Set<FullName>,
    ) -> Self {
        DecapturingVisitor {
            decap_lambdas: Vec::new(),
            local_decap_lambdas: Map::default(),
            specializable_funcs,
            required_specializations: Vec::new(),
            lam_func_counter: 0,
            current_symbol,
            global_names,
        }
    }

    // Generate a new lambda function name.
    fn new_lambda_func_name(&mut self) -> FullName {
        loop {
            let mut full_name = self.current_symbol.clone();
            *full_name.name_as_mut() += &format!("#decap_lam{}", self.lam_func_counter);
            self.lam_func_counter += 1;
            if self.global_names.contains(&full_name) {
                continue;
            }
            self.global_names.insert(full_name.clone());
            return full_name;
        }
    }

    // Is the `decapture_lambda` function applicable?
    fn decapturable(expr: &Arc<ExprNode>) -> bool {
        // If the expression is a not lambda expression, it is not decapturable.
        if !expr.is_lam() {
            return false;
        }

        let body = expr.get_lam_body();
        if body.free_vars().contains(&FullName::local(CAP_NAME)) {
            return false;
        }

        true
    }

    // Decapture a lambda expression.
    //
    // Returns `DecapturedLambdaInfo` and the expression that generates the capture list.
    fn decapture_lambda(
        &mut self,
        mut lam: Arc<ExprNode>,
        state: &mut crate::ast::traverse::VisitState,
    ) -> (DecapturedLambdaInfo, Arc<ExprNode>) {
        // Get the capture list.
        let cap_names = lam.lambda_cap_names();

        // If the lambda captures a decaptured lambda, visit `lam` in advance to ensure that the decaptured lambda in `lam` is processed.
        for cap_name in &cap_names {
            if self.local_decap_lambdas.contains_key(cap_name) {
                let lam_visit_res = self.visit_expr(&lam, state);
                lam = self.revisit_if_changed(lam_visit_res, state).expr;
                break;
            }
        }

        // For each captured name, get its type.
        let cap_names_types = cap_names
            .iter()
            .map(|name| {
                let ty = state.scope.get_local(&name.name).unwrap().unwrap();
                (name.clone(), ty.clone())
            })
            .collect::<Vec<_>>();

        // Create the type for the capture list struct.
        let tycon_hash_data = cap_names_types
            .iter()
            .map(|(name, ty)| format!("{}:{}", name.to_string(), ty.to_string()))
            .collect::<Vec<_>>()
            .join(",");
        // let tycon_hash = format!("{:x}", md5::compute(tycon_hash_data));
        let tycon_hash = tycon_hash_data;
        let tycon_name = TyCon {
            name: FullName::from_strs(&[STD_NAME], &format!("#CapList<{}>", tycon_hash)),
        };
        let tycon = Arc::new(tycon_name);
        let tycon_info = TyConInfo {
            kind: kind_star(),
            variant: crate::ast::types::TyConVariant::Struct,
            is_unbox: true,
            tyvars: vec![],
            fields: cap_names_types
                .iter()
                .map(|(name, ty)| Field {
                    name: name.name.clone(),
                    ty: ty.clone(),
                    syn_ty: None,
                    is_punched: false,
                    source: None,
                })
                .collect(),
            source: None,
            document: None,
        };
        let cap_list_ty = type_tycon(&tycon);

        // Create the capture list expression.
        let cap_list_expr = expr_make_struct(
            tycon.clone(),
            cap_names_types
                .iter()
                .map(|(name, ty)| {
                    let var = expr_var(name.clone(), None).set_type(ty.clone());
                    (name.to_string(), var)
                })
                .collect(),
        )
        .set_type(cap_list_ty.clone());

        // Create the lambda function.
        // To do this, add an argument to lam to receive the capture list, and insert a let expression at the beginning of the body to destructure the capture list.
        let cap_pats = cap_names_types
            .iter()
            .map(|(name, ty)| {
                let var = var_var(name.clone());
                let pat = PatternNode::make_var(var, None).set_type(ty.clone());
                (name.to_string(), pat)
            })
            .collect::<Vec<_>>();
        let cap_pat =
            PatternNode::make_struct(tycon.clone(), cap_pats).set_type(cap_list_ty.clone());
        let new_body = expr_let_typed(
            cap_pat,
            expr_var(FullName::local(DECAP_NAME), None).set_type(cap_list_ty.clone()),
            lam.clone(),
        );
        let new_arg = var_local(DECAP_NAME);
        let new_lam = expr_abs_typed(new_arg, cap_list_ty.clone(), new_body);
        let new_lam = internalize_let_to_var_at_head(&new_lam);
        let lambda_func_name = self.new_lambda_func_name();
        let decap_lam = DecapturedLambdaInfo {
            tycon: tycon.as_ref().clone(),
            tycon_info,
            cap_list_ty,
            lambda_func: new_lam,
            lambda_func_name,
        };
        self.decap_lambdas.push(decap_lam.clone());
        (decap_lam, cap_list_expr)
    }
}

// Information of specializable functions
#[derive(Clone)]
struct SpecializableFunctionInfo {
    // Indices of specializable arguments (ascending order)
    specializable_arg_indices: Vec<usize>,
}

// Information of specialization requests
struct SpecializationRequest {
    // Name of the function to be specialized
    org_func_name: FullName,
    // Type of the function to be specialized
    org_func_ty: Arc<TypeNode>,
    // Map from index of specialized argument to the decaptured lambda passed there
    specialized_args: Map<usize, DecapturedLambdaInfo>,
}

impl SpecializationRequest {
    // Generate the name of the specialized function.
    fn specialized_func_name(&self) -> FullName {
        let mut full_name = self.org_func_name.clone();
        let name = full_name.name_as_mut();
        *name += "#specialized";
        let mut hash_data = String::new();
        for (i, decap_lam) in self.specialized_args.iter() {
            hash_data += &format!(",{}", i);
            hash_data += &format!(",{}", decap_lam.lambda_func_name.to_string());
        }
        *name += &format!("_{:x}", md5::compute(hash_data));
        full_name
    }

    // Create the type of the specialized function
    fn specialized_func_ty(&self) -> Arc<TypeNode> {
        // Decompose the function type `A1 -> A2 -> ... -> An -> B` into `([A1, A2, ..., An], B)`,
        // and replace the type of the specialized arguments with the type of the capture list.
        let org_ty = self.org_func_ty.clone();
        let (mut doms, codom) = org_ty.collect_app_src(usize::MAX);
        for (i, decap_lam) in self.specialized_args.iter() {
            let cap_list_ty = decap_lam.cap_list_ty.clone();
            doms[*i] = cap_list_ty;
        }

        // Convert back to a function type
        let mut func_ty = codom;
        for dom in doms.iter().rev() {
            func_ty = type_fun(dom.clone(), func_ty);
        }

        func_ty
    }

    // Create an expression to refer to the specialized function.
    fn specialized_func_expr(&self) -> Arc<ExprNode> {
        expr_var(self.specialized_func_name(), None).set_type(self.specialized_func_ty())
    }
}

// デキャプチャしたラムダ式の情報を保持する構造体
#[derive(Clone)]
struct DecapturedLambdaInfo {
    // Type constructor for the capture list
    tycon: TyCon,
    tycon_info: TyConInfo,
    // Type of the capture list
    cap_list_ty: Arc<TypeNode>,
    // Lambda function
    lambda_func: Arc<ExprNode>,
    // Name of the lambda function
    lambda_func_name: FullName,
}

impl DecapturedLambdaInfo {
    // Create a symbol for the lambda function generated by decapturing
    fn make_symbol(&self) -> Symbol {
        Symbol {
            name: self.lambda_func_name.clone(),
            generic_name: self.lambda_func_name.clone(),
            ty: self.lambda_func.type_.as_ref().unwrap().clone(),
            expr: Some(self.lambda_func.clone()),
        }
    }
}

impl ExprVisitor for DecapturingVisitor {
    fn start_visit_var(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        // If `expr` refers to a decaptured lambda, and
        // the type of this expression is T, and the lambda function type is C->T (C is the capture list type),
        // replace it with an expression that applies the lambda function to the capture list.

        // Get the name
        let name = &expr.get_var().name;

        // Check that the variable name is local.
        if !name.is_local() {
            return StartVisitResult::VisitChildren;
        }

        // Check if this name refers to a decaptured lambda.
        let decap_lambda = self.local_decap_lambdas.get(name);
        if decap_lambda.is_none() {
            return StartVisitResult::VisitChildren;
        }
        let decap_lambda = decap_lambda.unwrap();

        // If the required type for this expression is already the capture list type, do nothing.
        let expr_ty = expr.type_.as_ref().unwrap().clone();
        let cap_list_ty = decap_lambda.cap_list_ty.clone();
        if expr_ty.to_string() == cap_list_ty.to_string() {
            return StartVisitResult::VisitChildren;
        }

        // Check that the required type for this expression matches the codomain of the lambda function.
        let lambda_ty = decap_lambda.lambda_func.type_.as_ref().unwrap();
        let lambda_codom_ty = lambda_ty.get_lambda_dst();
        assert_eq!(expr_ty.to_string(), lambda_codom_ty.to_string());

        // Replace with an expression that applies the lambda function to the capture list.
        let lam = expr_var(decap_lambda.lambda_func_name.clone(), None).set_type(lambda_ty.clone());
        let expr = expr_app_typed(lam, vec![expr.set_type(cap_list_ty)]);
        StartVisitResult::ReplaceAndRevisit(expr)
    }

    fn end_visit_var(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_llvm(
        &mut self,
        llvm_expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        // If any free variable in the LLVM expression refers to a decaptured lambda,
        // replace it with an expression that applies the lambda function to the capture list.

        let mut replace = Map::default(); // Data for replacing free variables in the LLVM expression
        for free_name in llvm_expr.free_vars() {
            let opt_decap_lambda = self.local_decap_lambdas.get(&free_name);
            if opt_decap_lambda.is_none() {
                continue;
            }
            let decap_lambda = opt_decap_lambda.unwrap();

            // Create an expression that applies the lambda function to the capture list.
            let lambda_ty = decap_lambda.lambda_func.type_.as_ref().unwrap();
            let lam =
                expr_var(decap_lambda.lambda_func_name.clone(), None).set_type(lambda_ty.clone());
            let name_expr =
                expr_var(free_name.clone(), None).set_type(decap_lambda.cap_list_ty.clone());
            let expr = expr_app_typed(lam, vec![name_expr]);

            replace.insert(free_name.clone(), expr);
        }

        // If none of the free variables in the LLVM expression refer to a decaptured lambda, do nothing.
        if replace.is_empty() {
            return StartVisitResult::VisitChildren;
        }

        let make_new_name = |name: &FullName| {
            let mut new_name = name.clone();
            new_name.name_as_mut().push_str("#call_decap_lam");
            new_name
        };

        // Rename free variables in the LLVM expression
        let mut llvm_expr = llvm_expr.clone();
        let mut rename: Map<FullName, FullName> = Default::default();
        for (name, _) in replace.iter() {
            rename.insert(name.clone(), make_new_name(name));
        }
        llvm_expr = rename_free_names(&llvm_expr, rename);

        // Insert `let (new name) = (lambda function call);` before the LLVM expression
        let mut expr = llvm_expr.clone();
        for (name, call_lam_expr) in replace.iter() {
            let new_name = make_new_name(name);
            expr = expr_let_typed(
                PatternNode::make_var(var_var(new_name.clone()), None)
                    .set_type(call_lam_expr.type_.as_ref().unwrap().clone()),
                call_lam_expr.clone(),
                expr.clone(),
            );
        }

        StartVisitResult::ReplaceAndRevisit(expr)
    }

    fn end_visit_llvm(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_app(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        // Perform closure specialization if this application expression meets the following conditions:
        // - The called function is specializable, and a specializable argument is either a lambda expression or an already decaptured lambda (i.e., a capture list).

        let (func, args) = expr.destructure_app();

        // Check that `func` is a global function.
        if !func.is_var() {
            return StartVisitResult::VisitChildren;
        }
        let func_name = &func.get_var().name;
        if !func_name.is_global() {
            return StartVisitResult::VisitChildren;
        }

        // Check that `func` is a specializable function.
        let specializable_func = self.specializable_funcs.get(func_name);
        if specializable_func.is_none() {
            return StartVisitResult::VisitChildren;
        }
        let specialize_info = specializable_func.unwrap().clone();

        // For each specializable argument of `func`, get or generate decaptured lambda information.
        let mut specialized_args = Map::default();
        let mut decaptured_args = args.clone();
        for (i, arg) in args.iter().enumerate() {
            // Check if this is a specializable argument.
            if !specialize_info.specializable_arg_indices.contains(&i) {
                continue;
            }
            // Get or generate decaptured lambda information.
            if arg.is_var() {
                let arg_name = &arg.get_var().name;
                if let Some(decap_info) = self.local_decap_lambdas.get(arg_name) {
                    specialized_args.insert(i, decap_info.clone());
                    decaptured_args[i] = arg.set_type(decap_info.cap_list_ty.clone());
                }
            } else if DecapturingVisitor::decapturable(arg) {
                // TODO: maybe we don't need to handle this case, because pull-let transformation converts this argument to a variable?
                let (decap_info, expr) = self.decapture_lambda(arg.clone(), state); // Visits `arg` inside this call
                specialized_args.insert(i, decap_info.clone());
                decaptured_args[i] = expr;
            }
        }
        if specialized_args.is_empty() {
            return StartVisitResult::VisitChildren;
        }

        // Request specialization.
        let specialization = SpecializationRequest {
            org_func_name: func_name.clone(),
            org_func_ty: func.type_.as_ref().unwrap().clone(),
            specialized_args,
        };
        let specialized_func_expr = specialization.specialized_func_expr();
        self.required_specializations.push(specialization);

        // Replace with an expression that calls the specialized function.
        let mut expr = specialized_func_expr.clone();
        for arg in decaptured_args {
            expr = expr_app_typed(expr, vec![arg]);
        }

        StartVisitResult::ReplaceAndRevisit(expr)
    }

    fn end_visit_app(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_lam(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        // Before visiting children, if the argument refers to a decaptured lambda, fix the domain part of the lambda type since it is incorrect.
        let arg = expr.get_lam_params();
        assert_eq!(arg.len(), 1);
        let arg = &arg[0];
        let arg_name = &arg.name;
        let opt_local_decap_lambda = self.local_decap_lambdas.get(arg_name);
        // If the argument does not refer to a decaptured lambda, do nothing.
        if opt_local_decap_lambda.is_none() {
            return StartVisitResult::VisitChildren;
        }
        let local_decap_lambda = opt_local_decap_lambda.unwrap();
        let cap_list_ty = local_decap_lambda.cap_list_ty.clone();
        let lam_ty = expr.type_.as_ref().unwrap();
        let arg_ty = lam_ty.get_lambda_srcs()[0].clone();
        // If the argument type is already correct, do nothing.
        if cap_list_ty.to_string() == arg_ty.to_string() {
            return StartVisitResult::VisitChildren;
        }
        // Fix the type of this lambda expression
        let new_lambda_ty = type_fun(cap_list_ty, lam_ty.get_lambda_dst());
        let expr = expr.set_type(new_lambda_ty);
        return StartVisitResult::ReplaceAndRevisit(expr);
    }

    fn end_visit_lam(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        // After visiting children, the codomain type of this expression may have changed, so fix the type if necessary.
        // Example: In `expr` is a lambda `|x| |y| (...)`, if `y` is a decaptured lambda, visiting `|y| (...)` may change its type, so the codomain of `|x| |y| (...)` may need to be fixed.
        let lam_ty = expr.type_.as_ref().unwrap();
        let dom_ty = lam_ty.get_lambda_srcs()[0].clone();
        let codom_ty = lam_ty.get_lambda_dst().clone();
        let lam_body = expr.get_lam_body();
        let impl_codom_ty = lam_body.type_.as_ref().unwrap();
        if codom_ty.to_string() == impl_codom_ty.to_string() {
            return EndVisitResult::unchanged(expr);
        }
        let new_lambda_ty = type_fun(dom_ty, impl_codom_ty.clone());
        let expr = expr.set_type(new_lambda_ty);
        EndVisitResult::changed(expr)
    }

    fn start_visit_let(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        let pat = expr.get_let_pat();
        let bound = expr.get_let_bound();
        let value = expr.get_let_value();
        if DecapturingVisitor::decapturable(&bound) {
            // If the bound expression is a lambda, perform decapturing.
            assert!(pat.is_var());
            let var_name = pat.get_var().name.clone();
            let (decap_lam, cap_list) = self.decapture_lambda(bound, state); // visit `bound` inside this call
            self.decap_lambdas.push(decap_lam.clone());
            self.local_decap_lambdas.insert(var_name.clone(), decap_lam);
            let pat = pat
                .set_var_tyanno(None) // Discard type annotation since it may become incorrect
                .set_type(cap_list.type_.as_ref().unwrap().clone());
            let expr = expr_let_typed(pat, cap_list, value);
            return StartVisitResult::ReplaceAndRevisit(expr);
        } else if pat.is_var() && bound.is_var() {
            let name = &bound.get_var().name;
            let opt_local_decap_lambda = self.local_decap_lambdas.get(name);
            if opt_local_decap_lambda.is_none() {
                return StartVisitResult::VisitChildren;
            }
            // In the case the bound expression is a variable referring to a decaptured lambda,
            // add the variable introduced by this let binding to `self.local_decap_lambdas`.
            let local_decap_lambda = opt_local_decap_lambda.unwrap().clone();
            self.local_decap_lambdas
                .insert(pat.get_var().name.clone(), local_decap_lambda.clone());

            // Set the type of the pattern and the bound expression to the capture list type.
            let bound_old_ty = bound.type_.as_ref().unwrap();
            let pat_old_ty = pat.info.type_.as_ref().unwrap();
            let cap_list_ty = local_decap_lambda.cap_list_ty.clone();
            if bound_old_ty.to_string() == cap_list_ty.to_string()
                && pat_old_ty.to_string() == cap_list_ty.to_string()
            {
                // If the types are already correct, do nothing.
                return StartVisitResult::VisitChildren;
            }
            // Fix the types in this let expression.
            let pat = pat.set_type(cap_list_ty.clone());
            let bound = bound.set_type(cap_list_ty);
            let expr = expr_let_typed(pat, bound, value);
            return StartVisitResult::ReplaceAndRevisit(expr);
        } else {
            return StartVisitResult::VisitChildren;
        }
    }

    fn end_visit_let(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_if(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_if(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_match(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_match(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_tyanno(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_tyanno(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_make_struct(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_make_struct(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_array_lit(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_array_lit(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_ffi_call(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_ffi_call(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_eval(
        &mut self,
        _expr: &Arc<ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_eval(
        &mut self,
        expr: &Arc<ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> EndVisitResult {
        EndVisitResult::unchanged(expr)
    }
}
