use std::{rc::Rc, sync::Arc};

use crate::{
    ast::{
        expr::{
            expr_abs_typed, expr_app_typed, expr_let_typed, expr_make_struct, expr_var, var_local,
            var_var, ExprNode,
        },
        name::FullName,
        pattern::PatternNode,
        program::{Program, Symbol},
        traverse::{EndVisitResult, ExprVisitor, StartVisitResult},
        typedecl::Field,
        types::{kind_star, type_fun, type_tycon, TyCon, TyConInfo, TypeNode},
    },
    constants::{DECAP_NAME, STD_NAME},
    misc::{Map, Set},
    optimization::utils::replace_free_var_of_expr,
};

use super::{uncurry::internalize_let_to_var_at_head, unify_local_names};

/*
# Decapturing optimization

## Overview

### Decapturing

For each lambda expression, a structure is defined that summarizes the values captured by that lambda expression.
And the lambda expression is defined as a global function.

For example, consider the following lambda expression:
```
let f = |x| x + n;
```

Then, the following structure and global function are defined:
```
type #DecapF = unbox struct { n: I64 };

#lamf : #DecapF -> I64 -> I64;
#lamf = |{ n : n }, x| x + n;
```

The creation of the lambda value is replaced with `#DecapF { n : n }`.
```
let f = #DecapF { n : n };
```

### Rewriting the usage of the lambda

The call of the decaptured lambda expression `f(x)` is transformed into the following code.
```
#lamf(f, x)
```

In principle, `f` is replaced with `#lamf(f)` in places where `f` appears alone (i.e., not in a call expression).
However, in cases where "closure specialization" can be applied, `f` is left as is.

### Closure specialization

Consider the case where a lambda is given as an argument to a global function.
As an example, consider the case where `f` is passed as the second argument to `fold`.

```
fold : S -> (A -> S -> S) -> Iter -> S;
fold = |s, op, iter| (
    match iter.advance {
        none() => s,
        some((iter, a)) => iter.fold(op(a, s), op)
    }
);
```

```
it.fold(s0, f)
```

In this case, the following code is generated.
This is called as "closure specialization".

```
fold#lamf : S -> #DecapF -> Iter -> S;
fold#lamf = |s, op, iter| (
    match iter.advance {
        none() => s,
        some((iter, a)) => iter.fold#lamf(#lamf(op, a, s), op)
    }
);
```

```
it.fold#lamf(s0, f)
```

## Applicable range and limitations

### The path from defining a lambda to using it

If a lambda is defined and used as is, decapturing optimization is applied.
Example: `iter.fold(s0, |acm, i| acm + i)`

If a lambda is defined in the right-hand side of a let statement and its name is used, decapturing optimization is applied.
Example: `let f = |acm, i| acm + i; iter.fold(s0, f)`

However, if the path from defining a lambda to using it is more complex than this, this optimization is not applied.
Example: `let (_, f) = (0, |acm, i| acm + i); iter.fold(s0, f)`

### Specializable functions

Specializable functions are determined by `is_specializable_func`.
Currently, we explicitly specify a few functions in `Std` as specializable functions.
The determination of whether a function is specializable is somewhat difficult (it may lead to an infinite loop) and is under consideration.

## Relations to other optimizations

* Inline expansion should be performed before this optimization. For example, the expression `f >> g` is replaced with a lambda expression by inline expansion, making it a target of this optimization.
* It may be worth performing inline expansion after this optimization. This is because global functions are generated by this optimization, and inline expansion may be performed on them.
* It may be worth performing inline expansion before this optimization. This is because the number of arguments that can be specialized increases due to eta expansion.
* To improve the performance of global functions generated by this optimization, uncurrying should be performed after this optimization.
*/

pub fn run(prg: &mut Program) {
    let mut stable_symbols = Set::default();
    while run_one(prg, &mut stable_symbols) {}
}

// Run optimization on all symbols.
// If any optimization is performed, return `true`.
//
// * `stable_symbols`: A set of symbols that are known to be stable (i.e., will not be optimized further).
pub fn run_one(prg: &mut Program, stable_symbols: &mut Set<FullName>) -> bool {
    // Whether optimization has been performed on any symbol.
    let mut changed = false;

    // Compute the set of specializable functions.
    let specializable_funcs = specializable_functions(prg);
    let specializable_funcs = Rc::new(specializable_funcs);

    let symbols = std::mem::take(&mut prg.symbols);
    let mut new_tycons = Map::default();

    // Create a set of global names
    let mut global_names = Set::default();
    for (name, _) in &symbols {
        global_names.insert(name.clone());
    }

    // Perform decapturing optimization on each symbol
    let mut new_symbols: Map<FullName, Symbol> = Map::default();
    let mut specializations: Vec<SpecializationRequest> = Vec::new();
    for (name, mut sym) in symbols {
        // Skip symbols that are already known to be stable and will not change.
        if stable_symbols.contains(&name) {
            new_symbols.insert(name.clone(), sym.clone());
            continue;
        }

        let mut visitor = DecapturingVisitor::new(
            name.clone(),
            specializable_funcs.clone(),
            global_names.clone(),
        );

        // Perform decapturing optimization
        let expr = unify_local_names::run_on_expr(sym.expr.as_ref().unwrap(), Set::default()); // Preconditions for decapturing optimization
        let trav_res = visitor.traverse(&expr);
        if !trav_res.changed {
            // When no optimization is performed,
            stable_symbols.insert(name.clone());
            new_symbols.insert(name.clone(), sym.clone());
            continue;
        }
        changed = true;
        sym.expr = Some(trav_res.expr.calculate_free_vars());
        specializations.append(&mut visitor.required_specializations); // Specialization requests are processed later

        // Extract the generated decaptured lambdas and type constructors
        for decap_lam in visitor.decap_lambdas {
            let decap_lam_sym = decap_lam.make_symbol();
            global_names.insert(decap_lam_sym.name.clone());
            new_symbols.insert(decap_lam_sym.name.clone(), decap_lam_sym);
            new_tycons.insert(decap_lam.tycon, decap_lam.tycon_info);
        }

        new_symbols.insert(name.clone(), sym.clone());
    }
    let mut symbols = new_symbols;

    // Process specialization requests
    for specialize_info in specializations {
        // Generate the name and type of the specialized function
        let specialized_func_name = specialize_info.specialized_func_name();
        let specialized_func_ty = specialize_info.specialized_func_ty();

        // If it is already implemented, skip
        if symbols.contains_key(&specialized_func_name) {
            continue;
        }

        let expr = symbols
            .get(&specialize_info.org_func_name)
            .unwrap()
            .expr
            .as_ref()
            .unwrap()
            .clone();
        let expr = unify_local_names::run_on_expr(&expr, Set::default()); // Preconditions for decapturing optimization

        // Generate a map from argument names to `DecapturedLambdaInfo`
        let mut local_decap_lambdas = Map::default();
        let (args, _) = expr.destructure_lam_sequence();
        for (i, decap_lam) in &specialize_info.specialized_args {
            assert!(*i < args.len());
            assert_eq!(args[*i].len(), 1);
            let arg_name = &args[*i][0].name;
            local_decap_lambdas.insert(arg_name.clone(), decap_lam.clone());
        }

        // Perform specialization
        let mut visitor = DecapturingVisitor::new(
            specialized_func_name.clone(),
            specializable_funcs.clone(),
            global_names.clone(),
        );
        visitor.local_decap_lambdas = local_decap_lambdas;
        let trav_res = visitor.traverse(&expr);
        let expr = trav_res.expr.calculate_free_vars();

        // Extract the generated decaptured lambdas and type constructors
        for decap_lam in visitor.decap_lambdas {
            let decap_lam_sym = decap_lam.make_symbol();
            global_names.insert(decap_lam_sym.name.clone());
            symbols.insert(decap_lam_sym.name.clone(), decap_lam_sym);
            new_tycons.insert(decap_lam.tycon, decap_lam.tycon_info);
        }

        // Register the specialized function
        let specialized_func = Symbol {
            name: specialized_func_name.clone(),
            generic_name: specialize_info.org_func_name.clone(),
            ty: specialized_func_ty,
            expr: Some(expr),
        };
        symbols.insert(specialized_func_name.clone(), specialized_func);
        global_names.insert(specialized_func_name.clone());

        // TODO: After more functions become specializable in the future, additional specialization requests may occur here, so it is necessary to process them in a loop.
    }

    prg.type_env.add_tycons(new_tycons);
    prg.symbols = symbols;
    changed
}

fn specializable_functions(prg: &Program) -> Map<FullName, SpecializableFunctionInfo> {
    let mut specializable_funcs = Map::default();
    for (name, sym) in &prg.symbols {
        if let Some(specialize_info) = is_specializable(sym) {
            specializable_funcs.insert(name.clone(), specialize_info);
        }
    }
    specializable_funcs
}

// Judge whether a symbol is specializable. If it is specializable, generate `SpecializableFunctionInfo`.
fn is_specializable(sym: &Symbol) -> Option<SpecializableFunctionInfo> {
    // Prefix of specializable functions and index of specializable arguments.
    const SPECIALIZABLE_FUNC_TABLE: [(&str, usize); 5] = [
        ("Std::loop#", 1),
        ("Std::loop_iter#", 1),
        ("Std::loop_iter_m#", 1),
        ("Std::Iterator::fold#", 1),
        ("Std::Iterator::fold_m#", 1),
    ];
    let name = sym.name.clone();
    let name_str = name.to_string();
    for (specializable_func, arg_index) in SPECIALIZABLE_FUNC_TABLE.iter() {
        if !name_str.starts_with(*specializable_func) {
            continue;
        }
        let param_tys = sym.ty.collect_app_src(usize::MAX).0;
        if param_tys.len() < 2 || !param_tys[*arg_index].is_closure() {
            return None;
        }
        return Some(SpecializableFunctionInfo {
            specializable_arg_indices: vec![*arg_index],
        });
    }
    return None;

    // TODO: Plan for future improvement of specializability judgment:
    //
    // The following gives sufficient conditions:
    // Decompose the call graph into strongly connected components.
    // If only nodes downstream from itself are called, it's OK.
    // Otherwise, if it only calls itself with the same arguments, it's OK; otherwise, avoid to specialize it.
    //
    // Also, inline cost should be considered for specializability.
    // Reference code:
    // let complexity = self.inline_costs.get_complexity(func_name);
    // if complexity.is_none() {
    //     return StartVisitResult::VisitChildren;
    // }
    // let complexity = complexity.unwrap();
    // let call_count = self.inline_costs.get_call_count(func_name);
    // if complexity * call_count > INLINE_COST_THRESHOLD {
    //     return StartVisitResult::VisitChildren;
    // }
}

// Expression visitor for decapturing optimization
struct DecapturingVisitor {
    /* Decapturing */
    // Information of decaptured lambdas generated by this optimization
    decap_lambdas: Vec<DecapturedLambdaInfo>,
    // When a decaptured lambda is given a local name, it is stored here.
    local_decap_lambdas: Map<FullName, DecapturedLambdaInfo>,

    /* Specialization */
    // Specializable functions
    specializable_funcs: Rc<Map<FullName, SpecializableFunctionInfo>>,
    // Specialization requests generated by decapturing
    required_specializations: Vec<SpecializationRequest>,

    /* Fields related to name generation of lambda function */
    // Counter used to generate lambda function names
    lam_func_counter: u32,
    // Name of the symbol currently being optimized
    // Used to generate the names of lambda functions.
    current_symbol: FullName,
    // Set of global names
    // Used to avoid name collisions when generating new global names.
    global_names: Set<FullName>,
}

impl DecapturingVisitor {
    // Create a new visitor
    fn new(
        current_symbol: FullName,
        specializable_funcs: Rc<Map<FullName, SpecializableFunctionInfo>>,
        global_names: Set<FullName>,
    ) -> Self {
        DecapturingVisitor {
            decap_lambdas: Vec::new(),
            local_decap_lambdas: Map::default(),
            specializable_funcs,
            required_specializations: Vec::new(),
            lam_func_counter: 0,
            current_symbol,
            global_names,
        }
    }

    // Generate a new lambda function name.
    fn new_lambda_func_name(&mut self) -> FullName {
        loop {
            let mut full_name = self.current_symbol.clone();
            *full_name.name_as_mut() += &format!("#decap_lam{}", self.lam_func_counter);
            self.lam_func_counter += 1;
            if self.global_names.contains(&full_name) {
                continue;
            }
            self.global_names.insert(full_name.clone());
            return full_name;
        }
    }

    // Decapture a lambda expression.
    //
    // Returns `DecapturedLambdaInfo` and the expression that generates the capture list.
    fn decapture_lambda(
        &mut self,
        mut lam: Arc<ExprNode>,
        state: &mut crate::ast::traverse::VisitState,
    ) -> (DecapturedLambdaInfo, Arc<ExprNode>) {
        // Get the capture list.
        let cap_names = lam.lambda_cap_names();

        // If the lambda captures a decaptured lambda, visit `lam` in advance.
        for cap_name in &cap_names {
            if self.local_decap_lambdas.contains_key(cap_name) {
                let lam_visit_res = self.visit_expr(&lam, state);
                lam = self
                    .revisit_if_changed(lam_visit_res, state)
                    .expr
                    .calculate_free_vars();
                break;
            }
        }

        // For each captured name, get its type.
        let cap_names_types = cap_names
            .iter()
            .map(|name| {
                let ty = state.scope.get_local(&name.name).unwrap().unwrap();
                (name.clone(), ty.clone())
            })
            .collect::<Vec<_>>();

        // Create the type for the capture list struct.
        let tycon_hash_data = cap_names_types
            .iter()
            .map(|(name, ty)| format!("{},{}", name.to_string(), ty.to_string()))
            .collect::<Vec<_>>()
            .join(",");
        let tycon_hash = format!("{:x}", md5::compute(tycon_hash_data));
        let tycon_name = TyCon {
            name: FullName::from_strs(&[STD_NAME], &format!("#DecapList_{}", tycon_hash)),
        };
        let tycon = Arc::new(tycon_name);
        let tycon_info = TyConInfo {
            kind: kind_star(),
            variant: crate::ast::types::TyConVariant::Struct,
            is_unbox: true,
            tyvars: vec![],
            fields: cap_names_types
                .iter()
                .map(|(name, ty)| Field {
                    name: name.name.clone(),
                    ty: ty.clone(),
                    syn_ty: None,
                    is_punched: false,
                    source: None,
                })
                .collect(),
            source: None,
            document: None,
        };
        let cap_list_ty = type_tycon(&tycon);

        // Create the capture list expression.
        let cap_list_expr = expr_make_struct(
            tycon.clone(),
            cap_names_types
                .iter()
                .map(|(name, ty)| {
                    let var = expr_var(name.clone(), None).set_inferred_type(ty.clone());
                    (name.to_string(), var)
                })
                .collect(),
        )
        .set_inferred_type(cap_list_ty.clone());

        // Create the lambda function.
        // To do this, add an argument to lam to receive the capture list, and insert a let expression at the beginning of the body to destructure the capture list.
        let cap_pats = cap_names_types
            .iter()
            .map(|(name, ty)| {
                let var = var_var(name.clone());
                let pat = PatternNode::make_var(var, None).set_type(ty.clone());
                (name.to_string(), pat)
            })
            .collect::<Vec<_>>();
        let cap_pat =
            PatternNode::make_struct(tycon.clone(), cap_pats).set_type(cap_list_ty.clone());
        let new_body = expr_let_typed(
            cap_pat,
            expr_var(FullName::local(DECAP_NAME), None).set_inferred_type(cap_list_ty.clone()),
            lam.clone(),
        );
        let new_arg = var_local(DECAP_NAME);
        let new_lam = expr_abs_typed(new_arg, cap_list_ty.clone(), new_body);
        let new_lam = internalize_let_to_var_at_head(&new_lam);

        let decap_lam = DecapturedLambdaInfo {
            tycon: tycon.as_ref().clone(),
            tycon_info,
            cap_list_ty,
            lambda_func: new_lam,
            lambda_func_name: self.new_lambda_func_name(),
        };
        self.decap_lambdas.push(decap_lam.clone());
        (decap_lam, cap_list_expr)
    }
}

// Information of specializable functions
#[derive(Clone)]
struct SpecializableFunctionInfo {
    // Indices of specializable arguments (ascending order)
    specializable_arg_indices: Vec<usize>,
}

// Information of specialization requests
struct SpecializationRequest {
    // Name of the function to be specialized
    org_func_name: FullName,
    // Type of the function to be specialized
    org_func_ty: Arc<TypeNode>,
    // Map from index of specialized argument to the decaptured lambda passed there
    specialized_args: Map<usize, DecapturedLambdaInfo>,
}

impl SpecializationRequest {
    // Generate the name of the specialized function.
    fn specialized_func_name(&self) -> FullName {
        let mut full_name = self.org_func_name.clone();
        let name = full_name.name_as_mut();
        *name += "#specialized";
        let mut hash_data = String::new();
        for (i, decap_lam) in self.specialized_args.iter() {
            hash_data += &format!(",{}", i);
            hash_data += &format!(",{}", decap_lam.lambda_func_name.to_string());
        }
        *name += &format!("_{:x}", md5::compute(hash_data));
        full_name
    }

    // Create the type of the specialized function
    fn specialized_func_ty(&self) -> Arc<TypeNode> {
        // Decompose the function type `A1 -> A2 -> ... -> An -> B` into `([A1, A2, ..., An], B)`,
        // and replace the type of the specialized arguments with the type of the capture list.
        let org_ty = self.org_func_ty.clone();
        let (mut doms, codom) = org_ty.collect_app_src(usize::MAX);
        for (i, decap_lam) in self.specialized_args.iter() {
            let cap_list_ty = decap_lam.cap_list_ty.clone();
            doms[*i] = cap_list_ty;
        }

        // Convert back to a function type
        let mut func_ty = codom;
        for dom in doms.iter().rev() {
            func_ty = type_fun(dom.clone(), func_ty);
        }

        func_ty
    }

    // Create an expression to retrieve the specialized function
    fn specialized_func_expr(&self) -> Arc<ExprNode> {
        expr_var(self.specialized_func_name(), None).set_inferred_type(self.specialized_func_ty())
    }
}

// デキャプチャしたラムダ式の情報を保持する構造体
#[derive(Clone)]
struct DecapturedLambdaInfo {
    // Type constructor for the capture list
    tycon: TyCon,
    tycon_info: TyConInfo,
    // Type of the capture list
    cap_list_ty: Arc<TypeNode>,
    // Lambda function
    lambda_func: Arc<ExprNode>,
    // Name of the lambda function
    lambda_func_name: FullName,
}

impl DecapturedLambdaInfo {
    // Create a symbol for the lambda function generated by decapturing
    fn make_symbol(&self) -> Symbol {
        Symbol {
            name: self.lambda_func_name.clone(),
            generic_name: self.lambda_func_name.clone(),
            ty: self.lambda_func.ty.as_ref().unwrap().clone(),
            expr: Some(self.lambda_func.clone()),
        }
    }
}

impl ExprVisitor for DecapturingVisitor {
    fn start_visit_var(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        // If `expr` refers to a decaptured lambda, and
        // the type of this expression is T, and the lambda function type is C->T (C is the capture list type),
        // replace it with an expression that applies the lambda function to the capture list.

        // Get the name
        let name = &expr.get_var().name;

        // Check that the variable name is local.
        if !name.is_local() {
            return StartVisitResult::VisitChildren;
        }

        // Check if this name refers to a decaptured lambda.
        let decap_lambda = self.local_decap_lambdas.get(name);
        if decap_lambda.is_none() {
            return StartVisitResult::VisitChildren;
        }
        let decap_lambda = decap_lambda.unwrap();

        // If the required type for this expression is already the capture list type, do nothing.
        let expr_ty = expr.ty.as_ref().unwrap().clone();
        let cap_list_ty = decap_lambda.cap_list_ty.clone();
        if expr_ty.to_string() == cap_list_ty.to_string() {
            return StartVisitResult::VisitChildren;
        }

        // Check that the required type for this expression matches the codomain of the lambda function.
        let lambda_ty = decap_lambda.lambda_func.ty.as_ref().unwrap();
        let lambda_codom_ty = lambda_ty.get_lambda_dst();
        assert_eq!(expr_ty.to_string(), lambda_codom_ty.to_string());

        // Replace with an expression that applies the lambda function to the capture list.
        let lam = expr_var(decap_lambda.lambda_func_name.clone(), None)
            .set_inferred_type(lambda_ty.clone());
        let expr = expr_app_typed(lam, vec![expr.set_inferred_type(cap_list_ty)]);
        StartVisitResult::ReplaceAndRevisit(expr)
    }

    fn end_visit_var(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_llvm(
        &mut self,
        llvm_expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        // If any free variable in the LLVM expression refers to a decaptured lambda,
        // replace it with an expression that applies the lambda function to the capture list.

        let mut replace = Map::default(); // Data for replacing free variables in the LLVM expression
        for free_name in llvm_expr.free_vars() {
            let opt_decap_lambda = self.local_decap_lambdas.get(free_name);
            if opt_decap_lambda.is_none() {
                continue;
            }
            let decap_lambda = opt_decap_lambda.unwrap();

            // Create an expression that applies the lambda function to the capture list.
            let lambda_ty = decap_lambda.lambda_func.ty.as_ref().unwrap();
            let lam = expr_var(decap_lambda.lambda_func_name.clone(), None)
                .set_inferred_type(lambda_ty.clone());
            let name_expr = expr_var(free_name.clone(), None)
                .set_inferred_type(decap_lambda.cap_list_ty.clone());
            let expr = expr_app_typed(lam, vec![name_expr]);

            replace.insert(free_name.clone(), expr);
        }

        // If none of the free variables in the LLVM expression refer to a decaptured lambda, do nothing.
        if replace.is_empty() {
            return StartVisitResult::VisitChildren;
        }

        let make_new_name = |name: &FullName| {
            let mut new_name = name.clone();
            new_name.name_as_mut().push_str("#call_decap_lam");
            new_name
        };

        // Rename free variables in the LLVM expression
        let mut llvm_expr = llvm_expr.clone();
        for (name, _) in replace.iter() {
            let new_name = make_new_name(name);
            llvm_expr = replace_free_var_of_expr(&llvm_expr, name, &new_name);
        }

        // Insert `let (new name) = (lambda function call);` before the LLVM expression
        let mut expr = llvm_expr.clone();
        for (name, call_lam_expr) in replace.iter() {
            let new_name = make_new_name(name);
            expr = expr_let_typed(
                PatternNode::make_var(var_var(new_name.clone()), None)
                    .set_type(call_lam_expr.ty.as_ref().unwrap().clone()),
                call_lam_expr.clone(),
                expr.clone(),
            );
        }

        StartVisitResult::ReplaceAndRevisit(expr)
    }

    fn end_visit_llvm(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_app(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        // Perform closure specialization if this application expression meets the following conditions:
        // - The called function is specializable, and a specializable argument is either a lambda expression or an already decaptured lambda (i.e., a capture list).

        let (func, args) = expr.destructure_app();

        // Check that `func` is a global function.
        if !func.is_var() {
            return StartVisitResult::VisitChildren;
        }
        let func_name = &func.get_var().name;
        if !func_name.is_global() {
            return StartVisitResult::VisitChildren;
        }

        // Check that `func` is a specializable function.
        let specializable_func = self.specializable_funcs.get(func_name);
        if specializable_func.is_none() {
            return StartVisitResult::VisitChildren;
        }
        let specialize_info = specializable_func.unwrap().clone();

        // For each specializable argument of `func`, get or generate decaptured lambda information.
        let mut specialized_args = Map::default();
        let mut decaptured_args = args.clone();
        for (i, arg) in args.iter().enumerate() {
            // Check if this is a specializable argument.
            if !specialize_info.specializable_arg_indices.contains(&i) {
                continue;
            }
            // Get or generate decaptured lambda information.
            if arg.is_var() {
                let arg_name = &arg.get_var().name;
                if let Some(decap_info) = self.local_decap_lambdas.get(arg_name) {
                    specialized_args.insert(i, decap_info.clone());
                    decaptured_args[i] = arg.set_inferred_type(decap_info.cap_list_ty.clone());
                }
            } else if arg.is_lam() {
                let (decap_info, expr) = self.decapture_lambda(arg.clone(), state); // Visits `arg` inside this call
                specialized_args.insert(i, decap_info.clone());
                decaptured_args[i] = expr;
            }
        }
        if specialized_args.is_empty() {
            return StartVisitResult::VisitChildren;
        }

        // Request specialization.
        let specialization = SpecializationRequest {
            org_func_name: func_name.clone(),
            org_func_ty: func.ty.as_ref().unwrap().clone(),
            specialized_args,
        };
        let specialized_func_expr = specialization.specialized_func_expr();
        self.required_specializations.push(specialization);

        // Replace with an expression that calls the specialized function.
        let mut expr = specialized_func_expr.clone();
        for arg in decaptured_args {
            expr = expr_app_typed(expr, vec![arg]);
        }

        StartVisitResult::ReplaceAndRevisit(expr)
    }

    fn end_visit_app(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_lam(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        // Before visiting children, if the argument refers to a decaptured lambda, fix the domain part of the lambda type since it is incorrect.
        let arg = expr.get_lam_params();
        assert_eq!(arg.len(), 1);
        let arg = &arg[0];
        let arg_name = &arg.name;
        let opt_local_decap_lambda = self.local_decap_lambdas.get(arg_name);
        // If the argument does not refer to a decaptured lambda, do nothing.
        if opt_local_decap_lambda.is_none() {
            return StartVisitResult::VisitChildren;
        }
        let local_decap_lambda = opt_local_decap_lambda.unwrap();
        let cap_list_ty = local_decap_lambda.cap_list_ty.clone();
        let lam_ty = expr.ty.as_ref().unwrap();
        let arg_ty = lam_ty.get_lambda_srcs()[0].clone();
        // If the argument type is already correct, do nothing.
        if cap_list_ty.to_string() == arg_ty.to_string() {
            return StartVisitResult::VisitChildren;
        }
        // Fix the type of this lambda expression
        let new_lambda_ty = type_fun(cap_list_ty, lam_ty.get_lambda_dst());
        let expr = expr.set_inferred_type(new_lambda_ty);
        return StartVisitResult::ReplaceAndRevisit(expr);
    }

    fn end_visit_lam(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        // After visiting children, the codomain type of this expression may have changed, so fix the type if necessary.
        // Example: In `expr` is a lambda `|x| |y| (...)`, if `y` is a decaptured lambda, visiting `|y| (...)` may change its type, so the codomain of `|x| |y| (...)` may need to be fixed.
        let lam_ty = expr.ty.as_ref().unwrap();
        let dom_ty = lam_ty.get_lambda_srcs()[0].clone();
        let codom_ty = lam_ty.get_lambda_dst().clone();
        let lam_body = expr.get_lam_body();
        let impl_codom_ty = lam_body.ty.as_ref().unwrap();
        if codom_ty.to_string() == impl_codom_ty.to_string() {
            return EndVisitResult::unchanged(expr);
        }
        let new_lambda_ty = type_fun(dom_ty, impl_codom_ty.clone());
        let expr = expr.set_inferred_type(new_lambda_ty);
        EndVisitResult::changed(expr)
    }

    fn start_visit_let(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        let pat = expr.get_let_pat();
        let bound = expr.get_let_bound();
        let value = expr.get_let_value();
        if bound.is_lam() {
            // If the bound expression is a lambda, perform decapturing.
            assert!(pat.is_var());
            let var_name = pat.get_var().name.clone();
            let (decap_lam, cap_list) = self.decapture_lambda(bound, state); // この中でboundを訪問している
            self.decap_lambdas.push(decap_lam.clone());
            self.local_decap_lambdas.insert(var_name.clone(), decap_lam);
            let pat = pat
                .set_var_tyanno(None) // Discard type annotation since it may become incorrect
                .set_type(cap_list.ty.as_ref().unwrap().clone());
            let expr = expr_let_typed(pat, cap_list, value);
            return StartVisitResult::ReplaceAndRevisit(expr);
        } else if bound.is_var() {
            let name = &bound.get_var().name;
            let opt_local_decap_lambda = self.local_decap_lambdas.get(name);
            if opt_local_decap_lambda.is_none() {
                return StartVisitResult::VisitChildren;
            }
            // The case the bound expression is a variable referring to a decaptured lambda.
            let local_decap_lambda = opt_local_decap_lambda.unwrap();
            // Set the type of bound expression to the capture list type.
            let bound = bound.set_inferred_type(local_decap_lambda.cap_list_ty.clone());
            let expr = expr.set_let_bound(bound);
            // Also add the variable introduced by this let binding to `self.local_decap_lambdas`.
            self.local_decap_lambdas
                .insert(pat.get_var().name.clone(), local_decap_lambda.clone());
            return StartVisitResult::ReplaceAndRevisit(expr);
        } else {
            return StartVisitResult::VisitChildren;
        }
    }

    fn end_visit_let(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_if(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_if(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_match(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_match(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_tyanno(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_tyanno(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_make_struct(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_make_struct(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_array_lit(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_array_lit(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }

    fn start_visit_ffi_call(
        &mut self,
        _expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::StartVisitResult {
        StartVisitResult::VisitChildren
    }

    fn end_visit_ffi_call(
        &mut self,
        expr: &std::sync::Arc<crate::ExprNode>,
        _state: &mut crate::ast::traverse::VisitState,
    ) -> crate::ast::traverse::EndVisitResult {
        EndVisitResult::unchanged(expr)
    }
}
