use crate::ast::program::Program;

/*
# Decapturing optimization

## 概要

### デキャプチャリング

ラムダ式ごとに専用の構造体を定義する。
その構造体はラムダ式がキャプチャする値をフィールドに持つ。
またラムダ式の処理をグローバル関数として定義する。

例：
```
let f = |x| x + n;
```
があるとき、
```
type #Cap0_f = unbox struct { n: I64 };

#lam0_f : #Cap0_f -> I64 -> I64;
#lam0_f = |{ n : n }, x| x + n;
```
が定義される。

ラムダの定義は、`#Cap0_f { n : n }` に置き換えられる。

`#lam0_f`がグローバル関数となることで、後続のuncurry最適化が適用されるようになり、高速化が見込める。

### ラムダの使用個所の書き換え

`f(x)`は、以下のコードに変換される。
```
#lam0_f(f, x)
```
fにより多数の引数がある場合、fの使用箇所が部分適用となっている式は、`#lam0_f` に部分適用を行う式に置き換えられる。

特に、fに0個の引数が与えられる場合、すなわちfそのものが出現する場所では、原則、`#lam0_f(f)` というコードになる。
ただし、そのうち「クロージャ特殊化」が適用できる個所では、`#lam0_f` に置き換えられる。

### クロージャ特殊化

グローバル関数の引数にラムダを与えている場合を考える。
例として、`fold`の第2引数に、上記の`f`を与えている場合を考える。

```
fold : S -> (A -> S -> S) -> Iter -> S;
fold = |s, op, iter| (
    match iter.advance {
        none() => s,
        some((iter, a)) => iter.fold(op(a, s), op)
    }
);
```

これをもとに以下のようなバージョンのfoldを定義する。
これをクロージャ特殊化と呼ぶ。

```
fold#lam0_f : S -> #Cap0_f -> Iter -> S;
fold#lam0_f = |s, op, iter| (
    match iter.advance {
        none() => s,
        some((iter, a)) => iter.fold#lam0_f(#lam0_f(op, a, s), op)
    }
);
```

そして、`iter.fold(s0, f)`を`iter.fold#lam0_f(s0, f)`に置き換える。

## 適用範囲と制限

### ラムダを定義してから使うまでの経路

#### 例

ラムダを定義してそのまま使う式にはこの最適化が適用される。
例： `iter.fold(s0, |acm, i| acm + i)`

#### 例2

ラムダを定義して一度ローカル変数に入れてから使う使う式にもこの最適化が適用される。
例： `let f = |acm, i| acm + i; iter.fold(s0, f)`

ただし、ラムダを定義してから使うまでの経路がこれより複雑な場合はこの最適化は適用されない。
例： `let (_, f) = (0, |acm, i| acm + i); iter.fold(s0, f)`
このような場合に対処するためには、なんらかの他の最適化を実装し、事前に適用しておく必要があるだろう。

## 他の最適化との関係

* 本最適化の前にインライン化を行っておくべき。例えば、式`f >> g`がインライン化によりラムダ式に置き換わることで、本最適化の対象となる。
* 本最適化の後にもインライン化を行う価値があるかもしれない。本最適化によりグローバル関数が増えるためである。
* 本最適化により生成されたグローバル関数の性能を向上させるため、アンカリー化は本最適化の後に行うべきである。
*/

pub fn run(prg: &mut Program) {}
