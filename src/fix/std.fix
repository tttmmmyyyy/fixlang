module Std;

import Debug;

namespace Array {

    // A function like `get_sub`, but behaves as if the size of the array is the specified value, 
    // and has a parameter to specify additional capacity of the returned `Array`.
    _get_sub_size_asif : I64 -> I64 -> I64 -> I64 -> Array a -> Array a;
    _get_sub_size_asif = |len, additional_capacity, s, e, arr| (
        if len == 0 { arr };
        let s = (s % len + len) % len;
        let e = (e % len + len) % len;
        let n = if e >= s { e - s } else { e + len - s };
        let res = Array::empty(n + additional_capacity);
        loop((s, res), |(i, res)| (
            if i == e { break $ res };
            let res = res.push_back(arr.@(i));
            let i = i + 1;
            let i = if i >= len { 0 } else { i };
            continue $ (i, res)
        ))
    );

    // Sort elements in a range of a vector by "less than" comparator.
    // This function receives a working buffer as the first argument to reduce memory allocation, and returns it as second element.
    _sort_range_using_buffer : Array a -> I64 -> I64 -> ((a, a) -> Bool) -> Array a -> (Array a, Array a);
    _sort_range_using_buffer = |buffer, begin, end, less_than, vec| (
        // Merge sorting.
        let len = end - begin;
        if len <= 1 { (vec, buffer) };
        // Divide into intervals.
        let former_len = len / 2;
        let former_begin = begin;
        let former_end = begin + former_len;
        let latter_len = len - former_len;
        let latter_begin = former_end;
        let latter_end = end;
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, former_begin, former_end, less_than);
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, latter_begin, latter_end, less_than);
        // Merge former and latter to buffer.
        let buffer = buffer.truncate(0);
        let former_pos = former_begin;
        let latter_pos = latter_begin;
        let buffer = loop((former_pos, latter_pos, buffer), |(former_pos, latter_pos, buffer)|(
            if former_pos == former_end { // If former_pos reached to the end,
                if latter_pos == latter_end { break $ buffer };
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(vec.@(latter_pos));
                continue $ (former_pos, latter_pos + 1, buffer)
            };
            if latter_pos == latter_end { // If latter_pos reached to the end,
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(vec.@(former_pos));
                continue $ (former_pos + 1, latter_pos, buffer)
            };
            let former_elem = vec.@(former_pos);
            let latter_elem = vec.@(latter_pos);
            if less_than((former_elem, latter_elem)) {
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(former_elem);
                continue $ (former_pos + 1, latter_pos, buffer)
            } else {
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(latter_elem);
                continue $ (former_pos, latter_pos + 1, buffer)
            }
        ));
        // Copy buffer to vec.
        loop((0, vec), |(idx, vec)|(
            if idx == len { break $ (vec, buffer) };
            let vec = vec.set(begin + idx, buffer.@(idx));
            continue $ (idx + 1, vec)
        ))
    );

    // Functorial version of `Array::mod`, a.k.a. "lens" of `Array` in Haskell community.
    // This function can be defined for any functor `f` in general, but it is easier to understand the behavior when `f` is a monad: the monadic action `act(idx, fun, arr)` first performs `fun(arr.@(idx))` to get a value `elm`, and returns a pure value `arr.set(idx, elm)`. In short, this function modifies an array by a monadic action. 
    // This action can be implemented as `fun(arr.@(idx)).bind(|elm| pure $ arr.set(idx, elm))`. As we have identity `map(f) == bind(|x| pure $ f(x))` for `map` of a functor underlying a monad, it can be written as `fun(arr.@(idx)).map(|elm| arr.set(idx, elm))` and therefore this function can be defined using only functor structure.
    // What is special about this function is that if you call `arr.act(idx, fun)` when the reference counters of both of `arr` and `arr.@(idx)` are one, it is assured that `fun` receives the element with reference counter one.
    // If you call `act` on an array which is shared by multiple references, this function clones the given array when inserting the result of your action into the array. This means that you don't need to pay cloning cost when your action failed, as expected.
    act : [f : Functor] I64 -> (a -> f a) -> Array a -> f (Array a);
    act = |idx, fun, arr| (
        let (unique, arr) = arr.unsafe_is_unique;
        if unique {
            arr.act!(idx, fun)
        } else { // shared
            fun(arr.@(idx)).map(|elm| arr.set(idx, elm))
        }        
    );

    // Functorial version of `Array::mod!`, a.k.a. "lens" of `Array` in Haskell community.
    // This function is almost the same as `Array::act`, but it panics if the given array is shared by multiple references.
    act! : [f : Functor] I64 -> (a -> f a) -> Array a -> f (Array a);
    act! = |idx, act, arr| (
        let (parr, elm) = PunchedArray::punch!(idx, arr);
        act(elm).map(|elm| parr.plug_in!(elm))
    );

    // Append an array to an array.
    // Note 1: Since `a1.append(a2)` puts `a2` after `a1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    // Note 2: 
    // As an optimization, when `a1` is empty, `a1.append(a2)` may return `a2` itself.
    // So even if you call `append` on an unique empty array, the returned array can be a shared one.
    append : Array a -> Array a -> Array a;
    append = |v2, v1| (
        // if v2 is empty, return early to avoid unnecessary clone.
        let v2_len = v2.get_size;
        if v2_len == 0 { v1 };

        // if v1 is empty, return early to avoid unnecessary clone.
        let v1_len = v1.get_size;
        if v1_len == 0 { v2 };

        // Reserve v1's buffer and force uniqueness.
        let len = v1_len + v2_len;
        let v1 = v1.reserve(len).force_unique;
        
        // Set length.
        let v1 = v1._unsafe_set_size(len);

        // Copy elements of v2 to v1.
        loop((0, v1), |(idx, v1)|(
            if idx >= v2_len { break $ v1 };
            let v1 = v1._unsafe_set(v1_len + idx, v2.@(idx));
            continue $ (idx+1, v1)
        ))
    );

    // Append an array to an array.
    // This is similar to `Array::append`, but `a1.append!(a2)` panics if this function has to clone `a1` due to it being shared.
    // Note that, when the capacity of `a1` is less than `a1.get_size + a2.get_size`, then `a1.append!(a2)` will not panic even if `a1` is shared, because in this case cloning is inevitable whether or not `a1` is shared.
    append! : Array a -> Array a -> Array a;
    append! = |v2, v1| (
        // if v2 is empty, return early to avoid unnecessary clone.
        let v2_len = v2.get_size;
        if v2_len == 0 { v1 };

        // if v1 is empty, return early to avoid unnecessary clone.
        let v1_len = v1.get_size;
        if v1_len == 0 { v2 };

        // Reserve v1's buffer and force uniqueness.
        let len = v1_len + v2_len;
        let v1 = v1.reserve(len).force_unique!;
        
        // Set length.
        let v1 = v1._unsafe_set_size(len);

        // Copy elements of v2 to v1.
        loop((0, v1), |(idx, v1)|(
            if idx >= v2_len { break $ v1 };
            let v1 = v1._unsafe_set(v1_len + idx, v2.@(idx));
            continue $ (idx+1, v1)
        ))
    );

    // Call a function with a pointer to the memory region where elements are stored.
    borrow_ptr : (Ptr -> b) -> Array a -> b;
    borrow_ptr = |f, arr| (
        let res = f(arr._get_ptr);
        eval arr; // Use array after calling f
        res
    );

    // Find the first index at which the element satisfies a condition.
    find_by : (a -> Bool) -> Array a -> Option I64;
    find_by = |cond, arr| (
        let len = arr.get_size;
        loop(0, |idx| (
            if idx == len { break $ Option::none $ () };
            if cond(arr.@(idx)) { break $ Option::some $ idx };
            continue $ idx + 1
        ))
    );

    // Create an array from an iterator.
    from_iter : Iterator a -> Array a;
    from_iter = |iter| (
        let len = iter.get_size;
        let arr = Array::empty(len)._unsafe_set_size(len);
        iter.fold((arr, 0), |(arr, idx), elem| (
            let arr = arr._unsafe_set(idx, elem);
            (arr, idx+1)
        )).@0
    );

    // Creates an array by a mapping function.
    from_map : I64 -> (I64 -> a) -> Array a;
    from_map = |size, map| (
        let arr = Array::empty(size)._unsafe_set_size(size);
        loop((0, arr), |(idx, arr)|(
            if idx == size {
                break $ arr
            } else {
                let arr = arr._unsafe_set(idx, map(idx));
                continue $ (idx + 1, arr)
            }
        ))
    );

    // Get the first element of an array. Returns none if the array is empty.
    get_first : Array a -> Option a;
    get_first = |arr| (
        if arr.is_empty { Option::none() };
        Option::some $ arr.@(0)
    );

    // Get the last element of an array. Returns none if the array is empty.
    get_last : Array a -> Option a;
    get_last = |arr| (
        let len = arr.get_size;
        if len == 0 { Option::none() };
        Option::some $ arr.@(len - 1)
    );

    // `arr.get_sub(s, e)` returns an array `[ arr.@(i) | i ∈ [s, e) ]`, 
    // More precisely, let `N` denote the the size of the `arr`. 
    // Then `arr.get_sub(s, e)` returns `[ arr.@(s + i mod N) | i ∈ [0, n), n >= 0 is the minimum number such that s + n == e mod N ]`.
    get_sub : I64 -> I64 -> Array a -> Array a;
    get_sub = |s, e, arr| arr._get_sub_size_asif(arr.get_size, 0, s, e);

    // Returns if the array is empty
    is_empty : Array a -> Bool;
    is_empty = |arr| ( arr.get_size == 0 );

    // Pop an element at the back of an array.
    // If the array is empty, this function does nothing.
    pop_back : Array a -> Array a;
    pop_back = |arr| (
        let len = arr.get_size;
        if len == 0 { arr };
        let arr = arr.force_unique;
        let released_elem = arr._unsafe_get(len-1);
        arr._unsafe_set_size(len-1)
    );

    // Pop an element at the back of an array.
    // If the array is empty, this function does nothing.
    // This function panics if elements must be cloned due to the given array being shared by multiple references. 
    // Note that, when the given array is empty, this function will not panic even if it is shared.
    pop_back! : Array a -> Array a;
    pop_back! = |arr| (
        let len = arr.get_size;
        if len == 0 { arr };
        let arr = arr.force_unique!;
        let released_elem = arr._unsafe_get(len-1);
        arr._unsafe_set_size(len-1)
    );

    // Push an element to the back of an array.
    push_back : a -> Array a -> Array a;
    push_back = |e, arr| (
        let len = arr.get_size;
        let arr = if arr.get_capacity < len + 1 {
            arr.reserve(2*(len + 1))
        } else {
            arr
        };
        let arr = arr.force_unique._unsafe_set_size(len+1);
        arr._unsafe_set(len, e)
    );

    // Push an element to the back of an array.
    // This function panics if elements must be cloned due to the given array being shared by multiple references. 
    // Note that, when the capacity of `arr` is equal to its size, `arr.push_back!(e)` will not panic even if `arr` is shared because in this case cloning elements is inevitable whether or not `arr` is shared.
    push_back! : a -> Array a -> Array a;
    push_back! = |e, arr| (
        let len = arr.get_size;
        let arr = if arr.get_capacity < len + 1 {
            arr.reserve(2*(len + 1))
        } else {
            arr
        };
        let arr = arr.force_unique!._unsafe_set_size(len+1);
        arr._unsafe_set(len, e)
    );

    // Reserves the memory region for an array.
    // TODO: change to more optimized implementation.
    reserve : I64 -> Array a -> Array a;
    reserve = |cap, arr| (
        if cap <= arr.get_capacity { arr };
        let len = arr.get_size;
        let new = Array::empty(cap)._unsafe_set_size(len);
        loop((0, new), |(idx, new)|(
            if idx == len {
                break $ new
            } else {
                let new = new._unsafe_set(idx, arr.@(idx));
                continue $ (idx + 1, new)
            }
        ))
    );

    // Sort elements in a vector by "less than" comparator.
    sort_by : ((a, a) -> Bool) -> Array a -> Array a;
    sort_by = |less_than, vec| (
        let buffer = Array::empty(vec.get_size);
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, 0, vec.get_size, less_than);
        vec
    );

    // Convert an array to an iterator.
    to_iter : Array a -> Iterator a;
    to_iter = Iterator::from_array;

    // Truncate an array, keeping the given number of first elements.
    // `truncante(len, arr)` does nothing if `len >= arr.get_size`.
    truncate : I64 -> Array a -> Array a;
    truncate = |length, vec| (
        loop(vec, |vec|(
            if length >= vec.get_size { break $ vec };
            continue $ vec.pop_back
        ))
    );
}

impl [a : Eq] Array a : Eq {
    // Compare two vectors.
    eq = |lhs, rhs| (
        if lhs.get_size != rhs.get_size { false };
        let len = lhs.get_size;
        loop(0, |idx| (
            if idx == len { break $ true };
            if lhs.@(idx) != rhs.@(idx) { break $ false };
            continue $ idx + 1
        ))
    );
}

impl Array : Functor {
    map = |f, arr| (
        let n = arr.get_size;
        let res = Array::empty(n);
        loop((0, res), |(i, res)| (
            if i == n { break $ res };
            let e = f $ arr.@(i);
            continue $ (i+1, res.push_back(e))
        ))
    );
}

impl Array : Monad {
    pure = |e| [e];
    bind = |f, arr| (
        let size = arr.get_size;
        let arr_arr = Array::empty(size);
        let (arr_arr, count) = loop((0, arr_arr, 0), |(idx, arr_arr, count)| (
            if idx == size { break $ (arr_arr, count) };
            let inner = f $ arr.@(idx);
            let count = count + inner.get_size;
            let arr_arr = arr_arr.push_back(inner);
            continue $ (idx + 1, arr_arr, count)
        ));
        let ret = Array::empty(count);
        loop((0, ret), |(i, ret)| (
            if i == size { break $ ret };
            let inner = arr_arr.@(i);
            continue $ loop((0, ret), |(j, ret)|(
                if j == inner.get_size {
                    break $ (i + 1, ret)
                } else {
                    let ret = ret.push_back(inner.@(j));
                    continue $ (j + 1, ret)
                }
            ))
        ))
    );
}

impl Bool : ToString {
    to_string = |lhs| (
        if lhs { "true" } else { "false" }
    );
}

// `Destructor a` is a boxed type which has two fields of type `a` and `a -> ()`, where the latter field is called destructor.
// The destructor function will be called when a value of `Destructor a` is deallocated.
// Note that the inner value of type `a` may be still alive after the destructor function is called.
// This type is useful to manage resources allocated by C function.
type Destructor a = box struct { value : a, dtor : a -> () };

namespace Destructor {
    // Borrow the internal value.
    // `borrow(worker, dtor)` calls `worker` on the internal value captured by `dtor`, and returns the value returned by `worker`.
    // If you try to extract the value by `dtor.@_value` from `dtor : Destructor a` and this expression is the last use of `dtor`, 
    // then you get a value after the destructor function is called. 
    // On the other hand, in `borrow(worker, dtor)`, `worker` will be called before the destructor is called.
    borrow : (a -> b) -> Destructor a -> b;
    borrow = |worker, dtor| (
        let res = worker(dtor.@value);
        eval dtor; // Prolong lifetime of `dtor`.
        res
    );

    // Make a destructor value.
    make : a -> (a -> ()) -> Destructor a;
    make = |val, dtor| Destructor { value : val, dtor : dtor };
}

// A type (alias) for error message. 
type ErrMsg = String;

type IO a = unbox struct { _data : () -> a };

namespace IO {
    // Read characters from an IOHandle.
    // If the first argument `upto_newline` is true, this function reads a file upto newline or EOF.
    _read_line_inner : Bool -> IOHandle -> IOFail String;
    _read_line_inner = |upto_newline, handle| (
        IOFail { _data : IO { _data : |_| (
            // Read strings and make iterators of strings (reversed).
            let strings_rev = loop(Iterator::empty, |strs|
                let buf_size = 1024;
                let buf = Array::empty(buf_size);                
                let strlen = buf.borrow_ptr(|buf|
                    // Read characters to buf.
                    let fgets_res = CALL_C[Ptr fgets(Ptr, I32, Ptr), buf, buf_size.to_I32, handle._file_ptr];
                    if fgets_res == nullptr { -1 };

                    // Return length.
                    let strlen = CALL_C[I64 strlen(Ptr), buf];
                    strlen
                );
                // If reached to EOF (or error), break.
                if strlen == -1 { break $ strs };

                // Create string.
                let buf = buf._unsafe_set_size(strlen + 1);
                let str = String { _data : buf };
                let strs = strs.push_front(str);

                // If no character is read, break.
                if strlen == 0 { break $ strs };

                if upto_newline {
                    // If the last character is \n, break.
                    let last_byte = buf.@(strlen-1);
                    if last_byte == '\n' { break $ strs };
                    continue $ strs
                } else {
                    continue $ strs
                }
            );

            // Check if err occurred.
            let err = CALL_C[I32 ferror(Ptr), handle._file_ptr];
            if err != 0_I32 { 
                let err = "Std::IO::_read_line_inner failed!: an error occurred in fgets.";
                Result::err(err)
            };

            let str = strings_rev.reverse.concat_iter;
            Result::ok(str)
        ) }}
    );

    // Perform the I/O action. This may violate purity of Fix.
    _unsafe_perform : IO a -> a;
    _unsafe_perform = |io| (io.@_data)();

    // Close a file.
    // Unlike C's `fclose`, closing an already closed `IOHandle` is safe and does nothing.
    close_file : IOHandle -> IO ();
    close_file = |handle| (
        IO { _data : |_| IOHandle::_unsafe_close(handle) }
    );

    // Print a string to stderr.
    eprint : String -> IO ();
    eprint = |str| (
        IO { _data : |_| (
            eval str.borrow_c_str(|c_ptr|
                CALL_C[I32 fprintf(Ptr, Ptr, ...), stdout._file_ptr, c_ptr]
            );
            ()
        )}
    );

    // Print a string followed by a newline to stderr.
    eprintln : String -> IO ();
    eprintln = |str| (
        eval *eprint(str);
        eval *eprint("\n");
        pure()
    );

    // Exit the program with an error code.
    exit : I64 -> IO a;
    exit = |code| IO { _data : |_| eval CALL_C[() exit(I32), code.to_I32]; abort() };

    // Exit the program with an error message and an error code.
    // The error message is written to the standard error output.
    exit_with_msg : I64 -> String -> IO a;
    exit_with_msg = |code, msg| eval *eprintln(msg); exit(code);

    // Read a line from stdin. If some error occurr, this function aborts.
    // If you want to handle errors, use `read_line(stdin)` instead.
    input_line : IO String;
    input_line = (
        let res = *read_line(stdin).to_io;
        if res.is_ok {
            pure $ res.as_ok
        } else {
            eval *(eprintln $ res.as_err.to_string);
            pure $ abort()
        }
    );

    // Check if an `IOHandle` reached to the EOF.
    is_eof : IOHandle -> IO Bool;
    is_eof = |handle| pure $ CALL_C[I32 feof(Ptr), handle._file_ptr] != 0_I32;

    // Loop on lines read from an `IOHandle`.
    // `loop_lines(handle, initial_state, worker)` calls `worker` on the pair of current state and a line string read from `handle`.
    // The function `worker` should return an updated state as `LoopResult` value, i.e., a value created by `continue` or `break`.
    // When the `handle` reaches to the EOF or `worker` returns a `break` value, `loop_lines` returns the last state value.
    // Note that the line string passed to `worker` may contain a newline code at the end. To remove it, use `String::rstrip`.
    loop_lines : IOHandle -> s -> (s -> String -> LoopResult s s) -> IOFail s;
    loop_lines = |handle, state, worker| (
        if *is_eof(handle).lift {
            pure $ state
        };
        let line = *read_line(handle);
        let res = worker(state, line);
        if res.is_break {
            pure $ res.as_break
        };
        let next_state = res.as_continue;
        loop_lines(handle, next_state, worker)
    );

    // Loop on lines read from a file.
    // For details, see comment for `loop_lines`.
    loop_lines_file : Path -> s -> (s -> String -> LoopResult s s) -> IOFail s;
    loop_lines_file = |path, state, worker| with_file(path, "r", |handle| loop_lines(handle, state, worker));

    // Open a file. The second argument is a mode string for `fopen` C function. 
    open_file : Path -> String -> IOFail IOHandle;
    open_file = |path, mode| (
        IOFail { _data  : IO { _data : |_|(
            let path_str = path.to_string;
            let res = path_str.borrow_c_str(|path_ptr|
                mode.borrow_c_str(|mode_str|
                    let file_ptr = CALL_C[Ptr fopen(Ptr, Ptr), path_ptr, mode_str];
                    if file_ptr == nullptr { 
                        Result::err $ "failed to open a file: " + path_str
                    } else {
                        Result::ok $ IOHandle::from_file_ptr $ file_ptr
                    }
                )
            );
            res
        ) }}
    );

    // Print a string to stdout.
    print : String -> IO ();
    print = |str| (
        IO { _data : |_| (
            eval str.borrow_c_str(|c_ptr|
                CALL_C[I32 printf(Ptr, ...), c_ptr]
            );
            ()
        )}
    );

    // Print a string followed by a newline to stdout.
    println : String -> IO ();
    println = |str| (
        eval *print(str);
        eval *print("\n");
        pure()
    );

    // Raad all characters from a file.
    read_file_string : Path -> IOFail String;
    read_file_string = |path| with_file(path, "r", read_string);

    // Read all bytes from a file.
    read_file_bytes : Path -> IOFail (Array U8);
    read_file_bytes = |path| with_file(path, "r", read_bytes);

    // Read characters from a IOHandle upto newline or EOF.
    // The returned string may include newline at its end.
    read_line : IOHandle -> IOFail String;
    read_line = _read_line_inner(true);

    // Read all bytes from an IOHandle.
    read_bytes : IOHandle -> IOFail (Array U8);
    read_bytes = |handle| (
        // Get Iterator of Arrays.
        let (iter, len) = *loop_m((Iterator::empty, 0), |(iter, len)| (
            let bytes = *read_n_bytes(handle, 1024);
            if bytes.is_empty {
                break_m $ (iter.reverse, len)
            } else {
                continue_m $ (iter.push_front(bytes), len + bytes.get_size)
            }
        ));
        // Concatenate bytes.
        let res = Array::empty(len);
        pure $ iter.fold(res, |res, bytes| res.append!(bytes))
    );

    // Read at most n bytes from an IOHandle.
    read_n_bytes : IOHandle -> I64 -> IOFail (Array U8);
    read_n_bytes = |handle, n| (
        let buf = Array::empty(n);
        let len = buf.borrow_ptr(|ptr| (
            CALL_C[I64 fread(Ptr, I64, I64, Ptr), ptr, 1, n, handle._file_ptr]
        ));
        // Check error.
        let err = CALL_C[I32 ferror(Ptr), handle._file_ptr];
        if err != 0_I32 { 
            let err = "Std::IO::read_n_bytes failed!: some error occurred in fread.";
            IOFail::from_result $ Result::err(err)
        };
        let buf = buf._unsafe_set_size(len);
        IOFail::from_result $ Result::ok(buf)
    );

    // Read all characters from an IOHandle.
    read_string : IOHandle -> IOFail String;
    read_string = _read_line_inner(false);

    // The handle for standard error.
    stderr : IOHandle;
    stderr = (
        let ptr = "a".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 2_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // The handle for standard input.
    stdin : IOHandle;
    stdin = (
        let ptr = "r".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 0_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // The handle for standard output.
    stdout : IOHandle;
    stdout = (
        let ptr = "a".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 1_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // Perform a function with a file handle. The second argument is a mode string for `fopen` C function. 
    // The file handle will be closed automatically.
    with_file : Path -> String -> (IOHandle -> IOFail a) -> IOFail a;
    with_file = |path, mode, action| (
        let handle = *open_file(path, mode);
        let res = *action(handle);
        eval *IOFail::lift(close_file(handle));
        pure $ res
    );

    // Write a byte array into an IOHandle.
    write_bytes : IOHandle -> Array U8 -> IOFail ();
    write_bytes = |handle, array| (
        let res = array.borrow_ptr(|ptr| (
            let n = array.get_size;
            let res = CALL_C[I64 fwrite(Ptr, I64, I64, Ptr), ptr, 1, n, handle._file_ptr];
            if res < n { Result::err $ "Std::IO::write_bytes failed!: some error occurred in fwrite." };
            Result::ok()
        ));
        IOFail::from_result $ res
    );

    // Write a byte array into a file.
    write_file_bytes : Path -> Array U8 -> IOFail ();
    write_file_bytes = |path, content| with_file(path, "w", |handle| write_bytes(handle, content));

    // Write a string into a file.
    write_file_string : Path -> String -> IOFail ();
    write_file_string = |path, content| with_file(path, "w", |handle| write_string(handle, content));

    // Write a string into an IOHandle.
    write_string : IOHandle -> String -> IOFail ();
    write_string = |handle, content| (
        let res = content.borrow_c_str(|c_str| (
            let file_ptr = handle._file_ptr;
            let res = CALL_C[I32 fputs(Ptr, Ptr), c_str, handle._file_ptr];
            if res < 0_I32 { Result::err $ "Std::IO::write_string failed!: some error occurred in fputs." };
            Result::ok()
        ));
        IOFail::from_result $ res
    );
}

impl IO : Functor {
    map = |f, io| IO { _data : |_| f(io._unsafe_perform) };
}

impl IO : Monad {
    pure = |v| IO { _data : |_| v };
    bind = |f, io| (
        IO { _data : |_| (
            let a = io._unsafe_perform;
            f(a)._unsafe_perform
        )}
    );
}

namespace IO {
    // A handle type for read / write operations on files, stdin, stdout, stderr.
    // You can create `IOHandle` value by `IO::open_file`, and close it by `IO::close_file`. 
    // Also there are global `IO::IOHandle::stdin`, `IO::IOHandle::stdout`, `IO::IOHandle::stderr`.
    type IOHandle = unbox struct { _data : Destructor Ptr };
}

namespace IO::IOHandle {
    // Get pointer to C's `FILE` value from an `IOHandle`.
    // DO NOT call `fclose` on the pointer returned by this function.
    // To close an `IOHandle`, use `IO::close_file`.
    _file_ptr : IOHandle -> Ptr;
    _file_ptr = |handle| handle.@_data.borrow(|handle_ptr| 
        CALL_C[Ptr fixruntime_iohandle_get_file(Ptr), handle_ptr]
    );

    // Close an `IOHandle`. 
    // This is an I/O action not wrapped by `IO`; use `IO::close_file` in the usual case.
    _unsafe_close : IOHandle -> ();
    _unsafe_close = |handle| (
        eval handle.@_data.borrow(|handle_ptr| CALL_C[() fixruntime_iohandle_close(Ptr), handle_ptr]);
        ()
    );

    // Create an `IOHandle` from a file pointer (i.e., pointer to C's `FILE`).
    // DO NOT create two `IOHandle`s from a single file pointer.
    from_file_ptr : Ptr -> IOHandle;
    from_file_ptr = |file_ptr| (
        let handle_ptr = CALL_C[Ptr fixruntime_iohandle_create(Ptr), file_ptr];
        let dtor = |handle_ptr| CALL_C[() fixruntime_iohandle_delete(Ptr), handle_ptr];
        IOHandle { _data : Destructor::make(handle_ptr, dtor) }
    );
}

namespace IO {
    // The type for I/O actions which may fail.
    type IOFail a = unbox struct { _data : IO (Result ErrMsg a) };
}

namespace IO::IOFail {
    // Create an pure `IOFail` value from a `Result` value.
    from_result : Result ErrMsg a -> IOFail a;
    from_result = |res| IOFail { _data : pure(res) };

    // Lift an `IO` action to a successful `IOFail` action.
    lift : IO a -> IOFail a;
    lift = |io| IOFail { _data : io.map(pure) };

    // Create an error `IOFail` action.
    throw : ErrMsg -> IOFail a;
    throw = |e| from_result $ Result::err(e);

    // Convert an `IOFail` to an `Result` value (wrapped by `IO`).
    to_result : IOFail a -> IO (Result ErrMsg a);
    to_result = @_data;

    // Convert an `IOFail` value to an `IO` value by an error handler (i.e., a `catch`) function.
    try : (ErrMsg -> IO a) -> IOFail a -> IO a;
    try = |catch, iof| (
        let res = *iof.to_result;
        if res.is_ok { pure $ res.as_ok } else { catch(res.as_err) }
    );
}

impl IOFail : Functor {
    map = |f, iof| iof.mod__data(map(map(f)));
}

impl IOFail : Monad {
    pure = |v| IOFail { _data : pure(pure(v)) };
    bind = |f, iof| IOFail { _data : do {
        let res = *iof.@_data;
        if res.is_err { pure $ Result::err $ res.as_err };
        f(res.as_ok).@_data
    }};
}

// Iterator (a.k.a lazy list)
type Iterator a = unbox struct { next: () -> Option (a, Iterator a) };

namespace Iterator {

    // Flatten an iterator of iterators.
    // You should use `Monad::flatten` instead of this function.
    // This function is used in the implementation of `Monad::bind` for `Iterator`.
    _flatten : Iterator (Iterator a) -> Iterator a;
    _flatten = |iter_iter| (
        let next = |_| (
            if iter_iter.is_empty { Option::none() };
            let (iter, iter_iter) = iter_iter.advance.as_some;
            if iter.is_empty { iter_iter._flatten.advance };
            let (e, iter) = iter.advance.as_some;
            Option::some $ (e, iter_iter.push_front(iter)._flatten)
        );
        Iterator { next : next }
    );

    // Get next value and next iterator.
    advance : Iterator a -> Option (a, Iterator a);
    advance = |iter| (iter.@next)();

    // Append an iterator to a iterator.
    // Note: Since `iter1.append(iter2)` puts `iter2` after `iter1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Iterator a -> Iterator a -> Iterator a;
    append = |rhs, lhs| (
        if lhs.is_empty { rhs };
        let next = |_| (
            lhs.advance.map(|(e, lhs)| (e, lhs.append(rhs)))
        );
        Iterator { next : next }
    );

    // Evaluate all elements of iterator.
    // TODO: add test
    bang : Iterator a -> Iterator a;
    bang = |iter| iter.to_array.to_iter;

    // Creates an iterator that counts up from a number.
    // count_up(n) = [n, n+1, n+2, ...]
    count_up : I64 -> Iterator I64;
    count_up = |i| (
        let next = |_| (
            some $ (i, Iterator::count_up(i+1))
        );
        Iterator { next: next }
    );

    // Create an empty iterator.
    empty : Iterator a;
    empty = (
        let next = |_| (none());
        Iterator { next: next }
    );

    // Filter elements by a condition function
    filter : (a -> Bool) -> Iterator a -> Iterator a;
    filter = |cond, iter| (
        let next = |_| (
            loop(iter, |iter| (
                let next = iter.advance;
                if next.is_none { break $ none() };
                let (v, iter) = next.as_some;
                if !cond(v) { continue $ iter };
                let iter = filter(cond, iter);
                break $ some((v, iter))
            ))
        );
        Iterator { next: next }
    );

    // Find the last element of an iterator.
    find_last : Iterator a -> Option a;
    find_last = |iter| (
        if iter.is_empty { none() };
        let (elem, iter) = iter.advance.as_some;
        if iter.is_empty { 
            some(elem)
        } else {
            iter.find_last
        }
    );

    // Folds iterator from left to right.
    // Example: `fold(init, op, [a0, a1, a2, ...]) = ...op(op(op(init, a0), a1), a2)...`
    fold : b -> (b -> a -> b) -> Iterator a -> b;
    fold = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none {
                break $ accum
            } else {
                let (next, iter) = next.as_some;
                continue $ (op(accum, next), iter)
            }
        )
    );

    // Folds iterator from left to right by monadic action.
    fold_m : [m : Monad] b -> (b -> a -> m b) -> Iterator a -> m b;
    fold_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)| (
            let next = iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let accum = *op(accum, next);
            continue_m $ (accum, iter)
        ))
    );

    // Create iterator from an array.
    from_array : Array a -> Iterator a;
    from_array = |arr| count_up(0).take(arr.get_size).map(|i| arr.@(i));

    // Creates iterator from mapping function.
    // from_map(f) = [f(0), f(1), f(2), ...]
    from_map : (I64 -> a) -> Iterator a;
    from_map = |f| count_up(0).map(f);

    // Generate an iterator from a state transition function.
    // - if `f(s)` is none, `generate(s, f)` is empty.
    // - if `f(s)` is some value `(e, s1)`, then `generate(s, f)` starts by `e` followed by `generate(s2, f)`.
    generate : s -> (s -> Option (a, s)) -> Iterator a;
    generate = |s, f| (
        let next = |_| f(s).map(|(e, s)| (e, Iterator::generate(s, f)));
        Iterator { next: next }
    );

    // Get the first element of an iterator. If the iterator is empty, this function returns `none`.
    // TODO: add test
    get_first : Iterator a -> Option a;
    get_first = |iter| iter.advance.map(@0);

    // Count the number of elements of an iterator.
    get_size : Iterator a -> I64;
    get_size = fold(0, |acm, _| acm + 1);

    // Remove the first element from an iterator. If the iterator is empty, this function returns `none`.
    // TODO: add test
    get_tail : Iterator a -> Option (Iterator a);
    get_tail = |iter| iter.advance.map(@1);

    // Intersperse an elemnt between elements of an iterator.
    // Example: 
    // ```
    // Iterator::from_array([1,2,3]).intersperse(0) == Iterator::from_array([1,0,2,0,3])
    // ```
    intersperse : a -> Iterator a -> Iterator a;
    intersperse = |sep, iter| (
        let next = |_| (
            if iter.is_empty { Option::none() };
            let (e, tail) = iter.advance.as_some;
            if tail.is_empty { Option::some $ (e, Iterator::empty) };
            Option::some $ (e, Iterator::push_front(sep) $ tail.intersperse(sep))
        );
        Iterator { next : next }
    );

    // Check if the iterator is empty.
    is_empty : Iterator a -> Bool;
    is_empty = |iter| iter.advance.is_none;

    // Loop along an iterator. At each iteration step, you can choose to continue or to break.
    loop_iter : b -> (b -> a -> LoopResult b b) -> Iterator a -> b;
    loop_iter = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none { break $ accum };
            let (next, iter) = next.as_some;
            let loop_res = op(accum, next);
            if loop_res.is_break { break $ loop_res.as_break };
            continue $ (loop_res.as_continue, iter)
        )
    );

    // Loop by monadic action along an iterator. At each iteration step, you can choose to continue or to break.
    loop_iter_m : [m : Monad] b -> (b -> a -> m (LoopResult b b)) -> Iterator a -> m b;
    loop_iter_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let loop_res = *op(accum, next);
            if loop_res.is_break { break_m $ loop_res.as_break };
            continue_m $ (loop_res.as_continue, iter)
        )
    );

    // Push an elemnt to an iterator.
    push_front : a -> Iterator a -> Iterator a;
    push_front = |elem, iter| (
        let next = |_| (
            some $ (elem, iter)
        );
        Iterator { next: next }     
    );

    // Create a range iterator, i.e. an iterator of the form `[a, a+1, a+2, ..., b-1]`.
    range : I64 -> I64 -> Iterator I64;
    range = |a, b| (
        let next = |_| (
            if a == b {
                Option::none()
            } else {
                Option::some $ (a, Iterator::range(a+1, b))
            }
        );
        Iterator { next: next }
    );

    // Reverse an iterator.
    reverse : Iterator a -> Iterator a;
    reverse = |iter| (
        loop((Iterator::empty, iter), |(out_iter, in_iter)|(
            if in_iter.is_empty {
                break $ out_iter
            } else {
                let (elem, in_iter) = in_iter.advance.as_some;
                let out_iter = out_iter.push_front(elem);
                continue $ (out_iter, in_iter)
            }
        ))
    );

    // Generated all subsequences of an iterator.
    // `[1,2,3].to_iter.subsequences` is `[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]].to_iter.map(to_iter)`.
    subsequences : Iterator a -> Iterator (Iterator a);
    subsequences = |iter| (
        if iter.is_empty { pure $ Iterator::empty };
        let (head, iter) = iter.advance.as_some;
        let subs = iter.subsequences;
        subs.append(subs.map(push_front(head)))
    );

    // Calculate the sum of elements of an iterator.
    sum : [a : Additive] Iterator a -> a;
    sum = fold(Zero::zero, Add::add);

    // Take at most n elements from an iterator.
    take : I64 -> Iterator a -> Iterator a;
    take = |n, iter| (
        let next = |_| (
            if n == 0 { none() };
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            some $ (v, iter.take(n-1))
        );
        Iterator { next: next }
    );

    // Take elements of an iterator while a condition is satisfied.
    // TODO: add test
    take_while : (a -> Bool) -> Iterator a -> Iterator a;
    take_while = |cond, iter| (
        let next = |_| (
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            if !cond(v) { none() };
            some $ (v, iter.take_while(cond))
        );
        Iterator { next: next }        
    );

    // Convert an iterator to an array.
    to_array : Iterator a -> Array a;
    to_array = Array::from_iter;

    // Zip two iterators.
    zip : Iterator b -> Iterator a -> Iterator (a, b);
    zip = |iter0, iter1| (
        let next = |_| (
            let iter0_next = iter0.advance;
            if iter0_next.is_none { none() };
            let iter1_next = iter1.advance;
            if iter1_next.is_none { none() };
            let (v0, iter0) = iter0_next.as_some;
            let (v1, iter1) = iter1_next.as_some;
            some $ ((v1, v0), zip(iter0, iter1))
        );
        Iterator { next: next }
    );
}

impl Iterator a : Add {
    add = |lhs, rhs| lhs.append(rhs);
}

impl [a : Eq] Iterator a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_empty { rhs.is_empty };
        if rhs.is_empty { false };
        let (e, lhs) = lhs.advance.as_some;
        let (f, rhs) = rhs.advance.as_some;
        if e != f { false };
        lhs == rhs
    );
}

impl Iterator : Functor {
    map = |f, a_iter| (
        let next = |_| (
            a_iter.advance.map(
                |(a_val, a_iter)| (f(a_val), a_iter.map(f))
            )
        );
        Iterator { next: next }
    );
}

impl Iterator : Monad {
    pure = |e| Iterator::empty.push_front(e);
    bind = |f, xs| xs.map(f)._flatten;
}

// The type of lazily generated values.
// This is a type alias defined as `type Lazy a = () -> a;`
// You can create a lazy value by `|_| (...an expression to generate the value...)`, and  
// you can evaluate a lazy value `v` by `v()`.
type Lazy a = () -> a;

// LoopResult

namespace LoopResult {

    // Make a break value wrapped in a monad.
    // This is used with `loop_m` function.
    break_m : [m : Monad] r -> m (LoopResult s r);
    break_m = break >> pure;

    // Make a continue value wrapped in a monad.
    // This is used with `loop_m` function.
    continue_m : [m : Monad] s -> m (LoopResult s r);
    continue_m = continue >> pure;

}

type Option a = union { none: (), some: a };

namespace Option {

    // Unwrap an option value if it is `some`, or returns given default value if it is `none`.
    as_some_or : a -> Option a -> a;
    as_some_or = |def, opt| (
        if opt.is_none { def } else { opt.as_some }
    );

    // Returns the provided default value if the option is none, or applies a function to the contained value if the option is some.
    map_or : b -> (a -> b) -> Option a -> b;
    map_or = |def, f, opt| if opt.is_some { f(opt.as_some) } else { def };
}

impl [a : Eq] Option a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_some && rhs.is_some { lhs.as_some == rhs.as_some };
        lhs.is_none && rhs.is_none
    );
}

impl Option : Functor {
    map = |f, opt| (
        if opt.is_none {
            Option::none()
        } else {
            Option::some $ f $ opt.as_some
        }
    );
}

impl Option : Monad {
    pure = Option::some;
    bind = |f, opt| if opt.is_none { Option::none() } else { f(opt.as_some) };
}

// The type for file path.
// TODO: give better implementation.
type Path = unbox struct { _data: String };

namespace Path {

    // Parse a string.
    parse : String -> Option Path;
    parse = |s| Option::some $ Path { _data: s };

}

impl Path : ToString {
    to_string = @_data;
}

// The type of punched arrays. A punched array is an array from which a certain element has been removed.
// If you create a punched array `parr` by punching an array `arr` at an index `idx`, only elements of `arr` whose indices are outside `idx` are released when `parr` is released.
type PunchedArray a = unbox struct { _data : Destructor (Array a), idx : I64 };

namespace PunchedArray {

    // Plug in an element to a punched array to get back an array.
    // This function panics if (the internal data of) the given punched array is shared by multiple references.
    plug_in! : a -> PunchedArray a -> Array a;
    plug_in! = |elm, parr| (
        let PunchedArray { _data : data, idx : idx } = parr;
        let arr = data.set_dtor!(|_|()).@value; // Clear destructor and extract value.
        arr.force_unique!._unsafe_set(idx, elm) 
        // The above force_unique! is redundant and added just to be safe: as long as the user doesn't access to `_data` of `PunchedArray`, `arr` should be uniquely owned by `data`.
    );

    // Creates a punched array.
    // Expression `punch(idx, arr)` evaluates to a pair `(parr, elm)`, where `elm` is the value that was stored at `idx` of `arr` and `parr` is the punched `arr` at `idx`.
    // This function panics if the given array is shared by multiple references.
    punch! : I64 -> Array a -> (PunchedArray a, a);
    punch! = |idx, arr| (
        let arr = arr.assert_unique!(|_|"[PunchedArray::punch!] Called on a shared array.");
        let size = arr.get_size;
        eval assert(|_|"[PunchedArray::punch!] Index out of range.", 0 <= idx && idx < size);
        let elm = arr._unsafe_get(idx);
        let dtor = |arr| (
            let arr = arr._unsafe_set_size(0); // Avoid releaseing elements in the destructor of Array.
            loop((arr, 0), |(arr, i)| (
                if i == size { break $ () };
                if i == idx { continue $ (arr, i+1) };
                eval arr._unsafe_get(i); // Release the element.
                continue $ (arr, i+1)
            ))
        );
        let parr = PunchedArray { _data : Destructor::make(arr, dtor), idx : idx };
        (parr, elm)
    );
}

// A type of result value for a computation that may fail.
type Result e o = unbox union { ok : o, err: e };

namespace Result {

    // Returns the containing value if the value is ok, or otherwise aborts.
    unwrap : Result e o -> o;
    unwrap = |res| (
        if res.is_err {
            abort()
        } else {
            res.as_ok
        }
    );
}

impl Result e : Functor {
    map = |f, res| (
        if res.is_err {
            Result::err $ res.as_err
        } else {
            Result::ok $ f $ res.as_ok
        }
    );
}

impl Result e : Monad {
    pure = Result::ok;
    bind = |f, res| if res.is_err { Result::err $ res.as_err } else { f(res.as_ok) };
}

type String = unbox struct { _data : Array U8 };

namespace String {

    // Get the null-terminated C string.
    // Note that in case the string is not used after call of this function, the returned pointer will be already released.
    _get_c_str : String -> Ptr;
    _get_c_str = |s| s.@_data._get_ptr;

    // Create a `String` from a pointer to null-terminated C string.
    // If `ptr` is not pointing to a valid null-terminated C string, this function cause undefined behavior.
    _unsafe_from_c_str_ptr : Ptr -> String;
    _unsafe_from_c_str_ptr = |ptr| (
        let len = CALL_C[I64 strlen(Ptr), ptr];
        let buf_len = len + 1;
        let buf = Array::empty(buf_len)._unsafe_set_size(buf_len);
        eval CALL_C[Ptr memcpy(Ptr, Ptr, I64), buf._get_ptr, ptr, buf_len];
        String { _data : buf }
    );

    // Call a function with a null-terminated C string.
    borrow_c_str : (Ptr -> a) -> String -> a;
    borrow_c_str = |f, str| str.@_data.borrow_ptr(f);

    // Concatenate two strings.
    // Note: Since `s1.concat(s2)` puts `s2` after `s1`, `concat(lhs, rhs)` puts `lhs` after `rhs`.
    concat : String -> String -> String;
    concat = |rhs, lhs| (
        // Remove null terminator from lhs and append rhs.
        String { _data : lhs.@_data.pop_back.append(rhs.@_data) }
    );

    // Concatenate an iterator of strings.
    concat_iter : Iterator String -> String;
    concat_iter = |iter| (
        let len = iter.map(get_size).fold(0, add);
        let data_len = len + 1; // Add space for null terminator.
        let data = "".@_data.reserve(data_len);
        let data = iter.fold(data, |data, str| data.pop_back.append(str.@_data));
        String { _data : data }
    );

    // Create an empty string, which is reserved for a length.
    empty : I64 -> String;
    empty = |n| String { _data : Array::empty(n+1).push_back(0_U8) };

    // Create a string from C string (i.e., null-terminated byte array).
    from_c_str : Array U8 -> String;
    from_c_str = |buf| (
        // Return length.
        let len = buf.borrow_ptr(|ptr| CALL_C[I64 strlen(Ptr), ptr]);
        let buf = buf._unsafe_set_size(len + 1);
        String { _data : buf }
    );

    // Get the byte array of a string, containing null-terminator.
    get_bytes : String -> Array U8;
    get_bytes = @_data;

    // Get the first byte of a string. Returns none if the string is empty.
    get_first_byte : String -> Option U8;
    get_first_byte = |s| (
        if s.is_empty { Option::none() };
        Option::some $ s.@_data.@(0)
    );

    // Get the last byte of a string. Returns none if the string is empty.
    get_last_byte : String -> Option U8;
    get_last_byte = |s| (
        let len = s.get_size;
        if len == 0 { Option::none() };
        Option::some $ s.@_data.@(len - 1)
    );

    // Get the length of a string.
    get_size : String -> I64;
    get_size = |s| s.@_data.get_size - 1; // exclude null terminator

    // `String` version of `Array::get_sub`.
    get_sub : I64 -> I64 -> String -> String;
    get_sub = |s, e, str| (
        let len = str.get_size;
        String::from_c_str $ str.get_bytes._get_sub_size_asif(len, 1, s, e).push_back('\0')
    );

    // Returns if the string is empty or not.
    is_empty : String -> Bool;
    is_empty = |s| s.get_size == 0;

    // Join strings by a separator.
    join : String -> Iterator String -> String;
    join = |sep, strs| (
        strs.intersperse(sep).concat_iter
    );

    // Removes the last byte.
    // If the string is empty, this function does nothing.
    pop_back_byte : String -> String;
    pop_back_byte = |s| (
        if s.is_empty { s };
        s.mod__data(|bytes| bytes.pop_back.pop_back.push_back(0_U8))
    );

    // Removes the first byte of a string while it satisifies the specified condition.
    strip_first_bytes : (U8 -> Bool) -> String -> String;
    strip_first_bytes = |cond, str| (
        let len = str.get_size;
        let bytes = str.get_bytes;
        let n = loop(0, |i| (
            if i == len { break $ i };
            if !cond(bytes.@(i)) { break $ i };
            continue $ i + 1
        ));
        if n == 0 { str } else { str.get_sub(n, 0) }
    );

    // Removing leading whitespace characters.
    strip_first_spaces : String -> String;
    strip_first_spaces = strip_first_bytes(|c| CALL_C[I32 isspace(I32), c.to_I32] > 0_I32);

    // Removes the last byte of a string while it satisifies the specified condition.
    strip_last_bytes : (U8 -> Bool) -> String -> String;
    strip_last_bytes = |cond, s| (
        loop(s, |s|
            if s.is_empty { break $ s };
            if cond(s.get_last_byte.as_some) { 
                continue $ s.pop_back_byte
            } else {
                break $ s
            }
        )
    );

    // Removes newlines and carriage returns at the end of the string.
    strip_last_newlines : String -> String;
    strip_last_newlines = strip_last_bytes(|c| c == '\n' || c == '\r');

    // Removing trailing whitespace characters.
    strip_last_spaces : String -> String;
    strip_last_spaces = strip_last_bytes(|c| CALL_C[I32 isspace(I32), c.to_I32] > 0_I32);

    // Strip leading and trailing whitespace characters.
    strip_spaces : String -> String;
    strip_spaces = |s| s.strip_last_spaces.strip_first_spaces;
}

impl String : Add {
    // Concatenate two strings.
    add = |lhs, rhs| lhs.concat(rhs);
}

impl String : Eq {
    // Compare two strings.
    eq = |lhs, rhs| (lhs.@_data == rhs.@_data);
}

impl String : ToString {
    to_string = |s| s;
}

// Unit
impl () : Eq {
    eq = |_, _| true;
}

// Function

// Compose two functions. Composition operators `<<` and `>>` is translated to use of `compose`. 
compose : (a -> b) -> (b -> c) -> a -> c;
compose = |f, g, a| g(f(a));

// Monadic loop function. This is similar to `loop` but can be used to perform monadic action at each loop.
loop_m : [m : Monad] s -> (s -> m (LoopResult s r)) -> m r;
loop_m = |s, f| (
    let res = *f(s);
    if res.is_break { pure $ res.as_break };
    loop_m(res.as_continue, f)
);

// Constants

namespace I8 {
    maximum : I8;
    maximum = 127_I8;

    minimum : I8;
    minimum = -128_I8;
}
impl I8 : Zero {
    zero = 0_I8;
}

namespace U8 {
    maximum : U8;
    maximum = 255_U8;

    minimum : U8;
    minimum = 0_U8;
}
impl U8 : Zero {
    zero = 0_U8;
}

namespace I16 {
    maximum : I16;
    maximum = 32767_I16;

    minimum : I16;
    minimum = -32768_I16;
}
impl I16 : Zero {
    zero = 0_I16;
}

namespace U16 {
    maximum : U16;
    maximum = 65535_U16;

    minimum : U16;
    minimum = 0_U16;
}
impl U16 : Zero {
    zero = 0_U16;
}

namespace I32 {
    maximum : I32;
    maximum = 2147483647_I32;

    minimum : I32;
    minimum = -2147483648_I32;
}
impl I32 : Zero {
    zero = 0_I32;
}

namespace U32 {
    maximum : U32;
    maximum = 4294967295_U32;

    minimum : U32;
    minimum = 0_U32;
}
impl U32 : Zero {
    zero = 0_U32;
}

namespace I64 {
    maximum : I64;
    maximum = 9223372036854775807;

    minimum : I64;
    minimum = -9223372036854775808;
}
impl I64 : Zero {
    zero = 0_I64;
}

namespace U64 {
    maximum : U64;
    maximum = 18446744073709551615_U64;

    minimum : U64;
    minimum = 0_U64;
}
impl U64 : Zero {
    zero = 0_U64;
}

impl F32 : Zero {
    zero = 0.0_F32;
}

impl F64 : Zero {
    zero = 0.0_F64;
}

// Traits

trait Additive = Add + Zero;

trait a : FromBytes {
    from_bytes : Array U8 -> Result ErrMsg a;
}

trait a : FromString {
    from_string : String -> Result ErrMsg a;
}

trait [f : *->*] f : Functor {
    map : (a -> b) -> f a -> f b;
}

namespace LessThan {
    max : [a : LessThan] a -> a -> a;
    max = |x, y| if x < y { y } else { x };

    min : [a : LessThan] a -> a -> a;
    min = |x, y| if x < y { x } else { y };
}

trait [m : *->*] m : Monad {
    bind : (a -> m b) -> m a -> m b;
    pure : a -> m a;
}

namespace Monad {
    flatten : [m : Monad] m (m a) -> m a;
    flatten = Monad::bind(|x|x);
}

trait a : ToBytes {
    to_bytes : a -> Array U8;
}

trait a : ToString {
    to_string : a -> String;
}

trait a : Zero {
    zero : a;
}

// Abs

namespace I8 {
    abs : I8 -> I8;
    abs = |f| if f < 0_I8 { -f } else { f };
}

namespace I16 {
    abs : I16 -> I16;
    abs = |f| if f < 0_I16 { -f } else { f };
}

namespace I32 {
    abs : I32 -> I32;
    abs = |f| if f < 0_I32 { -f } else { f };
}

namespace I64 {
    abs : I64 -> I64;
    abs = |f| if f < 0 { -f } else { f };
}

namespace F32 {
    abs : F32 -> F32;
    abs = |f| if f < 0.0_F32 { -f } else { f };
}

namespace F64 {
    abs : F64 -> F64;
    abs = |f| if f < 0.0 { -f } else { f };
}

// ToString, FromString implementations for fundamental types

impl U8 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(1)._unsafe_set_size(1);
        eval CALL_C[() fixruntime_u8_to_bytes(Ptr, U8), data._get_ptr, v];
        data
    );
}
impl U8 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 1 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U8."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[U8 fixruntime_u8_from_bytes(Ptr), ptr])
    );
}
impl U8 : ToString {
    to_string = |v| (
        let data = Array::empty(4); // len(255) + 1
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_u8_to_str(Ptr, U8), ptr, v]
        ));
        String::from_c_str(data)
    );
}
impl U8 : FromString {
    from_string = |str| str.from_string.map(U64::to_U8);
}

impl U16 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(2)._unsafe_set_size(2);
        eval CALL_C[() fixruntime_u16_to_bytes(Ptr, U16), data._get_ptr, v];
        data
    );
}
impl U16 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 2 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U16."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[U16 fixruntime_u16_from_bytes(Ptr), ptr])
    );
}
impl U16 : ToString {
    to_string = |v| (
        let data = Array::empty(6); // len(65535) + 1
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_u16_to_str(Ptr, U16), ptr, v]
        ));
        String::from_c_str(data)
    );
}
impl U16 : FromString {
    from_string = |str| str.from_string.map(U64::to_U16);
}

impl U32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        eval CALL_C[() fixruntime_u32_to_bytes(Ptr, U32), data._get_ptr, v];
        data
    );
}
impl U32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U32."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[U32 fixruntime_u32_from_bytes(Ptr), ptr])
    );
}
impl U32 : ToString {
    to_string = |v| (
        let data = Array::empty(11);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_u32_to_str(Ptr, U32), ptr, v]
        ));
        String::from_c_str(data)
    );
}
impl U32 : FromString {
    from_string = |str| str.from_string.map(U64::to_U32);
}

impl U64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        eval CALL_C[() fixruntime_u64_to_bytes(Ptr, U64), data._get_ptr, v];
        data
    );
}
impl U64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U64."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[U64 fixruntime_u64_from_bytes(Ptr), ptr])
    );
}
impl U64 : ToString {
    to_string = |v| (
        let data = Array::empty(20);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_u64_to_str(Ptr, U64), ptr, v]
        ));
        String::from_c_str(data)
    );
}
impl U64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = CALL_C[U64 fixruntime_strtoull_10(Ptr), c_str];
            let err = CALL_C[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (invalid format): " + str) };
            let err = CALL_C[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl I8 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(1)._unsafe_set_size(1);
        eval CALL_C[() fixruntime_u8_to_bytes(Ptr, I8), data._get_ptr, v];
        data
    );
}
impl I8 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 1 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I8."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[I8 fixruntime_u8_from_bytes(Ptr), ptr])
    );
}
impl I8 : ToString {
    to_string = |v| (
        let data = Array::empty(5); // len(-128) + 1
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_i8_to_str(Ptr, I8), ptr, v]
        ));
        String::from_c_str(data)
    );
}
impl I8 : FromString {
    from_string = |str| str.from_string.map(I64::to_I8);
}

impl I16 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(2)._unsafe_set_size(2);
        eval CALL_C[() fixruntime_u16_to_bytes(Ptr, I16), data._get_ptr, v];
        data
    );
}
impl I16 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 2 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I16."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[I16 fixruntime_u16_from_bytes(Ptr), ptr])
    );
}
impl I16 : ToString {
    to_string = |v| (
        let data = Array::empty(7); // len(-32768) + 1
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_i16_to_str(Ptr, I16), ptr, v]
        ));
        String::from_c_str(data)
    );
}
impl I16 : FromString {
    from_string = |str| str.from_string.map(I64::to_I16);
}

impl I32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        eval CALL_C[() fixruntime_u32_to_bytes(Ptr, I32), data._get_ptr, v];
        data
    );
}
impl I32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I32."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[I32 fixruntime_u32_from_bytes(Ptr), ptr])
    );
}
impl I32 : ToString {
    to_string = |v| (
        let data = Array::empty(12);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_i32_to_str(Ptr, I32), ptr, v]
        ));
        String::from_c_str(data)
    );
}
impl I32 : FromString {
    from_string = |str| str.from_string.map(I64::to_I32);
}

impl I64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        eval CALL_C[() fixruntime_u64_to_bytes(Ptr, I64), data._get_ptr, v];
        data
    );
}
impl I64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I64."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[I64 fixruntime_u64_from_bytes(Ptr), ptr])
    );
}
impl I64 : ToString {
    to_string = |v| (
        let data = Array::empty(21);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_i64_to_str(Ptr, I64), ptr, v]
        ));
        String::from_c_str(data)
    );
}
impl I64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = CALL_C[I64 fixruntime_strtoll_10(Ptr), c_str];
            let err = CALL_C[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (invalid format): " + str) };
            let err = CALL_C[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl F32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        eval CALL_C[() fixruntime_f32_to_bytes(Ptr, F32), data._get_ptr, v];
        data
    );
}
impl F32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as F32."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[F32 fixruntime_f32_from_bytes(Ptr), ptr])
    );
}
impl F32 : ToString {
    to_string = |v| (
        let data = Array::empty(50);
        eval CALL_C[() fixruntime_f32_to_str(Ptr, F32), data._get_ptr, v];
        String::from_c_str(data)
    );
}
namespace F32 {
    // Convert a floating number to a string of exponential form.
    to_string_exp : F32 -> String;
    to_string_exp = |v| (
        let data = Array::empty(50);
        eval CALL_C[() fixruntime_f32_to_str_exp(Ptr, F32), data._get_ptr, v];
        String::from_c_str(data)
    );

    // Convert a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).
    to_string_exp_precision : U8 -> F32 -> String;
    to_string_exp_precision = |prec, v| (
        let data = Array::empty(50 + prec.to_I64);
        eval CALL_C[() fixruntime_f32_to_str_exp_precision(Ptr, F32, U8), data._get_ptr, v, prec];
        String::from_c_str(data)
    );

    // Convert a floating number to a string with specified precision (i.e., number of digits after the decimal point).
    to_string_precision : U8 -> F32 -> String;
    to_string_precision = |prec, v| (
        let data = Array::empty(50 + prec.to_I64);
        eval CALL_C[() fixruntime_f32_to_str_precision(Ptr, F32, U8), data._get_ptr, v, prec];
        String::from_c_str(data)
    );
}
impl F32 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = CALL_C[F32 fixruntime_strtof(Ptr), c_str];
            let err = CALL_C[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to number (invalid format): " + str) };
            let err = CALL_C[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to number (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl F64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        eval CALL_C[() fixruntime_f64_to_bytes(Ptr, F64), data._get_ptr, v];
        data
    );
}
impl F64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as F64."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[F64 fixruntime_f64_from_bytes(Ptr), ptr])
    );
}
impl F64 : ToString {
    to_string = |v| (
        let data = Array::empty(500);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_f64_to_str(Ptr, F64), ptr, v]
        ));
        String::from_c_str(data)
    );
}
namespace F64 {
    // Convert a floating number to a string of exponential form.
    to_string_exp : F64 -> String;
    to_string_exp = |v| (
        let data = Array::empty(500);
        eval CALL_C[() fixruntime_f64_to_str_exp(Ptr, F64), data._get_ptr, v];
        String::from_c_str(data)
    );

    // Convert a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).
    to_string_exp_precision : U8 -> F64 -> String;
    to_string_exp_precision = |prec, v| (
        let data = Array::empty(500 + prec.to_I64);
        eval CALL_C[() fixruntime_f64_to_str_exp_precision(Ptr, F64, U8), data._get_ptr, v, prec];
        String::from_c_str(data)
    );

    // Convert a floating number to a string with specified precision (i.e., number of digits after the decimal point).
    to_string_precision : U8 -> F64 -> String;
    to_string_precision = |prec, v| (
        let data = Array::empty(500 + prec.to_I64);
        eval CALL_C[() fixruntime_f64_to_str_precision(Ptr, F64, U8), data._get_ptr, v, prec];
        String::from_c_str(data)
    );
}
impl F64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = CALL_C[F64 fixruntime_strtod(Ptr), c_str];
            let err = CALL_C[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to number (invalid format): " + str) };
            let err = CALL_C[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to number (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl [a : ToString, b : ToString] (a, b) : ToString {
    to_string = |(l, r)| "(" + l.to_string + ", " + r.to_string + ")";
}

// Eq Implementation for fundamental types

impl [a : Eq, b : Eq] (a, b) : Eq {
    eq = |(a, b), (c, d)| a == c && b == d;
}