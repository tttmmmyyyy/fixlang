// Module `Std` provides basic types, traits and values.
// 
// This module is special in the sense that: 
// - It is always imported implicitly. If you don't want to import some or all of entities in this module, you should write `import Std {...entities...}` explicitly.
// - It contains built-in types or values which are defined or implemented directly by Fix compiler, not by Fix source code.
// 
// NOTE on tuples: 
// The tuple types `Std::TupleN` are defined on demand, i.e., if the user uses N-tuple in the source code, 
// the compiler generates definition `TupleN` and related functions / trait implementations.
// The document for `Std` module describes about them up to N=3, but you can use larger tuples in the same way.
module Std;

// A union type with variants `continue` and `break`.
// 
// This type is used to represent the result of a loop body function passed to `Std::loop` or other similar functions.
type LoopResult s b = unbox union { continue : s, break : b };

namespace Array {

    // A function like `get_sub`, but behaves as if the size of the array is the specified value, 
    // and has a parameter to specify additional capacity of the returned `Array`.
    _get_sub_size_with_length_and_additional_capacity : I64 -> I64 -> I64 -> I64 -> Array a -> Array a;
    _get_sub_size_with_length_and_additional_capacity = |len, additional_capacity, s, e, arr| (
        let s = max(0, s);
        let e = min(len, e);
        let n = if e > s { e - s } else { 0 };
        let res = Array::empty(n + additional_capacity);
        if n == 0 || len == 0 { res };
        loop((s, res), |(i, res)| (
            if i == e { break $ res };
            let res = res.push_back(arr.@(i));
            continue $ (i + 1, res)
        ))
    ); 

    // Sorts elements in a range of a vector by "less than" comparator.
    // 
    // This function receives a working buffer as the first argument to reduce memory allocation, and returns it as second element.
    _sort_range_using_buffer : Array a -> I64 -> I64 -> ((a, a) -> Bool) -> Array a -> (Array a, Array a);
    _sort_range_using_buffer = |buffer, begin, end, less_than, vec| (
        // Merge sorting.
        let len = end - begin;
        if len <= 1 { (vec, buffer) };
        // Divide into intervals.
        let former_len = len / 2;
        let former_begin = begin;
        let former_end = begin + former_len;
        let latter_len = len - former_len;
        let latter_begin = former_end;
        let latter_end = end;
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, former_begin, former_end, less_than);
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, latter_begin, latter_end, less_than);
        // Merge former and latter to buffer.
        let buffer = buffer.truncate(0);
        let former_pos = former_begin;
        let latter_pos = latter_begin;
        let buffer = loop((former_pos, latter_pos, buffer), |(former_pos, latter_pos, buffer)|(
            if former_pos == former_end { // If former_pos reached to the end,
                if latter_pos == latter_end { break $ buffer };
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(vec.@(latter_pos));
                continue $ (former_pos, latter_pos + 1, buffer)
            };
            if latter_pos == latter_end { // If latter_pos reached to the end,
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(vec.@(former_pos));
                continue $ (former_pos + 1, latter_pos, buffer)
            };
            let former_elem = vec.@(former_pos);
            let latter_elem = vec.@(latter_pos);
            if less_than((former_elem, latter_elem)) {
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(former_elem);
                continue $ (former_pos + 1, latter_pos, buffer)
            } else {
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(latter_elem);
                continue $ (former_pos, latter_pos + 1, buffer)
            }
        ));
        // Copy buffer to vec.
        loop((0, vec), |(idx, vec)|(
            if idx == len { break $ (vec, buffer) };
            let vec = vec.set(begin + idx, buffer.@(idx));
            continue $ (idx + 1, vec)
        ))
    );

    // Modifies an array by a functorial action. 
    // 
    // Semantically, `arr.act(idx, fun)` is equivalent to `fun(arr.@(idx)).map(|elm| arr.set(idx, elm))`.
    // 
    // This function can be defined for any functor `f` in general, but it is easier to understand the behavior when `f` is a monad: 
    // the monadic action `act(idx, fun, arr)` first performs `fun(arr.@(idx))` to get a value `elm`, and returns a pure value `arr.set(idx, elm)`. 
    // 
    // If you call `arr.act(idx, fun)` when both of `arr` and `arr.@(idx)` are unique, it is assured that `fun` receives the unique value.
    // 
    // If you call `act` on an array which is shared, this function clones the given array when inserting the result of your action into the array. 
    // This means that you don't need to pay cloning cost when your action failed, as expected.
    act : [f : Functor] I64 -> (a -> f a) -> Array a -> f (Array a);
    act = |idx, fun, arr| (
        let (unique, arr) = arr.unsafe_is_unique;
        if unique {
            let (parr, elm) = PunchedArray::unsafe_punch(idx, arr);
            fun(elm).map(|elm| parr.plug_in(elm))
        } else {
            fun(arr.@(idx)).map(|elm| arr.set(idx, elm))
        }
    );

    // Appends an array to an array.
    // 
    // Note: Since `a1.append(a2)` puts `a2` after `a1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Array a -> Array a -> Array a;
    append = |v2, v1| (
        let v1_len = v1.get_size;
        let v2_len = v2.get_size;

        // Reserve v1's buffer and force uniqueness.        
        let len = v1_len + v2_len;
        let v1 = if v1.get_capacity < len {
            v1.reserve(max(len, 2 * v1.get_capacity))
        } else {
            v1._unsafe_force_unique
        };
        
        // Set length.
        let v1 = v1._unsafe_set_size(len);

        // Copy elements of v2 to v1.
        loop((0, v1), |(idx, v1)|(
            if idx >= v2_len { break $ v1 };
            let v1 = v1._unsafe_set(v1_len + idx, v2.@(idx));
            continue $ (idx+1, v1)
        ))
    );

    // Finds the first index at which the element satisfies a condition.
    find_by : (a -> Bool) -> Array a -> Option I64;
    find_by = |cond, arr| (
        let len = arr.get_size;
        loop(0, |idx| (
            if idx == len { break $ Option::none $ () };
            if cond(arr.@(idx)) { break $ Option::some $ idx };
            continue $ idx + 1
        ))
    );

    // Create an array from an iterator.
    from_iter : Iterator a -> Array a;
    from_iter = |iter| (
        let len = iter.get_size;
        let arr = Array::empty(len)._unsafe_set_size(len);
        iter.fold((arr, 0), |(arr, idx), elem| (
            let arr = arr._unsafe_set(idx, elem);
            (arr, idx+1)
        )).@0
    );

    // Creates an array by a mapping function.
    from_map : I64 -> (I64 -> a) -> Array a;
    from_map = |size, map| (
        let arr = Array::empty(size)._unsafe_set_size(size);
        loop((0, arr), |(idx, arr)|(
            if idx == size {
                break $ arr
            } else {
                let arr = arr._unsafe_set(idx, map(idx));
                continue $ (idx + 1, arr)
            }
        ))
    );

    // Gets the first element of an array. Returns none if the array is empty.
    get_first : Array a -> Option a;
    get_first = |arr| (
        if arr.is_empty { Option::none() };
        Option::some $ arr.@(0)
    );

    // Gets the last element of an array. Returns none if the array is empty.
    get_last : Array a -> Option a;
    get_last = |arr| (
        let len = arr.get_size;
        if len == 0 { Option::none() };
        Option::some $ arr.@(len - 1)
    );

    // `arr.get_sub(s, e)` returns an array `[ arr.@(i) | i âˆˆ [s, e) ]`.
    // 
    // `s` and `e` are clamped to the range `[0, arr.get_size]`.
    get_sub : I64 -> I64 -> Array a -> Array a;
    get_sub = |s, e, arr| arr._get_sub_size_with_length_and_additional_capacity(arr.get_size, 0, s, e);

    // Returns if the array is empty
    is_empty : Array a -> Bool;
    is_empty = |arr| ( arr.get_size == 0 );

    // Pops an element at the back of an array.
    // If the array is empty, this function does nothing.
    pop_back : Array a -> Array a;
    pop_back = |arr| (
        let len = arr.get_size;
        if len == 0 { arr };
        arr._unsafe_force_unique._unsafe_set_size(len-1)._unsafe_get_linear(len-1).@0
    );

    // Pushes an element to the back of an array.
    push_back : a -> Array a -> Array a;
    push_back = |e, arr| (
        let len = arr.get_size;
        let arr = if arr.get_capacity < len + 1 {
            arr.reserve(2*(len + 1))
        } else {
            arr
        };
        arr._unsafe_force_unique._unsafe_set_size(len+1)._unsafe_set(len, e)
    );

    // Reserves the memory region for an array.
    // 
    // TODO: change to more optimized implementation.
    reserve : I64 -> Array a -> Array a;
    reserve = |cap, arr| (
        if cap <= arr.get_capacity { arr };
        let len = arr.get_size;
        let new = Array::empty(cap)._unsafe_set_size(len);
        loop((0, new), |(idx, new)|(
            if idx == len {
                break $ new
            } else {
                let new = new._unsafe_set(idx, arr.@(idx));
                continue $ (idx + 1, new)
            }
        ))
    );

    // Sorts elements in a vector by "less than" comparator.
    sort_by : ((a, a) -> Bool) -> Array a -> Array a;
    sort_by = |less_than, vec| (
        let buffer = Array::empty(vec.get_size);
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, 0, vec.get_size, less_than);
        vec
    );

    // Converts an array to an iterator.
    to_iter : Array a -> Iterator a;
    to_iter = Iterator::from_array;

    // Truncates an array, keeping the given number of first elements.
    // 
    // `truncante(len, arr)` does nothing if `len >= arr.get_size`.
    truncate : I64 -> Array a -> Array a;
    truncate = |length, vec| (
        loop(vec, |vec|(
            if length >= vec.get_size { break $ vec };
            continue $ vec.pop_back
        ))
    );
}

impl [a : Eq] Array a : Eq {
    eq = |lhs, rhs| (
        if lhs.get_size != rhs.get_size { false };
        let len = lhs.get_size;
        loop(0, |idx| (
            if idx == len { break $ true };
            if lhs.@(idx) != rhs.@(idx) { break $ false };
            continue $ idx + 1
        ))
    );
}

// `LessThan` implementation for `Array a`.
// 
// Compares two arrays by lexicographic order.
impl [a : Eq, a : LessThan] Array a : LessThan {
    less_than = |lhs, rhs| (
        loop(0, |i| (
            if i == lhs.get_size && i == rhs.get_size { break $ false };
            if i == lhs.get_size { break $ true };
            if i == rhs.get_size { break $ false };
            let l = lhs.@(i);
            let r = rhs.@(i);
            if l != r { break $ l < r };
            continue $ i + 1
        ))
    );
}

// `LessThanOrEq` implementation for `Array a`.
// 
// Compares two arrays by lexicographic order.
impl [a : Eq, a : LessThanOrEq] Array a : LessThanOrEq {
    less_than_or_eq = |lhs, rhs| (
        loop(0, |i| (
            if i == lhs.get_size && i == rhs.get_size { break $ true };
            if i == lhs.get_size { break $ true };
            if i == rhs.get_size { break $ false };
            let l = lhs.@(i);
            let r = rhs.@(i);
            if l != r { break $ l <= r };
            continue $ i + 1
        ))
    );
}

impl Array : Functor {
    map = |f, arr| (
        let n = arr.get_size;
        let res = Array::empty(n);
        loop((0, res), |(i, res)| (
            if i == n { break $ res };
            let e = f $ arr.@(i);
            continue $ (i+1, res.push_back(e))
        ))
    );
}

impl Array : Monad {
    pure = |e| [e];
    bind = |f, arr| (
        let size = arr.get_size;
        let arr_arr = Array::empty(size);
        let (arr_arr, count) = loop((0, arr_arr, 0), |(idx, arr_arr, count)| (
            if idx == size { break $ (arr_arr, count) };
            let inner = f $ arr.@(idx);
            let count = count + inner.get_size;
            let arr_arr = arr_arr.push_back(inner);
            continue $ (idx + 1, arr_arr, count)
        ));
        let ret = Array::empty(count);
        loop((0, ret), |(i, ret)| (
            if i == size { break $ ret };
            let inner = arr_arr.@(i);
            continue $ loop((0, ret), |(j, ret)|(
                if j == inner.get_size {
                    break $ (i + 1, ret)
                } else {
                    let ret = ret.push_back(inner.@(j));
                    continue $ (j + 1, ret)
                }
            ))
        ))
    );
}

impl [a : ToString] Array a : ToString {
    to_string = |arr| ("[" + arr.to_iter.map(to_string).join(", ") + "]");
}

impl Arrow a : Functor {
    map = |f, a| a >> f;
}

impl Arrow a : Monad {
    pure = |x| |_| x;
    bind = |f, a| |x| f(a(x)) $ x;
}

impl Bool : ToString {
    to_string = |lhs| (
        if lhs { "true" } else { "false" }
    );
}

// Boxed wrapper for a type.
type Box a = box struct { value : a };

namespace Box {
    make : a -> Box a;
    make = |val| Box { value : val };
}

// Marker trait for boxed types.
// 
// This trait is automatically implemented for all boxed types.
// Implementing this trait manually is not allowed.
trait a : Boxed {}

// A type (alias) for error message. 
type ErrMsg = String;

namespace FFI {

    // `x.mutate_boxed_io(io)` gets a pointer `ptr` to the data that `x` points to, executes `io(ptr)`, and then returns mutated `x` paired with the result of `io(ptr)`.
    // 
    // Similar to `mutate_boxed`, but this function is used when you want to run the IO action in the existing IO context.
    // 
    // For more details, see the document of `mutate_boxed`.
    mutate_boxed_io : [a : Boxed] (Ptr -> IO b) -> a -> IO (a, b);
    mutate_boxed_io = |act, val| IO::from_runner $ |ios| mutate_boxed_ios(act, val, ios);

    // Borrows a pointer to the data of a boxed value.
    // 
    // For the details of the pointer, see the document of `_get_boxed_ptr`.
    borrow_boxed : [a : Boxed] (Ptr -> b) -> a -> b;
    borrow_boxed = |act, val| val.do_with_retained(|val| act(val._get_boxed_ptr));

    // Performs an IO action borrowing a pointer to the data of a boxed value.
    // 
    // For the details of the pointer, see the document of `_get_boxed_ptr`.
    borrow_boxed_io : [a : Boxed] (Ptr -> IO b) -> a -> IO b;
    borrow_boxed_io = |act, val| IO::from_runner $ |ios| val.borrow_boxed(|ptr| (act(ptr).@runner)(ios));

    // Gets errno which is set by C functions.
    get_errno : IO CInt;
    get_errno = FFI_CALL_IO[CInt fixruntime_get_errno()];

    // Sets errno to zero.
    clear_errno : IO ();
    clear_errno = FFI_CALL_IO[() fixruntime_clear_errno()];

    // `Destructor a` is a wrapper type for `a`, which can have a destructor function `a -> IO a`.
    // Just before a value of type `Destructor a` is dropped, the destructor function is called on the contained value, and the value can be modified by the `IO` action.
    // 
    // This type is used to create a Fix's type that wraps a resource allocated by FFI. In such cases, the destructor release the resource by FFI.
    // 
    // NOTE: In the destructor, only IO actions for finalizing the passed value are allowed, and you should not perform other IO actions such as writing standard output.
    // 
    // NOTE: Of course, if the value stored in `Destructor` also exists outside of `Destructor`, the value still exists in the Fix program even after the destructor function is called, 
    // and there is a possibility that the value is used after the destructor function is called.
    type Destructor a = box struct { _value : a, dtor : a -> IO a };    

    namespace Destructor {
        // Borrow the contained value.
        // 
        // `borrow(worker, dtor)` calls `worker` on the contained value captured by `dtor`, and returns the value returned by `worker`.
        // 
        // It is guaranteed that the `dtor` is alive during the call of `worker`.
        // In other words, the `worker` receives the contained value for which the destructor is not called yet.
        borrow : (a -> b) -> Destructor a -> b;
        borrow = |worker, dtor| dtor.do_with_retained(|dtor| worker(dtor.@_value));

        // Performs an IO action borrowing the contained value.
        borrow_io : (a -> IO b) -> Destructor a -> IO b;
        borrow_io = |act, dtor| IO::from_runner $ |ios| dtor.borrow(|val| (act(val).@runner)(ios));

        // Make a destructor value.
        make : a -> (a -> IO a) -> Destructor a;
        make = |val, dtor| Destructor { _value : val, dtor : dtor };

        // Apply an IO action which mutates the semantics of the value.
        //
        // `dtor.mutate_unique(ctor, action)` applies `action` to `dtor` if `dtor` is unique. 
        // If `dtor` is shared, it creates a new `Destructor` value using `ctor` and applies `action` to the new value.
        // 
        // The `action` is allowed to modify the external resource stored in `dtor` (e.g., if `value` is a pointer, it can modify the value pointed by the pointer).
        // Also, `ctor` should be a "copy constructor" (e.g., memcpy) of the external resource stored in `dtor`.
        mutate_unique : (a -> IO a) -> (a -> IO b) -> Destructor a -> (Destructor a, b);
        mutate_unique = |ctr, action, dtor| dtor.mutate_unique_io(ctr, action).unsafe_perform;

        // Apply an IO action which mutates the semantics of the value.
        // 
        // This is similar to `mutate_unique`, but the `ctor` and `action` is executed in the context of the external `IO` context.
        mutate_unique_io : (a -> IO a) -> (a -> IO b) -> Destructor a -> IO (Destructor a, b);
        mutate_unique_io = |ctor, action, dtor| (
            let (unique, dtor) = dtor.unsafe_is_unique;
            if unique {
                let val = dtor.@_value;
                let res = *action(val);
                pure $ (dtor, res)
            } else {
                let val = dtor.@_value;
                let val = *ctor(val);
                let res = *action(val);
                let dtor = Destructor::make(val, dtor.@dtor);
                pure $ (dtor, res)
            }
        );
    }
}

// `IO a` is a type representing I/O actions which return values of type `a`.
type IO a = unbox struct { runner : IOState -> (IOState, a) };

namespace IO {
    // Reads characters from an IOHandle.
    // 
    // If the first argument `upto_newline` is true, this function reads a file upto newline or EOF.
    _read_line_inner : Bool -> IOHandle -> IOFail String;
    _read_line_inner = |upto_newline, handle| (
        IOFail::from_io_result $ do {
            let file_ptr = *handle.get_file_ptr;
            if file_ptr == nullptr {
                pure $ Result::err("`Std::IO::_read_line_inner` failed!: the IOHandle is already closed.")
            };
            loop_m("", |str|
                let buf_size = 1024;
                let buf = Array::empty(buf_size);
                let (buf, fgets_res) = *buf.mutate_boxed_io(|buf_ptr| (
                    FFI_CALL_IO[Ptr fgets(Ptr, I32, Ptr), buf_ptr, buf_size.to_I32, file_ptr]
                ));
                if fgets_res == nullptr {
                    let err = *FFI_CALL_IO[I32 ferror(Ptr), file_ptr];
                    if err != 0_I32 { 
                        let err = "`Std::IO::_read_line_inner` failed!: an error occurred in `fgets`.";
                        break_m $ Result::err(err)
                    } else {
                        break_m $ Result::ok(str)
                    }
                };
                let str = str + String::_unsafe_from_c_str(buf);
                if upto_newline {
                    // If the last character is \n, break.
                    let last_byte = str.get_last_byte.as_some;
                    if last_byte == '\n' { 
                        break_m $ Result::ok(str)
                    };
                    continue_m $ str
                } else {
                    continue_m $ str
                }
            )
        }
    );

    // Closes a file.
    // 
    // Unlike C's `fclose`, closing an already closed `IOHandle` is safe and does nothing.
    close_file : IOHandle -> IO ();
    close_file = |handle| handle.@_data.borrow_io(|handle_ptr| FFI_CALL_IO[() fixruntime_iohandle_close(Ptr), handle_ptr]);

    // Prints a string to stderr.
    eprint : String -> IO ();
    eprint = |str| str.borrow_c_str_io(|c_str| FFI_CALL_IO[I32 fputs(Ptr, Ptr), c_str, *stderr.get_file_ptr]);; pure();

    // Prints a string followed by a newline to stderr.
    eprintln : String -> IO ();
    eprintln = |str| eprint(str + "\n");

    // Exits the program with an error code.
    exit : I64 -> IO a;
    exit = |code| FFI_CALL_IO[() exit(I32), code.to_I32];; pure $ undefined("");

    // Exits the program with an error message and an error code.
    //  
    // The error message is written to the standard error output.
    exit_with_msg : I64 -> String -> IO a;
    exit_with_msg = |code, msg| eprintln(msg);; exit(code);

    // Creates an IO action from a IO runner function, which is a function of type `IOState -> (IOState, a)`.
    from_runner : (IOState -> (IOState, a)) -> IO a;
    from_runner = |runner| IO { runner : runner };

    // `get_arg(n)` returns the n-th (0-indexed) command line argument.
    // 
    // If n is greater than or equal to the number of command line arguments, this function returns none.
    get_arg : I64 -> IO (Option String);
    get_arg = |n| (
        let argc = *get_arg_count;
        if n >= argc { pure $ Option::none() };
        let arg_ptr = *(FFI_CALL_IO[Ptr fixruntime_get_argv(I64), n]);
        pure $ Option::some(String::_unsafe_from_c_str_ptr(arg_ptr))
    );

    // Gets the number of command line arguments.
    get_arg_count : IO I64;
    get_arg_count = (
        let argc = *(FFI_CALL_IO[I32 fixruntime_get_argc()]);
        pure $ argc.to_I64
    );

    // Gets command line arguments.
    get_args : IO (Array String);
    get_args = (
        let argc = *get_arg_count;
        let args = Array::empty(argc);
        loop_m((args, 0), |(args, idx)| (
            if idx == argc { break_m $ args };
            let arg = (*get_arg(idx)).as_some;
            continue_m $ (args.push_back(arg), idx + 1)
        ))
    );

    // Reads a line from stdin. If some error occurr, this function aborts the program.
    // 
    // If you want to handle errors, use `read_line(stdin)` instead.
    input_line : IO String;
    input_line = (
        let res = *read_line(stdin).to_result;
        if res.is_ok {
            pure $ res.as_ok
        } else {
            pure $ undefined(res.as_err.to_string)
        }
    );

    // Checks if an `IOHandle` reached to the EOF.
    is_eof : IOHandle -> IO Bool;
    is_eof = |handle| FFI_CALL_IO[I32 feof(Ptr), *handle.get_file_ptr].map(|res| res != 0_I32);

    // Loop on lines read from an `IOHandle`.
    // 
    // `loop_lines(handle, initial_state, worker)` calls `worker` on the pair of current state and a line string read from `handle`.
    // The function `worker` should return an updated state as `LoopResult` value, i.e., a value created by `continue` or `break`.
    // When the `handle` reaches to the EOF or `worker` returns a `break` value, `loop_lines` returns the last state value.
    // 
    // Note that the line string passed to `worker` may contain a newline code at the end. To remove it, use `String::strip_last_spaces`.
    loop_lines : IOHandle -> s -> (s -> String -> LoopResult s s) -> IOFail s;
    loop_lines = |handle, state, worker| (
        if *is_eof(handle).lift {
            pure $ state
        };
        let line = *read_line(handle);
        let res = worker(state, line);
        if res.is_break {
            pure $ res.as_break
        };
        let next_state = res.as_continue;
        loop_lines(handle, next_state, worker)
    );

    // Loop on lines read from an `IOHandle`.
    // 
    // Similar to `loop_lines`, but the worker function can perform an IO action.
    loop_lines_io : IOHandle -> s -> (s -> String -> IOFail (LoopResult s s)) -> IOFail s;
    loop_lines_io = |handle, state, worker| (
        if *is_eof(handle).lift {
            pure $ state
        };
        let line = *read_line(handle);
        let res = *worker(state, line);
        if res.is_break {
            pure $ res.as_break
        };
        let next_state = res.as_continue;
        loop_lines_io(handle, next_state, worker)
    );

    // Openes a file. The second argument is a mode string for `fopen` C function.
    open_file : Path -> String -> IOFail IOHandle;
    open_file = |path, mode| (
        let path = path.to_string;
        IOFail::from_io_result $ path.borrow_c_str_io(|path_ptr| mode.borrow_c_str_io(|mode_ptr|
            let file_ptr = *FFI_CALL_IO[Ptr fopen(Ptr, Ptr), path_ptr, mode_ptr];
            if file_ptr == nullptr { 
                pure $ Result::err $ "Failed to open a file: " + path
            } else {
                pure $ Result::ok $ IOHandle::from_file_ptr $ file_ptr
            }
        ))
    );

    // Prints a string to stdout.
    print : String -> IO ();
    print = |str| str.borrow_c_str_io(|c_str| FFI_CALL_IO[I32 fputs(Ptr, Ptr), c_str, *stdout.get_file_ptr]);; pure();

    // Prints a string followed by a newline to stdout.
    println : String -> IO ();
    println = |str| print(str + "\n");

    // Raads all characters from a file.
    read_file_string : Path -> IOFail String;
    read_file_string = |path| with_file(path, "r", read_string);

    // Reads all bytes from a file.
    read_file_bytes : Path -> IOFail (Array U8);
    read_file_bytes = |path| with_file(path, "r", read_bytes);

    // Reads characters from a IOHandle upto newline or EOF.
    // The returned string may include newline at its end.
    read_line : IOHandle -> IOFail String;
    read_line = _read_line_inner(true);

    // Reads all bytes from an IOHandle.
    read_bytes : IOHandle -> IOFail (Array U8);
    read_bytes = |handle| (
        // Get Iterator of Arrays.
        let (iter, len) = *loop_m((Iterator::empty, 0), |(iter, len)| (
            let bytes = *read_n_bytes(handle, 1024);
            if bytes.is_empty {
                break_m $ (iter.reverse, len)
            } else {
                continue_m $ (iter.push_front(bytes), len + bytes.get_size)
            }
        ));
        // Concatenate bytes.
        let res = Array::empty(len);
        pure $ iter.fold(res, |res, bytes| res.append(bytes))
    );

    // Reads at most n bytes from an IOHandle.
    read_n_bytes : IOHandle -> I64 -> IOFail (Array U8);
    read_n_bytes = |handle, n| IOFail::from_io_result $ do {
        // Get the file pointer.
        let file_ptr = *handle.get_file_ptr;

        // Read n bytes into a buffer.
        let buf = Array::empty(n);
        let (buf, len) = buf.mutate_boxed(|buf| FFI_CALL_IO[I64 fread(Ptr, I64, I64, Ptr), buf, 1, n, file_ptr]);

        // Check error.
        let err = *FFI_CALL_IO[I32 ferror(Ptr), file_ptr];
        if err != 0_I32 { 
            let err = "`Std::IO::read_n_bytes` failed!: Some error occurred in `fread`.";
            pure $ Result::err(err)
        };

        // Return the result.
        let buf = buf._unsafe_set_size(len);
        pure $ Result::ok(buf)
    };

    // Reads all characters from an IOHandle.
    read_string : IOHandle -> IOFail String;
    read_string = _read_line_inner(false);

    // The handle for standard error.
    stderr : IOHandle;
    stderr = (
        let ptr = "a".borrow_c_str(|mode| FFI_CALL[Ptr fdopen(I32, Ptr), 2_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // The handle for standard input.
    stdin : IOHandle;
    stdin = (
        let ptr = "r".borrow_c_str(|mode| FFI_CALL[Ptr fdopen(I32, Ptr), 0_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // The handle for standard output.
    stdout : IOHandle;
    stdout = (
        let ptr = "a".borrow_c_str(|mode| FFI_CALL[Ptr fdopen(I32, Ptr), 1_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // Performs a function with a file handle. The second argument is a mode string for `fopen` C function. 
    // 
    // The file handle will be closed automatically.
    with_file : Path -> String -> (IOHandle -> IOFail a) -> IOFail a;
    with_file = |path, mode, action| (
        let handle = *open_file(path, mode);
        let res = *action(handle);
        IOFail::lift(close_file(handle));;
        pure $ res
    );

    // Writes a byte array into an IOHandle.
    write_bytes : IOHandle -> Array U8 -> IOFail ();
    write_bytes = |handle, array| IOFail::from_io_result $ do {
        let file_ptr = *handle.get_file_ptr;
        let arr_size = array.get_size;
        array.borrow_boxed_io(|array_buf|
            let written = *FFI_CALL_IO[I64 fwrite(Ptr, I64, I64, Ptr), array_buf, 1, arr_size, file_ptr];
            if written < arr_size { pure $ Result::err $ "`Std::IO::write_bytes` failed!: some error occurred in `fwrite`." };
            pure $ Result::ok()
        )
    };

    // Writes a byte array into a file.
    write_file_bytes : Path -> Array U8 -> IOFail ();
    write_file_bytes = |path, content| with_file(path, "w", |handle| write_bytes(handle, content));

    // Writes a string into a file.
    write_file_string : Path -> String -> IOFail ();
    write_file_string = |path, content| with_file(path, "w", |handle| write_string(handle, content));

    // Writes a string into an IOHandle.
    write_string : IOHandle -> String -> IOFail ();
    write_string = |handle, content| IOFail::from_io_result $ do {
        let file_ptr = *handle.get_file_ptr;
        content.borrow_c_str_io(|c_str|
            let res = *FFI_CALL_IO[I32 fputs(Ptr, Ptr), c_str, file_ptr];
            if res < 0_I32 { pure $ Result::err $ "`Std::IO::write_string` failed!: some error occurred in fputs." };
            pure $ Result::ok()
        )
    };
}

impl IO : Functor {
    map = |f, io| IO::from_runner $ |iostate| (
        let (iostate, a) = (io.@runner)(iostate);
        (iostate, f(a))
    );
}

impl IO : Monad {
    pure = |v| IO { runner : |iostate| (iostate, v) };
    bind = |f, io| (
        IO::from_runner $ |iostate| (
            let (iostate, a) = (io.@runner)(iostate);
            (f(a).@runner)(iostate)
        )
    );
}

namespace IO {
    // A handle type for read / write operations on files, stdin, stdout, stderr.
    // 
    // You can create `IOHandle` value by `IO::open_file`, and close it by `IO::close_file`. 
    // There are also global `IO::IOHandle::stdin`, `IO::IOHandle::stdout`, `IO::IOHandle::stderr`.
    // 
    // `IOHandle` is different from C's `FILE` structure in that it is safe to close it twice.
    // If you try to get a file pointer by `file_ptr` from a closed `IOHandle`, you will get `nullptr`.
    //
    // NOTE: 
    // `IOHandle` is implemented by `Destructor`, but the destructor function does not close the file pointer.
    // (The destructor function only frees the management memory area.)
    // You should explicitly close the file pointer by `IO::close_file`.
    type IOHandle = unbox struct { _data : Destructor Ptr };
}

namespace IO::IOHandle {
    // Gets pointer to C's `FILE` value from an `IOHandle`.
    //
    // If the `IOHandle` is already closed, the function returns `nullptr`.
    // 
    // NOTE: 
    // Do not directly close the file pointer by `fclose` or other functions.
    // Instead you should close `IOHandle` by `IO::close_file`.
    //
    // DEPRECATED: 
    // Use `get_file_ptr` instead.
    // This function is deprecated because it has a pure function interface, but the value of `_file_ptr` changes by calling `IO::close_file`.
    _file_ptr : IOHandle -> Ptr;
    _file_ptr = |handle| handle.@_data.borrow(|handle_ptr| FFI_CALL[Ptr fixruntime_iohandle_get_file(Ptr), handle_ptr]);

    // Gets pointer to C's `FILE` value from an `IOHandle`.
    //
    // If the `IOHandle` is already closed, the function returns `nullptr`.
    // 
    // NOTE: 
    // Do not directly close the file pointer by `fclose` or other functions.
    // Instead you should close `IOHandle` by `IO::close_file`.
    // 
    // NOTE: 
    // If `IO::close` is called while using the `Ptr` obtained by this function, the `Ptr` becomes invalid and may cause undefined behavior.
    get_file_ptr : IOHandle -> IO Ptr;
    get_file_ptr = |handle| handle.@_data.borrow_io(|handle_ptr| FFI_CALL_IO[Ptr fixruntime_iohandle_get_file(Ptr), handle_ptr]);

    // Creates an `IOHandle` from a file pointer (i.e., pointer to C's `FILE`).
    // 
    // Creating two `IOHandle`s from a single file pointer is forbidden.
    from_file_ptr : Ptr -> IOHandle;
    from_file_ptr = |file_ptr| (
        let handle_ptr = FFI_CALL[Ptr fixruntime_iohandle_create(Ptr), file_ptr];
        let dtor = |handle_ptr| FFI_CALL_IO[() fixruntime_iohandle_delete(Ptr), handle_ptr];; pure $ nullptr;
        IOHandle { _data : Destructor::make(handle_ptr, dtor) }
    );
}

namespace IO {
    // The type for I/O actions which may fail.
    type IOFail a = unbox struct { _data : IO (Result ErrMsg a) };
}

namespace IO::IOFail {
    // Create from IO action of which returns `Result ErrMsg a`.
    from_io_result : IO (Result ErrMsg a) -> IOFail a;
    from_io_result = |io_res| IOFail { _data : io_res };

    // Creates an pure `IOFail` value from a `Result` value.
    from_result : Result ErrMsg a -> IOFail a;
    from_result = |res| IOFail { _data : pure(res) };

    // Lifts an `IO` action to a successful `IOFail` action.
    lift : IO a -> IOFail a;
    lift = |io| IOFail { _data : io.map(pure) };

    // Creates an error `IOFail` action.
    throw : ErrMsg -> IOFail a;
    throw = |e| from_result $ Result::err(e);

    // Converts an `IOFail` to an `Result` value (wrapped by `IO`).
    to_result : IOFail a -> IO (Result ErrMsg a);
    to_result = @_data;

    // Converts an `IOFail` value to an `IO` value by an error handler (i.e., a `catch`) function.
    try : (ErrMsg -> IO a) -> IOFail a -> IO a;
    try = |catch, iof| (
        let res = *iof.to_result;
        if res.is_ok { pure $ res.as_ok } else { catch(res.as_err) }
    );
}

impl IOFail : Functor {
    map = |f, iof| IOFail { _data : iof.@_data.map(map(f)) };
}

impl IOFail : Monad {
    pure = |v| IOFail { _data : pure(pure(v)) };
    bind = |f, iof| IOFail { _data : do {
        let res = *iof.@_data;
        if res.is_err { pure $ Result::err $ res.as_err };
        f(res.as_ok).@_data
    }};
}

// The type of iterators (a.k.a lazy list).
type Iterator a = unbox struct { next: () -> Option (a, Iterator a) };

namespace Iterator {

    // Flatten an iterator of iterators.
    // 
    // You should use `Monad::flatten` instead of this function.
    // This function is used in the implementation of `Monad::bind` for `Iterator`.
    _flatten : Iterator (Iterator a) -> Iterator a;
    _flatten = |iters| (
        let opt_iter = iters.advance;
        if opt_iter.is_none { Iterator::empty };
        let (iter, iters) = opt_iter.as_some;
        _flatten_sub(iter, iters)
    );

    _flatten_sub : Iterator a -> Iterator (Iterator a) -> Iterator a;
    _flatten_sub = |iter, iters| Iterator { next : |_| 
        let opt_elem = iter.advance;
        if opt_elem.is_none { iters._flatten.advance };
        let (elem, iter) = opt_elem.as_some;
        Option::some $ (elem, _flatten_sub(iter, iters))
    };

    // Gets next value and next iterator.
    advance : Iterator a -> Option (a, Iterator a);
    advance = |iter| (iter.@next)();

    // Appends an iterator to a iterator.
    // 
    // Note: Since `iter1.append(iter2)` puts `iter2` after `iter1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Iterator a -> Iterator a -> Iterator a;
    append = |rhs, lhs| (
        if lhs.is_empty { rhs };
        let next = |_| (
            lhs.advance.map(|(e, lhs)| (e, lhs.append(rhs)))
        );
        Iterator { next : next }
    );

    // Evaluates all elements of iterator.
    bang : Iterator a -> Iterator a;
    bang = |iter| iter.to_array.to_iter;

    // Creates an iterator that counts up from a number.
    // 
    // count_up(n) = [n, n+1, n+2, ...]
    count_up : I64 -> Iterator I64;
    count_up = |i| (
        let next = |_| (
            some $ (i, Iterator::count_up(i+1))
        );
        Iterator { next: next }
    );

    // Creates an empty iterator.
    empty : Iterator a;
    empty = (
        let next = |_| (none());
        Iterator { next: next }
    );

    // Filters elements by a condition function
    filter : (a -> Bool) -> Iterator a -> Iterator a;
    filter = |cond, iter| (
        let next = |_| (
            loop(iter, |iter| (
                let next = iter.advance;
                if next.is_none { break $ none() };
                let (v, iter) = next.as_some;
                if !cond(v) { continue $ iter };
                let iter = filter(cond, iter);
                break $ some((v, iter))
            ))
        );
        Iterator { next: next }
    );

    // Finds the last element of an iterator.
    find_last : Iterator a -> Option a;
    find_last = |iter| (
        if iter.is_empty { none() };
        let (elem, iter) = iter.advance.as_some;
        if iter.is_empty { 
            some(elem)
        } else {
            iter.find_last
        }
    );

    // Folds iterator from left to right.
    // 
    // Example: `fold(init, op, [a0, a1, a2, ...]) = ...op(op(op(init, a0), a1), a2)...`
    fold : b -> (b -> a -> b) -> Iterator a -> b;
    fold = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            match iter.advance {
                none() => break $ accum,
                some((next, iter)) => continue $ (op(accum, next), iter)
            }
        )
    );

    // Folds iterator from left to right by monadic action.
    fold_m : [m : Monad] b -> (b -> a -> m b) -> Iterator a -> m b;
    fold_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)| (
            let next = iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let accum = *op(accum, next);
            continue_m $ (accum, iter)
        ))
    );

    // Creates iterator from an array.
    from_array : Array a -> Iterator a;
    from_array = |arr| count_up(0).take(arr.get_size).map(|i| arr.@(i));

    // Creates iterator from mapping function.
    // 
    // from_map(f) = [f(0), f(1), f(2), ...]
    from_map : (I64 -> a) -> Iterator a;
    from_map = |f| count_up(0).map(f);

    // Generates an iterator from a state transition function.
    // 
    // - if `f(s)` is none, `generate(s, f)` is empty.
    // - if `f(s)` is some value `(e, s1)`, then `generate(s, f)` starts by `e` followed by `generate(s2, f)`.
    generate : s -> (s -> Option (a, s)) -> Iterator a;
    generate = |s, f| (
        let next = |_| f(s).map(|(e, s)| (e, Iterator::generate(s, f)));
        Iterator { next: next }
    );

    // Gets the first element of an iterator. If the iterator is empty, this function returns `none`.
    // 
    // TODO: add test
    get_first : Iterator a -> Option a;
    get_first = |iter| iter.advance.map(@0);

    // Counts the number of elements of an iterator.
    get_size : Iterator a -> I64;
    get_size = fold(0, |acm, _| acm + 1);

    // Removes the first element from an iterator. If the iterator is empty, this function returns `none`.
    // 
    // TODO: add test
    get_tail : Iterator a -> Option (Iterator a);
    get_tail = |iter| iter.advance.map(@1);

    // Intersperse an elemnt between elements of an iterator.
    // 
    // Example: 
    // ```
    // Iterator::from_array([1,2,3]).intersperse(0) == Iterator::from_array([1,0,2,0,3])
    // ```
    intersperse : a -> Iterator a -> Iterator a;
    intersperse = |sep, iter| (
        let next = |_| (
            if iter.is_empty { Option::none() };
            let (e, tail) = iter.advance.as_some;
            if tail.is_empty { Option::some $ (e, Iterator::empty) };
            Option::some $ (e, Iterator::push_front(sep) $ tail.intersperse(sep))
        );
        Iterator { next : next }
    );

    // Check if the iterator is empty.
    is_empty : Iterator a -> Bool;
    is_empty = |iter| iter.advance.is_none;

    // Loop along an iterator. At each iteration step, you can choose to continue or to break.
    loop_iter : b -> (b -> a -> LoopResult b b) -> Iterator a -> b;
    loop_iter = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none { break $ accum };
            let (next, iter) = next.as_some;
            let loop_res = op(accum, next);
            if loop_res.is_break { break $ loop_res.as_break };
            continue $ (loop_res.as_continue, iter)
        )
    );

    // Loop by monadic action along an iterator. At each iteration step, you can choose to continue or to break.
    loop_iter_m : [m : Monad] b -> (b -> a -> m (LoopResult b b)) -> Iterator a -> m b;
    loop_iter_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let loop_res = *op(accum, next);
            if loop_res.is_break { break_m $ loop_res.as_break };
            continue_m $ (loop_res.as_continue, iter)
        )
    );

    // Generates the cartesian product of two iterators.
    // 
    // Example: `[1, 2, 3].to_iter.product(['a', 'b'].to_iter).to_array == [(1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b')]`
    product : Iterator a -> Iterator b -> Iterator (b, a);
    product = |as, bs| as.map(|a| bs.map(|b| (b, a)))._flatten;

    // Pushes an element to an iterator.
    push_front : a -> Iterator a -> Iterator a;
    push_front = |elem, iter| Iterator { next: |_| some $ (elem, iter) };

    // Creates a range iterator, i.e. an iterator of the form `[a, a+1, a+2, ..., b-1]`.
    range : I64 -> I64 -> Iterator I64;
    range = |a, b| (
        Iterator { next: |_| (
            if a == b {
                Option::none()
            } else {
                Option::some $ (a, Iterator::range(a+1, b))
            }
        ) }
    );

    // Reverses an iterator.
    reverse : Iterator a -> Iterator a;
    reverse = |iter| (
        loop((Iterator::empty, iter), |(out_iter, in_iter)|(
            if in_iter.is_empty {
                break $ out_iter
            } else {
                let (elem, in_iter) = in_iter.advance.as_some;
                let out_iter = out_iter.push_front(elem);
                continue $ (out_iter, in_iter)
            }
        ))
    );

    // Generates all subsequences of an iterator.
    // 
    // `[1,2,3].to_iter.subsequences` is `[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]].to_iter.map(to_iter)`.
    subsequences : Iterator a -> Iterator (Iterator a);
    subsequences = |iter| (
        if iter.is_empty { pure $ Iterator::empty };
        let (head, iter) = iter.advance.as_some;
        let subs = iter.subsequences;
        subs.append(subs.map(push_front(head)))
    );

    // Calculates the sum of elements of an iterator.
    sum : [a : Additive] Iterator a -> a;
    sum = fold(Zero::zero, Add::add);

    // Takes at most n elements from an iterator.
    take : I64 -> Iterator a -> Iterator a;
    take = |n, iter| (
        let next = |_| (
            if n == 0 { none() };
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            some $ (v, iter.take(n-1))
        );
        Iterator { next: next }
    );

    // Takes elements of an iterator while a condition is satisfied.
    // TODO: add test
    take_while : (a -> Bool) -> Iterator a -> Iterator a;
    take_while = |cond, iter| (
        let next = |_| (
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            if !cond(v) { none() };
            some $ (v, iter.take_while(cond))
        );
        Iterator { next: next }        
    );

    // Converts an iterator to an array.
    to_array : Iterator a -> Array a;
    to_array = Array::from_iter;

    // Zips two iterators.
    zip : Iterator b -> Iterator a -> Iterator (a, b);
    zip = |iter0, iter1| (
        let next = |_| (
            let iter0_next = iter0.advance;
            if iter0_next.is_none { none() };
            let iter1_next = iter1.advance;
            if iter1_next.is_none { none() };
            let (v0, iter0) = iter0_next.as_some;
            let (v1, iter1) = iter1_next.as_some;
            some $ ((v1, v0), zip(iter0, iter1))
        );
        Iterator { next: next }
    );
}

impl Iterator a : Add {
    add = |lhs, rhs| lhs.append(rhs);
}

impl [a : Eq] Iterator a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_empty { rhs.is_empty };
        if rhs.is_empty { false };
        let (e, lhs) = lhs.advance.as_some;
        let (f, rhs) = rhs.advance.as_some;
        if e != f { false };
        lhs == rhs
    );
}

impl Iterator : Functor {
    map = |f, a_iter| (
        let next = |_| (
            a_iter.advance.map(
                |(a_val, a_iter)| (f(a_val), a_iter.map(f))
            )
        );
        Iterator { next: next }
    );
}

impl Iterator : Monad {
    pure = |e| Iterator::empty.push_front(e);
    bind = |f, xs| xs.map(f)._flatten;
}

// The type of lazily generated values.
//
// You can create a lazy value by `|_| (...an expression to generate the value...)`, 
// and you can evaluate a lazy value `v` by `v()`.
type Lazy a = () -> a;

namespace LoopResult {

    // Make a break value wrapped in a monad.
    // 
    // This is used with `loop_m` function.
    break_m : [m : Monad] r -> m (LoopResult s r);
    break_m = break >> pure;

    // Make a continue value wrapped in a monad.
    // 
    // This is used with `loop_m` function.
    continue_m : [m : Monad] s -> m (LoopResult s r);
    continue_m = continue >> pure;

}

type Option a = union { none: (), some: a };

namespace Option {

    // Unwrap an option value if it is `some`, or returns given default value if it is `none`.
    as_some_or : a -> Option a -> a;
    as_some_or = |def, opt| (
        if opt.is_none { def } else { opt.as_some }
    );

    // Returns the provided default value if the option is none, or applies a function to the contained value if the option is some.
    map_or : b -> (a -> b) -> Option a -> b;
    map_or = |def, f, opt| if opt.is_some { f(opt.as_some) } else { def };
}

impl [a : Eq] Option a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_some && rhs.is_some { lhs.as_some == rhs.as_some };
        lhs.is_none && rhs.is_none
    );
}

impl [a : ToString] Option a : ToString {
    to_string = |opt| if opt.is_some { "some(" + opt.as_some.to_string + ")" } else { "none()" };
}

impl Option : Functor {
    map = |f, opt| (
        if opt.is_none {
            Option::none()
        } else {
            Option::some $ f $ opt.as_some
        }
    );
}

impl Option : Monad {
    pure = Option::some;
    bind = |f, opt| if opt.is_none { Option::none() } else { f(opt.as_some) };
}

// The type for file path.
// 
// TODO: give better implementation.
type Path = unbox struct { _data: String };

namespace Path {

    // Parse a string.
    parse : String -> Option Path;
    parse = |s| Option::some $ Path { _data: s };

}

impl Path : ToString {
    to_string = @_data;
}

// The type of punched arrays. 
// 
// A punched array is an array from which a certain element has been removed.
// This is used in the implementation of `Array::act`.
type PunchedArray a = unbox struct { _arr : Array a, idx : I64 };

namespace PunchedArray {

    // Plug in an element to a punched array to get back an array.
    plug_in : a -> PunchedArray a -> Array a;
    plug_in = |elm, parr| (
        let PunchedArray { _arr : arr, idx : idx } = parr;
        let size = arr.get_size + 1;

        // Increment the size.
        let arr = arr._unsafe_force_unique._unsafe_set_size(size);

        // Move the element at the `idx` to the last.
        let arr = if idx == size - 1 { arr } else {
            let (arr, last) = arr._unsafe_get_linear(idx);
            arr._unsafe_set(size - 1, last)
        };

        // Insert the element.
        arr._unsafe_set(idx, elm)
    );

    // Creates a punched array by moving out the element at the specified index.
    // 
    // NOTE: this function assumes that the given array is unique WITHOUT CHECKING.
    // The uniqueness of the array is ensured in the `Array::act` function.
    unsafe_punch : I64 -> Array a -> (PunchedArray a, a);
    unsafe_punch = |idx, arr| (
        // Bounds check.
        let size = arr.get_size;
        if !(0 <= idx && idx < size) { undefined("[PunchedArray::punch] Index out of range.") };

        // Decrement the size.
        let (arr, elm) = arr._unsafe_set_size(size - 1)._unsafe_get_linear(idx);

        // Move the last element to the punched index.
        let arr = if idx == size - 1 {
            arr
        } else {
            let (arr, last) = arr._unsafe_get_linear(size-1);
            arr._unsafe_set(idx, last)
        };

        let parr = PunchedArray { _arr : arr, idx : idx };
        (parr, elm)
    );
}

// A type of result value for a computation that may fail.
type Result e o = unbox union { ok : o, err: e };

namespace Result {

    // Returns the containing value if the value is ok, or otherwise aborts the program.
    unwrap : Result e o -> o;
    unwrap = |res| (
        if res.is_err {
            undefined("[Std::Result::unwrap] Try to unwrap an error value.")
        } else {
            res.as_ok
        }
    );
}

impl [e : Eq, a : Eq] Result e a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_ok && rhs.is_ok { lhs.as_ok == rhs.as_ok };
        if lhs.is_err && rhs.is_err { lhs.as_err == rhs.as_err };
        false
    );
}

impl Result e : Functor {
    map = |f, res| (
        if res.is_err {
            Result::err $ res.as_err
        } else {
            Result::ok $ f $ res.as_ok
        }
    );
}

impl Result e : Monad {
    pure = Result::ok;
    bind = |f, res| if res.is_err { Result::err $ res.as_err } else { f(res.as_ok) };
}

impl [e : ToString, a : ToString] Result e a : ToString {
    to_string = |res| if res.is_ok { "ok(" + res.as_ok.to_string + ")" } else { "err(" + res.as_err.to_string + ")" };
}

type String = unbox struct { _data : Array U8 };

namespace String {

    // Get the null-terminated C string.
    // 
    // Note that in case the string is not used after call of this function, the returned pointer will be already released.
    _get_c_str : String -> Ptr;
    _get_c_str = |s| s.@_data._get_boxed_ptr;

    // Create a string from C string (i.e., null-terminated byte array).
    // 
    // If the byte array doesn't include `\0`, this function causes undefined behavior.
    _unsafe_from_c_str : Array U8 -> String;
    _unsafe_from_c_str = |buf| (
        // Return length.
        let len = buf.borrow_boxed(|ptr| FFI_CALL[I64 strlen(Ptr), ptr]);
        let buf = buf._unsafe_set_size(len + 1);
        String { _data : buf }
    );

    // Create a `String` from a pointer to null-terminated C string.
    // 
    // If `ptr` is not pointing to a valid null-terminated C string, this function cause undefined behavior.
    _unsafe_from_c_str_ptr : Ptr -> String;
    _unsafe_from_c_str_ptr = |ptr| (
        let len = FFI_CALL[I64 strlen(Ptr), ptr];
        let buf_len = len + 1;
        let buf = Array::empty(buf_len)._unsafe_set_size(buf_len);
        let (buf, _) = buf.mutate_boxed(|buf_ptr| FFI_CALL_IO[Ptr memcpy(Ptr, Ptr, I64), buf_ptr, ptr, buf_len]);
        String { _data : buf }
    );

    // Call a function with a null-terminated C string.
    borrow_c_str : (Ptr -> a) -> String -> a;
    borrow_c_str = |f, str| str.@_data.borrow_boxed(f);

    // Call an IO action with a null-terminated C string.
    borrow_c_str_io : (Ptr -> IO a) -> String -> IO a;
    borrow_c_str_io = |act, str| IO::from_runner $ |ios| (
        str.borrow_c_str(|c_str| (act(c_str).@runner)(ios))
    );

    // Concatenate two strings.
    // 
    // Note: Since `s1.concat(s2)` puts `s2` after `s1`, `concat(lhs, rhs)` puts `lhs` after `rhs`.
    concat : String -> String -> String;
    concat = |rhs, lhs| (
        // Remove null terminator from lhs and append rhs.
        String { _data : lhs.@_data.pop_back.append(rhs.@_data) }
    );

    // Concatenate an iterator of strings.
    concat_iter : Iterator String -> String;
    concat_iter = |iter| (
        let len = iter.map(get_size).fold(0, add);
        let data_len = len + 1; // Add space for null terminator.
        let data = "".@_data.reserve(data_len);
        let data = iter.fold(data, |data, str| data.pop_back.append(str.@_data));
        String { _data : data }
    );

    // Create an empty string, which is reserved for a length.
    empty : I64 -> String;
    empty = |n| String { _data : Array::empty(n+1).push_back(0_U8) };

    // `str.find(token, start_idx)` finds the index where `token` firstly appears in `str`, starting from `start_idx`.
    // 
    // Note that this function basically returns a number less than or equal to `start_idx`, but there is an exception:
    // `str.find("", start_idx)` with `start_idx >= str.get_size` returns `str.get_size`, not `start_idx`.
    find : String -> I64 -> String -> Option I64;
    find = |tok, start, str| (
        str.borrow_c_str(|c_str|
            let start = min(start, str.get_size);
            let pos = tok.borrow_c_str(|tok_c_str| FFI_CALL[Ptr strstr(Ptr, Ptr), c_str.add_offset(start), tok_c_str]);
            if pos == nullptr {
                Option::none()
            };
            let pos = pos.subtract_ptr(c_str);
            Option::some(pos)
        )
    );

    // Gets the byte array of a string, containing null-terminator.
    get_bytes : String -> Array U8;
    get_bytes = @_data;

    // Gets the first byte of a string. Returns none if the string is empty.
    get_first_byte : String -> Option U8;
    get_first_byte = |s| (
        if s.is_empty { Option::none() };
        Option::some $ s.@_data.@(0)
    );

    // Gets the last byte of a string. Returns none if the string is empty.
    get_last_byte : String -> Option U8;
    get_last_byte = |s| (
        let len = s.get_size;
        if len == 0 { Option::none() };
        Option::some $ s.@_data.@(len - 1)
    );

    // Gets the length of a string.
    get_size : String -> I64;
    get_size = |s| s.@_data.get_size - 1; // exclude null terminator

    // `String` version of `Array::get_sub`.
    get_sub : I64 -> I64 -> String -> String;
    get_sub = |s, e, str| (
        let len = str.get_size;
        String::_unsafe_from_c_str $ str.get_bytes._get_sub_size_with_length_and_additional_capacity(len, 1, s, e).push_back('\0')
    );

    // Returns if the string is empty or not.
    is_empty : String -> Bool;
    is_empty = |s| s.get_size == 0;

    // Joins strings by a separator.
    join : String -> Iterator String -> String;
    join = |sep, strs| (
        strs.intersperse(sep).concat_iter
    );

    // Removes the last byte.
    // 
    // If the string is empty, this function does nothing.
    pop_back_byte : String -> String;
    pop_back_byte = |s| (
        if s.is_empty { s };
        s.mod__data(|bytes| bytes.pop_back.pop_back.push_back(0_U8))
    );

    // `str.split(sep)` splits `str` by `sep` into an iterator.
    // 
    // - If `sep` is empty, this function returns an infinite sequence of ""s.
    // - If `sep` is non-empty and `str` is empty, this function returns an iterator with a single element "".
    split : String -> String -> Iterator String;
    split = |sep, str| (
        let n = str.get_size;
        let m = sep.get_size;
        generate(0, |idx| (
            if idx == -1 { Option::none() };
            if idx == n { Option::some $ ("", -1) };
            let opt_idx = str.find(sep, idx);
            if opt_idx.is_none { Option::some $ (str.get_sub(idx, n), -1) };
            let idx2 = opt_idx.as_some;
            Option::some $ (str.get_sub(idx, idx2), idx2 + m)
        ))
    );

    // Removes the first byte of a string while it satisifies the specified condition.
    strip_first_bytes : (U8 -> Bool) -> String -> String;
    strip_first_bytes = |cond, str| (
        let len = str.get_size;
        let bytes = str.get_bytes;
        let n = loop(0, |i| (
            if i == len { break $ i };
            if !cond(bytes.@(i)) { break $ i };
            continue $ i + 1
        ));
        str.get_sub(n, len)
    );

    // Removes leading whitespace characters.
    strip_first_spaces : String -> String;
    strip_first_spaces = strip_first_bytes(|c| FFI_CALL[I32 isspace(I32), c.to_I32] > 0_I32);

    // Removes the last byte of a string while it satisifies the specified condition.
    strip_last_bytes : (U8 -> Bool) -> String -> String;
    strip_last_bytes = |cond, s| (
        loop(s, |s|
            if s.is_empty { break $ s };
            if cond(s.get_last_byte.as_some) { 
                continue $ s.pop_back_byte
            } else {
                break $ s
            }
        )
    );

    // Removes newlines and carriage returns at the end of the string.
    strip_last_newlines : String -> String;
    strip_last_newlines = strip_last_bytes(|c| c == '\n' || c == '\r');

    // Removes trailing whitespace characters.
    strip_last_spaces : String -> String;
    strip_last_spaces = strip_last_bytes(|c| FFI_CALL[I32 isspace(I32), c.to_I32] > 0_I32);

    // Strips leading and trailing whitespace characters.
    strip_spaces : String -> String;
    strip_spaces = |s| s.strip_last_spaces.strip_first_spaces;
}

// Concatenates two strings.
impl String : Add {
    add = |lhs, rhs| lhs.concat(rhs);
}

impl String : Eq {
    eq = |lhs, rhs| (lhs.@_data == rhs.@_data);
}

impl String : LessThan {
    less_than = |lhs, rhs| lhs.@_data < rhs.@_data;
}

impl String : LessThanOrEq {
    less_than_or_eq = |lhs, rhs| lhs.@_data <= rhs.@_data;
}

impl String : ToString {
    to_string = |s| s;
}

impl () : Eq {
    eq = |_, _| true;
}

// Functions

// Composes two functions. Composition operators `<<` and `>>` is translated to use of `compose`. 
compose : (a -> b) -> (b -> c) -> a -> c;
compose = |f, g, a| g(f(a));

// Monadic loop function. This is similar to `loop` but can be used to perform monadic action at each loop.
// 
// It is convenient to use `continue_m` and `break_m` to create monadic loop body function.
// 
// The following program prints "Hello World! (i)" for i = 0, 1, 2.
// 
// ```
// module Main;
// 
// main : IO ();
// main = (
//     loop_m(0, |i| (
//         if i == 3 { break_m $ () };
//         println("Hello World! (" + i.to_string + ")");;
//         continue_m $ i + 1
//     ))
// );
// ```
loop_m : [m : Monad] s -> (s -> m (LoopResult s r)) -> m r;
loop_m = |s, f| (
    let res = *f(s);
    if res.is_break { pure $ res.as_break };
    loop_m(res.as_continue, f)
);

// Constants

namespace I8 {
    maximum : I8;
    maximum = 127_I8;

    minimum : I8;
    minimum = -128_I8;
}
impl I8 : Zero {
    zero = 0_I8;
}

namespace U8 {
    maximum : U8;
    maximum = 255_U8;

    minimum : U8;
    minimum = 0_U8;
}
impl U8 : Zero {
    zero = 0_U8;
}

namespace I16 {
    maximum : I16;
    maximum = 32767_I16;

    minimum : I16;
    minimum = -32768_I16;
}
impl I16 : Zero {
    zero = 0_I16;
}

namespace U16 {
    maximum : U16;
    maximum = 65535_U16;

    minimum : U16;
    minimum = 0_U16;
}
impl U16 : Zero {
    zero = 0_U16;
}

namespace I32 {
    maximum : I32;
    maximum = 2147483647_I32;

    minimum : I32;
    minimum = -2147483648_I32;
}
impl I32 : Zero {
    zero = 0_I32;
}

namespace U32 {
    maximum : U32;
    maximum = 4294967295_U32;

    minimum : U32;
    minimum = 0_U32;
}
impl U32 : Zero {
    zero = 0_U32;
}

namespace I64 {
    maximum : I64;
    maximum = 9223372036854775807;

    minimum : I64;
    minimum = -9223372036854775808;
}
impl I64 : Zero {
    zero = 0_I64;
}

namespace U64 {
    maximum : U64;
    maximum = 18446744073709551615_U64;

    minimum : U64;
    minimum = 0_U64;
}
impl U64 : Zero {
    zero = 0_U64;
}

impl F32 : Zero {
    zero = 0.0_F32;
}

impl F64 : Zero {
    zero = 0.0_F64;
}

// Traits

// Trait for prefix operator `-`.
trait a : Neg {
    // Negates a value. An expression `-x` is translated to `neg(x)`.
    neg : a -> a;
}

// Trait for prefix operator `!`.
trait a : Not {
    // Logical NOT of a value. An expression `!x` is translated to `not(x)`.
    not : a -> a;
}

// Trait for infix operator `==`.
trait a : Eq {
    // Checks equality of two values. An expression `x == y` is translated to `eq(x, y)`.
    eq : a -> a -> Bool;
}

// Trait for infix operator `<`.
trait a : LessThan {
    // Compares two values. An expression `x < y` is translated to `less_than(x, y)`.
    less_than : a -> a -> Bool;
}

// Trait for infix operator `<=`.
trait a : LessThanOrEq {
    // Compares two values. An expression `x <= y` is translated to `less_than_or_eq(x, y)`.
    less_than_or_eq : a -> a -> Bool;
}

// Trait for infix operator `+`.
trait a : Add {
    // Adds two values. An expression `x + y` is translated to `add(x, y)`.
    add : a -> a -> a;
}

// Trait for infix operator `-`.
trait a : Sub {
    // Subtracts a value from another value. An expression `x - y` is translated to `sub(x, y)`.
    sub : a -> a -> a;
}

// Trait for infix operator `*`.
trait a : Mul {
    // Multiplies a value by another value. An expression `x * y` is translated to `mul(x, y)`.
    mul : a -> a -> a;
}

// Trait for infix operator `/`.
trait a : Div {
    // Divides a value by another value. An expression `x / y` is translated to `div(x, y)`.
    div : a -> a -> a;
}

// Trait for infix operator `%`.
trait a : Rem {
    // Calculate remainder of a value dividing another value. An expression `x % y` is translated to `rem(x, y)`.
    rem : a -> a -> a;
}

trait Additive = Add + Zero;

trait a : FromBytes {
    from_bytes : Array U8 -> Result ErrMsg a;
}

trait a : FromString {
    from_string : String -> Result ErrMsg a;
}

trait [f : *->*] f : Functor {
    map : (a -> b) -> f a -> f b;
}

namespace Functor {
    forget : [f : Functor] f a -> f ();
    forget = map(|_|());
}

namespace LessThan {
    max : [a : LessThan] a -> a -> a;
    max = |x, y| if x < y { y } else { x };

    min : [a : LessThan] a -> a -> a;
    min = |x, y| if x < y { x } else { y };
}

trait [m : *->*] m : Monad {
    bind : (a -> m b) -> m a -> m b;
    pure : a -> m a;
}

namespace Monad {
    // Flattens a nested monadic action.
    flatten : [m : Monad] m (m a) -> m a;
    flatten = Monad::bind(|x|x);

    // `unless(cond, act)` where `act` is a monadic value which returns `()` perfoms `act` only when `cond` is false.
    unless : [m : Monad] Bool -> m () -> m ();
    unless = |cond, act| if cond { pure $ () } else { act };

    // `when(cond, act)` where `act` is a monadic value which returns `()` perfoms `act` only when `cond` is true.
    when : [m : Monad] Bool -> m () -> m ();
    when = |cond, act| if cond { act } else { pure $ () };
}

trait a : ToBytes {
    to_bytes : a -> Array U8;
}

trait a : ToString {
    to_string : a -> String;
}

trait a : Zero {
    zero : a;
}

// Abs

namespace I8 {
    abs : I8 -> I8;
    abs = |f| if f < 0_I8 { -f } else { f };
}

namespace I16 {
    abs : I16 -> I16;
    abs = |f| if f < 0_I16 { -f } else { f };
}

namespace I32 {
    abs : I32 -> I32;
    abs = |f| if f < 0_I32 { -f } else { f };
}

namespace I64 {
    abs : I64 -> I64;
    abs = |f| if f < 0 { -f } else { f };
}

namespace F32 {
    abs : F32 -> F32;
    abs = |f| if f < 0.0_F32 { -f } else { f };
}

namespace F64 {
    abs : F64 -> F64;
    abs = |f| if f < 0.0 { -f } else { f };
}

namespace Ptr {
    // Adds an offset to a pointer.
    add_offset : I64 -> Ptr -> Ptr;
    add_offset = |off, ptr| FFI_CALL[Ptr fixruntime_ptr_add_offset(Ptr, I64), ptr, off];

    // Subtracts two pointers.
    // 
    // Note that `x.subtract_ptr(y)` calculates `x - y`, so `subtract_ptr(x, y)` calculates `y - x`.
    subtract_ptr : Ptr -> Ptr -> I64;
    subtract_ptr = |rhs, lhs| FFI_CALL[I64 fixruntime_subtract_ptr(Ptr, Ptr), lhs, rhs];
}

impl Ptr : ToString {
    to_string = |v| (
        let data = Array::empty(17);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_ptr_to_str(Ptr, Ptr), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U8 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(1)._unsafe_set_size(1);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u8_to_bytes(Ptr, U8), ptr, v]);
        data
    );
}
impl U8 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 1 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U8."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[U8 fixruntime_u8_from_bytes(Ptr), ptr])
    );
}
impl U8 : ToString {
    to_string = |v| (
        let data = Array::empty(4); // len(255) + 1
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u8_to_str(Ptr, U8), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U8 : FromString {
    from_string = |str| str.from_string.map(U64::to_U8);
}

impl U16 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(2)._unsafe_set_size(2);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u16_to_bytes(Ptr, U16), ptr, v]);
        data
    );
}
impl U16 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 2 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U16."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[U16 fixruntime_u16_from_bytes(Ptr), ptr])
    );
}
impl U16 : ToString {
    to_string = |v| (
        let data = Array::empty(6); // len(65535) + 1
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u16_to_str(Ptr, U16), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U16 : FromString {
    from_string = |str| str.from_string.map(U64::to_U16);
}

impl U32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u32_to_bytes(Ptr, U32), ptr, v]);
        data
    );
}
impl U32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U32."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[U32 fixruntime_u32_from_bytes(Ptr), ptr])
    );
}
impl U32 : ToString {
    to_string = |v| (
        let data = Array::empty(11);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u32_to_str(Ptr, U32), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U32 : FromString {
    from_string = |str| str.from_string.map(U64::to_U32);
}

impl U64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u64_to_bytes(Ptr, U64), ptr, v]);
        data
    );
}
impl U64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U64."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[U64 fixruntime_u64_from_bytes(Ptr), ptr])
    );
}
impl U64 : ToString {
    to_string = |v| (
        let data = Array::empty(21);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u64_to_str(Ptr, U64), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = FFI_CALL[U64 fixruntime_strtoull_10(Ptr), c_str];
            let err = FFI_CALL[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (invalid format): " + str) };
            let err = FFI_CALL[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl I8 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(1)._unsafe_set_size(1);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u8_to_bytes(Ptr, I8), ptr, v]);
        data
    );
}
impl I8 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 1 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I8."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[I8 fixruntime_u8_from_bytes(Ptr), ptr])
    );
}
impl I8 : ToString {
    to_string = |v| (
        let data = Array::empty(5); // len(-128) + 1
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_i8_to_str(Ptr, I8), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl I8 : FromString {
    from_string = |str| str.from_string.map(I64::to_I8);
}

impl I16 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(2)._unsafe_set_size(2);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u16_to_bytes(Ptr, I16), ptr, v]);
        data
    );
}
impl I16 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 2 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I16."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[I16 fixruntime_u16_from_bytes(Ptr), ptr])
    );
}
impl I16 : ToString {
    to_string = |v| (
        let data = Array::empty(7); // len(-32768) + 1
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_i16_to_str(Ptr, I16), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl I16 : FromString {
    from_string = |str| str.from_string.map(I64::to_I16);
}

impl I32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u32_to_bytes(Ptr, I32), ptr, v]);
        data
    );
}
impl I32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I32."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[I32 fixruntime_u32_from_bytes(Ptr), ptr])
    );
}
impl I32 : ToString {
    to_string = |v| (
        let data = Array::empty(12);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_i32_to_str(Ptr, I32), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl I32 : FromString {
    from_string = |str| str.from_string.map(I64::to_I32);
}

impl I64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u64_to_bytes(Ptr, I64), ptr, v]);
        data
    );
}
impl I64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I64."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[I64 fixruntime_u64_from_bytes(Ptr), ptr])
    );
}
impl I64 : ToString {
    to_string = |v| (
        let data = Array::empty(21);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_i64_to_str(Ptr, I64), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl I64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = FFI_CALL[I64 fixruntime_strtoll_10(Ptr), c_str];
            let err = FFI_CALL[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (invalid format): " + str) };
            let err = FFI_CALL[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl F32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_bytes(Ptr, F32), ptr, v]);
        data
    );
}
impl F32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as F32."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[F32 fixruntime_f32_from_bytes(Ptr), ptr])
    );
}
impl F32 : ToString {
    to_string = |v| (
        let data = Array::empty(50);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_str(Ptr, F32), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
namespace F32 {
    // Converts a floating number to a string of exponential form.
    to_string_exp : F32 -> String;
    to_string_exp = |v| (
        let data = Array::empty(50);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_str_exp(Ptr, F32), ptr, v]);
        String::_unsafe_from_c_str(data)
    );

    // Converts a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).
    to_string_exp_precision : U8 -> F32 -> String;
    to_string_exp_precision = |prec, v| (
        let data = Array::empty(50 + prec.to_I64);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_str_exp_precision(Ptr, F32, U8), ptr, v, prec]);
        String::_unsafe_from_c_str(data)
    );

    // Converts a floating number to a string with specified precision (i.e., number of digits after the decimal point).
    to_string_precision : U8 -> F32 -> String;
    to_string_precision = |prec, v| (
        let data = Array::empty(50 + prec.to_I64);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_str_precision(Ptr, F32, U8), ptr, v, prec]);
        String::_unsafe_from_c_str(data)
    );
}
impl F32 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = FFI_CALL[F32 fixruntime_strtof(Ptr), c_str];
            let err = FFI_CALL[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to number (invalid format): " + str) };
            let err = FFI_CALL[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to number (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl F64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_bytes(Ptr, F64), ptr, v]);
        data
    );
}
impl F64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as F64."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[F64 fixruntime_f64_from_bytes(Ptr), ptr])
    );
}
impl F64 : ToString {
    to_string = |v| (
        let data = Array::empty(500);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_str(Ptr, F64), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
namespace F64 {
    // Converts a floating number to a string of exponential form.
    to_string_exp : F64 -> String;
    to_string_exp = |v| (
        let data = Array::empty(500);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_str_exp(Ptr, F64), ptr, v]);
        String::_unsafe_from_c_str(data)
    );

    // Converts a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).
    to_string_exp_precision : U8 -> F64 -> String;
    to_string_exp_precision = |prec, v| (
        let data = Array::empty(500 + prec.to_I64);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_str_exp_precision(Ptr, F64, U8), ptr, v, prec]);
        String::_unsafe_from_c_str(data)
    );

    // Converts a floating number to a string with specified precision (i.e., number of digits after the decimal point).
    to_string_precision : U8 -> F64 -> String;
    to_string_precision = |prec, v| (
        let data = Array::empty(500 + prec.to_I64);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_str_precision(Ptr, F64, U8), ptr, v, prec]);
        String::_unsafe_from_c_str(data)
    );
}
impl F64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = FFI_CALL[F64 fixruntime_strtod(Ptr), c_str];
            let err = FFI_CALL[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to number (invalid format): " + str) };
            let err = FFI_CALL[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to number (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

// Returns "()".
impl () : ToString {
    to_string = |_| "()";
}

namespace Debug {

    // Asserts that a condition (boolean value) is true. 
    // 
    // If the assertion failed, prints a message to the stderr and aborts the program.
    assert : Lazy String -> Bool -> IO ();
    assert = |msg, b| IO::from_runner $ |state| (
        if b {
            (state, ())
        } else {
            undefined("Assertion failed!: " + msg())
        }
    );

    // Asserts that two values are equal.
    // 
    // If the assertion failed, prints a message to the stderr and aborts the program.
    assert_eq : [a: Eq] Lazy String -> a -> a -> IO ();
    assert_eq = |msg, lhs, rhs| assert(msg, lhs == rhs);

    // Asserts that the given value is unique, and returns the given value.
    // If the assertion failed, prints a message to the stderr and aborts the program.
    // 
    // The main use of this function is to check whether a boxed value given as an argument is unique.
    assert_unique : Lazy String -> a -> a;
    assert_unique = |msg, x| (
        let (unique, x) = x.unsafe_is_unique;
        if !unique { undefined("Value is not unique: " + msg()) };
        x
    );

    // Get clocks (cpu time) elapsed while executing an I/O action.
    consumed_time_while_io : IO a -> IO (a, F64);
    consumed_time_while_io = |io| (
        let s = *FFI_CALL_IO[I64 fixruntime_clock()];
        let r = *io;
        let t = *FFI_CALL_IO[I64 fixruntime_clock()];
        let t = FFI_CALL[F64 fixruntime_clocks_to_sec(I64), t - s];
        pure $ (r, t)
    );

    // Get clocks (cpu time) elapsed while evaluating a lazy value.
    // 
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    consumed_time_while_lazy : Lazy a -> (a, F64);
    consumed_time_while_lazy = |l| (
        let s = FFI_CALL[I64 fixruntime_clock()];
        let r = l();
        let t = FFI_CALL[I64 fixruntime_clock()];
        let t = FFI_CALL[F64 fixruntime_clocks_to_sec(I64), t - s];
        (r, t)
    );

    // Prints a string to stderr and flushes.
    // 
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    debug_eprint : String -> ();
    debug_eprint = |msg| _debug_print_to_stream(stderr, msg);

    // Prints a string followed by a newline to stderr and flushes.
    //
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    debug_eprintln : String -> ();
    debug_eprintln = |msg| debug_eprint(msg + "\n");

    // Prints a string to stdout and flushes.
    // 
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    debug_print : String -> ();
    debug_print = |msg| _debug_print_to_stream(stdout, msg);

    // Prints a string followed by a newline to stdout and flushes.
    //
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    debug_println : String -> ();
    debug_println = |msg| debug_print(msg + "\n");

    // Prints a string to the specified stream and flushes the stream.
    // 
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    _debug_print_to_stream : IOHandle -> String -> ();
    _debug_print_to_stream = |handle, msg| (
        msg.borrow_c_str_io(|str|
            let file_ptr = *handle.get_file_ptr;
            FFI_CALL_IO[I32 fputs(Ptr, Ptr), str, file_ptr];;
            FFI_CALL_IO[I32 fflush(Ptr), file_ptr];;
            pure()
        ).unsafe_perform
    );
}