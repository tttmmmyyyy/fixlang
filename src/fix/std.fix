module Std;

import Debug;

namespace Array {

    // A function like `get_sub`, but behaves as if the size of the array is the specified value, 
    // and has a parameter to specify additional capacity of the returned `Array`.
    _get_sub_size_asif : I64 -> I64 -> I64 -> I64 -> Array a -> Array a;
    _get_sub_size_asif = |len, additional_capacity, s, e, arr| (
        if len == 0 { arr };
        let s = (s % len + len) % len;
        let e = (e % len + len) % len;
        let n = if e >= s { e - s } else { e + len - s };
        let res = Array::empty(n + additional_capacity);
        loop((s, res), |(i, res)| (
            if i == e { break $ res };
            let res = res.push_back(arr.@(i));
            let i = i + 1;
            let i = if i >= len { 0 } else { i };
            continue $ (i, res)
        ))
    );

    // Sort elements in a range of a vector by "less than" comparator.
    // This function receives a working buffer as the first argument to reduce memory allocation, and returns it as second element.
    _sort_range_using_buffer : Array a -> I64 -> I64 -> ((a, a) -> Bool) -> Array a -> (Array a, Array a);
    _sort_range_using_buffer = |buffer, begin, end, less_than, vec| (
        // Merge sorting.
        let len = end - begin;
        if len <= 1 { (vec, buffer) };
        // Divide into intervals.
        let former_len = len / 2;
        let former_begin = begin;
        let former_end = begin + former_len;
        let latter_len = len - former_len;
        let latter_begin = former_end;
        let latter_end = end;
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, former_begin, former_end, less_than);
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, latter_begin, latter_end, less_than);
        // Merge former and latter to buffer.
        let buffer = buffer.truncate(0);
        let former_pos = former_begin;
        let latter_pos = latter_begin;
        let buffer = loop((former_pos, latter_pos, buffer), |(former_pos, latter_pos, buffer)|(
            if former_pos == former_end { // If former_pos reached to the end,
                if latter_pos == latter_end { break $ buffer };
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(vec.@(latter_pos));
                continue $ (former_pos, latter_pos + 1, buffer)
            };
            if latter_pos == latter_end { // If latter_pos reached to the end,
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(vec.@(former_pos));
                continue $ (former_pos + 1, latter_pos, buffer)
            };
            let former_elem = vec.@(former_pos);
            let latter_elem = vec.@(latter_pos);
            if less_than((former_elem, latter_elem)) {
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(former_elem);
                continue $ (former_pos + 1, latter_pos, buffer)
            } else {
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(latter_elem);
                continue $ (former_pos, latter_pos + 1, buffer)
            }
        ));
        // Copy buffer to vec.
        loop((0, vec), |(idx, vec)|(
            if idx == len { break $ (vec, buffer) };
            let vec = vec.set(begin + idx, buffer.@(idx));
            continue $ (idx + 1, vec)
        ))
    );

    // Functorial version of `Array::mod`, a.k.a. "lens" of `Array` in Haskell community.
    // This function can be defined for any functor `f` in general, but it is easier to understand the behavior when `f` is a monad: the monadic action `act(idx, fun, arr)` first performs `fun(arr.@(idx))` to get a value `elm`, and returns a pure value `arr.set(idx, elm)`. In short, this function modifies an array by a monadic action. 
    // This behavior can be implemented as `fun(arr.@(idx)).bind(|elm| pure $ arr.set(idx, elm))`. As we have identity `map(f) == bind(|x| pure $ f(x))` for `map` of a functor underlying a monad, it can be written as `fun(arr.@(idx)).map(|elm| arr.set(idx, elm))` and therefore this function requires `f` to be a functor, not a monad.
    // What is special about this function is that if you call `arr.act(idx, fun)` when both of `arr` and `arr.@(idx)` are unique, it is assured that `fun` receives the unique value.
    // If you call `act` on an array which is shared, this function clones the given array when inserting the result of your action into the array. This means that you don't need to pay cloning cost when your action failed, as expected.
    act : [f : Functor] I64 -> (a -> f a) -> Array a -> f (Array a);
    act = |idx, fun, arr| (
        let (unique, arr) = arr.unsafe_is_unique;
        if unique {
            let (parr, elm) = PunchedArray::unsafe_punch(idx, arr);
            fun(elm).map(|elm| parr.plug_in(elm))
        } else {
            fun(arr.@(idx)).map(|elm| arr.set(idx, elm))
        }
    );

    // Append an array to an array.
    // Note: Since `a1.append(a2)` puts `a2` after `a1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Array a -> Array a -> Array a;
    append = |v2, v1| (
        let v1_len = v1.get_size;
        let v2_len = v2.get_size;

        // Reserve v1's buffer and force uniqueness.        
        let len = v1_len + v2_len;
        let v1 = if v1.get_capacity < len {
            v1.reserve(max(len, 2 * v1.get_capacity))
        } else {
            v1.force_unique
        };
        
        // Set length.
        let v1 = v1._unsafe_set_size(len);

        // Copy elements of v2 to v1.
        loop((0, v1), |(idx, v1)|(
            if idx >= v2_len { break $ v1 };
            let v1 = v1._unsafe_set(v1_len + idx, v2.@(idx));
            continue $ (idx+1, v1)
        ))
    );

    // Call a function with a pointer to the memory region where elements are stored.
    borrow_ptr : (Ptr -> b) -> Array a -> b;
    borrow_ptr = |f, arr| (
        let res = f(arr._get_ptr);
        let _ = arr; // Use array after calling f
        res
    );

    // Find the first index at which the element satisfies a condition.
    find_by : (a -> Bool) -> Array a -> Option I64;
    find_by = |cond, arr| (
        let len = arr.get_size;
        loop(0, |idx| (
            if idx == len { break $ Option::none $ () };
            if cond(arr.@(idx)) { break $ Option::some $ idx };
            continue $ idx + 1
        ))
    );

    // Create an array from an iterator.
    from_iter : Iterator a -> Array a;
    from_iter = |iter| (
        let len = iter.get_size;
        let arr = Array::empty(len)._unsafe_set_size(len);
        iter.fold((arr, 0), |(arr, idx), elem| (
            let arr = arr._unsafe_set(idx, elem);
            (arr, idx+1)
        )).@0
    );

    // Creates an array by a mapping function.
    from_map : I64 -> (I64 -> a) -> Array a;
    from_map = |size, map| (
        let arr = Array::empty(size)._unsafe_set_size(size);
        loop((0, arr), |(idx, arr)|(
            if idx == size {
                break $ arr
            } else {
                let arr = arr._unsafe_set(idx, map(idx));
                continue $ (idx + 1, arr)
            }
        ))
    );

    // Get the first element of an array. Returns none if the array is empty.
    get_first : Array a -> Option a;
    get_first = |arr| (
        if arr.is_empty { Option::none() };
        Option::some $ arr.@(0)
    );

    // Get the last element of an array. Returns none if the array is empty.
    get_last : Array a -> Option a;
    get_last = |arr| (
        let len = arr.get_size;
        if len == 0 { Option::none() };
        Option::some $ arr.@(len - 1)
    );

    // `arr.get_sub(s, e)` returns an array `[ arr.@(i) | i ∈ [s, e) ]`, 
    // More precisely, let `N` denote the the size of the `arr`. 
    // Then `arr.get_sub(s, e)` returns `[ arr.@(s + i mod N) | i ∈ [0, n), n >= 0 is the minimum number such that s + n == e mod N ]`.
    get_sub : I64 -> I64 -> Array a -> Array a;
    get_sub = |s, e, arr| arr._get_sub_size_asif(arr.get_size, 0, s, e);

    // Returns if the array is empty
    is_empty : Array a -> Bool;
    is_empty = |arr| ( arr.get_size == 0 );

    // Pop an element at the back of an array.
    // If the array is empty, this function does nothing.
    pop_back : Array a -> Array a;
    pop_back = |arr| (
        let len = arr.get_size;
        if len == 0 { arr };
        let arr = arr.force_unique;
        let released_elem = arr._unsafe_get(len-1);
        arr._unsafe_set_size(len-1)
    );

    // Push an element to the back of an array.
    push_back : a -> Array a -> Array a;
    push_back = |e, arr| (
        let len = arr.get_size;
        let arr = if arr.get_capacity < len + 1 {
            arr.reserve(2*(len + 1))
        } else {
            arr
        };
        let arr = arr.force_unique._unsafe_set_size(len+1);
        arr._unsafe_set(len, e)
    );

    // Reserves the memory region for an array.
    // TODO: change to more optimized implementation.
    reserve : I64 -> Array a -> Array a;
    reserve = |cap, arr| (
        if cap <= arr.get_capacity { arr };
        let len = arr.get_size;
        let new = Array::empty(cap)._unsafe_set_size(len);
        loop((0, new), |(idx, new)|(
            if idx == len {
                break $ new
            } else {
                let new = new._unsafe_set(idx, arr.@(idx));
                continue $ (idx + 1, new)
            }
        ))
    );

    // Sort elements in a vector by "less than" comparator.
    sort_by : ((a, a) -> Bool) -> Array a -> Array a;
    sort_by = |less_than, vec| (
        let buffer = Array::empty(vec.get_size);
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, 0, vec.get_size, less_than);
        vec
    );

    // Convert an array to an iterator.
    to_iter : Array a -> Iterator a;
    to_iter = Iterator::from_array;

    // Truncate an array, keeping the given number of first elements.
    // `truncante(len, arr)` does nothing if `len >= arr.get_size`.
    truncate : I64 -> Array a -> Array a;
    truncate = |length, vec| (
        loop(vec, |vec|(
            if length >= vec.get_size { break $ vec };
            continue $ vec.pop_back
        ))
    );
}

impl [a : Eq] Array a : Eq {
    // Compare two vectors.
    eq = |lhs, rhs| (
        if lhs.get_size != rhs.get_size { false };
        let len = lhs.get_size;
        loop(0, |idx| (
            if idx == len { break $ true };
            if lhs.@(idx) != rhs.@(idx) { break $ false };
            continue $ idx + 1
        ))
    );
}

impl [a : Eq, a : LessThan] Array a : LessThan {
    less_than = |lhs, rhs| (
        loop(0, |i| (
            if i == lhs.get_size && i == rhs.get_size { break $ false };
            if i == lhs.get_size { break $ true };
            if i == rhs.get_size { break $ false };
            let l = lhs.@(i);
            let r = rhs.@(i);
            if l != r { break $ l < r };
            continue $ i + 1
        ))
    );
}

impl [a : Eq, a : LessThanOrEq] Array a : LessThanOrEq {
    less_than_or_eq = |lhs, rhs| (
        loop(0, |i| (
            if i == lhs.get_size && i == rhs.get_size { break $ true };
            if i == lhs.get_size { break $ true };
            if i == rhs.get_size { break $ false };
            let l = lhs.@(i);
            let r = rhs.@(i);
            if l != r { break $ l <= r };
            continue $ i + 1
        ))
    );
}

impl Array : Functor {
    map = |f, arr| (
        let n = arr.get_size;
        let res = Array::empty(n);
        loop((0, res), |(i, res)| (
            if i == n { break $ res };
            let e = f $ arr.@(i);
            continue $ (i+1, res.push_back(e))
        ))
    );
}

impl Array : Monad {
    pure = |e| [e];
    bind = |f, arr| (
        let size = arr.get_size;
        let arr_arr = Array::empty(size);
        let (arr_arr, count) = loop((0, arr_arr, 0), |(idx, arr_arr, count)| (
            if idx == size { break $ (arr_arr, count) };
            let inner = f $ arr.@(idx);
            let count = count + inner.get_size;
            let arr_arr = arr_arr.push_back(inner);
            continue $ (idx + 1, arr_arr, count)
        ));
        let ret = Array::empty(count);
        loop((0, ret), |(i, ret)| (
            if i == size { break $ ret };
            let inner = arr_arr.@(i);
            continue $ loop((0, ret), |(j, ret)|(
                if j == inner.get_size {
                    break $ (i + 1, ret)
                } else {
                    let ret = ret.push_back(inner.@(j));
                    continue $ (j + 1, ret)
                }
            ))
        ))
    );
}

impl [a : ToString] Array a : ToString {
    to_string = |arr| ("[" + arr.to_iter.map(to_string).join(", ") + "]");
}

impl Bool : ToString {
    to_string = |lhs| (
        if lhs { "true" } else { "false" }
    );
}

// Boxed wrapper for a type.
// This is nothing but
// ```
// type Boxed a = box struct { value : a };
// ```
// .
type Boxed a = box struct { value : a };

// A type (alias) for error message. 
type ErrMsg = String;

namespace FFI {
    // Borrow a pointer to the data of a boxed value.
    // For detail, see the document of `_unsafe_get_boxed_data_ptr`.
    unsafe_borrow_boxed_data_ptr : (Ptr -> b) -> a -> b;
    unsafe_borrow_boxed_data_ptr = |act, val| (
        let ptr = val._unsafe_get_boxed_data_ptr;
        let res = act(ptr);
        let _ = val; // Use val after calling act
        res
    );

    // Get errno which is set by C functions.
    unsafe_get_errno : () -> CInt;
    unsafe_get_errno = |_| CALL_C[CInt fixruntime_get_errno()];

    // Set errno to zero.
    unsafe_clear_errno : () -> ();
    unsafe_clear_errno = |_| CALL_C[() fixruntime_clear_errno()];

    // `Destructor a` is a boxed type which is containing a value of type `a` and a function `a -> ()` which is called destructor.
    // When a value of `Destructor a` is deallocated, the destructor function will be called on the contained value.
    // This type is useful to free a resouce allocated by a C function automatically when the resource is no longer needed in Fix code.
    // 
    // NOTE1: Accessing the contained value directly by the field accessor function is not recommended. Use `borrow` function to access the value.
    // NOTE2: If the contained value is captured by another Fix's object than `Destructor`, the contained value is still alive after the destructor function is called.
    type Destructor a = box struct { _value : a, dtor : a -> () };    

    namespace Destructor {
        // Borrow the contained value.
        // `borrow(worker, dtor)` calls `worker` on the contained value captured by `dtor`, and returns the value returned by `worker`.
        // It is guaranteed that the `dtor` is alive during the call of `worker`. 
        // In other words, the `worker` receives the contained value on which the destructor is not called yet.
        borrow : (a -> b) -> Destructor a -> b;
        borrow = |worker, dtor| (
            let res = worker(dtor.@_value);
            let _ = dtor; // Prolong lifetime of `dtor`.
            res
        );

        // Make a destructor value.
        make : a -> (a -> ()) -> Destructor a;
        make = |val, dtor| Destructor { _value : val, dtor : dtor };
    }
}

type IO a = unbox struct { _data : () -> a };

namespace IO {
    // Read characters from an IOHandle.
    // If the first argument `upto_newline` is true, this function reads a file upto newline or EOF.
    _read_line_inner : Bool -> IOHandle -> IOFail String;
    _read_line_inner = |upto_newline, handle| (
        IOFail { _data : IO { _data : |_| (
            let file_ptr = handle._file_ptr;
            if file_ptr == nullptr {
                Result::err("Std::IO::_read_line_inner failed!: the IOHandle is already closed.")
            };
            loop("", |str|
                let buf_size = 1024;
                let buf = Array::empty(buf_size);
                let fgets_res = CALL_C[Ptr fgets(Ptr, I32, Ptr), buf._get_ptr, buf_size.to_I32, file_ptr];
                if fgets_res == nullptr { 
                    let err = CALL_C[I32 ferror(Ptr), file_ptr];
                    if err != 0_I32 { 
                        let err = "Std::IO::_read_line_inner failed!: an error occurred in fgets.";
                        break $ Result::err(err)
                    } else {
                        break $ Result::ok(str)
                    }
                };
                let strlen = CALL_C[I64 strlen(Ptr), buf._get_ptr];
                let buf = buf._unsafe_set_size(strlen + 1);
                let read = String { _data : buf };
                let str = str + read;
                if upto_newline {
                    // If the last character is \n, break.
                    let last_byte = buf.@(strlen-1);
                    if last_byte == '\n' { break $ Result::ok(str) };
                    continue $ str
                } else {
                    continue $ str
                }
            )
        ) }}
    );

    // Perform the I/O action. This may violate purity of Fix.
    _unsafe_perform : IO a -> a;
    _unsafe_perform = |io| (io.@_data)();

    // Close a file.
    // Unlike C's `fclose`, closing an already closed `IOHandle` is safe and does nothing.
    close_file : IOHandle -> IO ();
    close_file = |handle| (
        IO { _data : |_| IOHandle::_unsafe_close(handle) }
    );

    // Print a string to stderr.
    eprint : String -> IO ();
    eprint = |str| (
        IO { _data : |_| (
            eval str.borrow_c_str(|c_ptr|
                let _ = CALL_C[I32 fputs(Ptr, Ptr), c_ptr, stderr._file_ptr];
                ()
            );
            ()
        )}
    );

    // Print a string followed by a newline to stderr.
    eprintln : String -> IO ();
    eprintln = |str| (
        eval *eprint(str);
        eval *eprint("\n");
        pure()
    );

    // Exit the program with an error code.
    exit : I64 -> IO a;
    exit = |code| IO { _data : |_| eval CALL_C[() exit(I32), code.to_I32]; abort() };

    // Exit the program with an error message and an error code.
    // The error message is written to the standard error output.
    exit_with_msg : I64 -> String -> IO a;
    exit_with_msg = |code, msg| eval *eprintln(msg); exit(code);

    // Create an IO action from a function.
    from_func : (() -> a) -> IO a;
    from_func = |func| IO { _data : func };

    // `get_arg(n)` returns the n-th (0-indexed) command line argument.
    // If n is greater than or equal to the number of command line arguments, this function returns none.
    get_arg : I64 -> IO (Option String);
    get_arg = |n| (
        let argc = *get_arg_count;
        if n >= argc { pure $ Option::none() };
        let arg_ptr = CALL_C[Ptr fixruntime_get_argv(I64), n];
        pure $ Option::some(String::_unsafe_from_c_str_ptr(arg_ptr))
    );

    // Get the number of command line arguments.
    get_arg_count : IO I64;
    get_arg_count = (
        eval *pure();
        let argc = CALL_C[I32 fixruntime_get_argc()].to_I64;
        pure $ argc
    );

    // Get command line arguments.
    get_args : IO (Array String);
    get_args = (
        let argc = *get_arg_count;
        let args = Array::empty(argc);
        loop_m((args, 0), |(args, idx)| (
            if idx == argc { break_m $ args };
            let arg = (*get_arg(idx)).as_some;
            continue_m $ (args.push_back(arg), idx + 1)
        ))
    );

    // Read a line from stdin. If some error occurr, this function aborts.
    // If you want to handle errors, use `read_line(stdin)` instead.
    input_line : IO String;
    input_line = (
        let res = *read_line(stdin).to_result;
        if res.is_ok {
            pure $ res.as_ok
        } else {
            eval *(eprintln $ res.as_err.to_string);
            pure $ abort()
        }
    );

    // Check if an `IOHandle` reached to the EOF.
    is_eof : IOHandle -> IO Bool;
    is_eof = |handle| (
        eval *pure();
        pure $ CALL_C[I32 feof(Ptr), handle._file_ptr] != 0_I32
    );

    // Loop on lines read from an `IOHandle`.
    // `loop_lines(handle, initial_state, worker)` calls `worker` on the pair of current state and a line string read from `handle`.
    // The function `worker` should return an updated state as `LoopResult` value, i.e., a value created by `continue` or `break`.
    // When the `handle` reaches to the EOF or `worker` returns a `break` value, `loop_lines` returns the last state value.
    // Note that the line string passed to `worker` may contain a newline code at the end. To remove it, use `String::strip_last_spaces`.
    loop_lines : IOHandle -> s -> (s -> String -> LoopResult s s) -> IOFail s;
    loop_lines = |handle, state, worker| (
        eval *pure();
        if is_eof(handle)._unsafe_perform {
            pure $ state
        };
        let line = read_line(handle).to_result._unsafe_perform;
        if line.is_err {
            IOFail::from_result(Result::err(line.as_err))
        };
        let line = line.as_ok;
        let res = worker(state, line);
        if res.is_break {
            pure $ res.as_break
        };
        let next_state = res.as_continue;
        loop_lines(handle, next_state, worker)
    );

    // Loop on lines read from an `IOHandle`.
    // Similar to `loop_lines`, but the worker function can perform an IO action.
    loop_lines_io : IOHandle -> s -> (s -> String -> IOFail (LoopResult s s)) -> IOFail s;
    loop_lines_io = |handle, state, worker| (
        eval *pure();
        if is_eof(handle)._unsafe_perform {
            pure $ state
        };
        let line = read_line(handle).to_result._unsafe_perform;
        if line.is_err {
            IOFail::from_result(Result::err(line.as_err))
        };
        let line = line.as_ok;
        let res = worker(state, line).to_result._unsafe_perform;
        if res.is_err {
            IOFail::from_result(Result::err(res.as_err))
        };
        let res = res.as_ok;
        if res.is_break {
            pure $ res.as_break
        };
        let next_state = res.as_continue;
        loop_lines_io(handle, next_state, worker)
    );

    // Open a file. The second argument is a mode string for `fopen` C function. 
    open_file : Path -> String -> IOFail IOHandle;
    open_file = |path, mode| (
        IOFail { _data  : IO { _data : |_|(
            let path_str = path.to_string;
            let res = path_str.borrow_c_str(|path_ptr|
                mode.borrow_c_str(|mode_str|
                    let file_ptr = CALL_C[Ptr fopen(Ptr, Ptr), path_ptr, mode_str];
                    if file_ptr == nullptr { 
                        Result::err $ "Failed to open a file: " + path_str
                    } else {
                        Result::ok $ IOHandle::from_file_ptr $ file_ptr
                    }
                )
            );
            res
        ) }}
    );

    // Print a string to stdout.
    print : String -> IO ();
    print = |str| (
        IO { _data : |_| (
            eval str.borrow_c_str(|c_ptr|
                let _ = CALL_C[I32 fputs(Ptr, Ptr), c_ptr, stdout._file_ptr];
                ()
            );
            ()
        )}
    );

    // Print a string followed by a newline to stdout.
    println : String -> IO ();
    println = |str| (
        eval *print(str);
        eval *print("\n");
        pure()
    );

    // Raad all characters from a file.
    read_file_string : Path -> IOFail String;
    read_file_string = |path| with_file(path, "r", read_string);

    // Read all bytes from a file.
    read_file_bytes : Path -> IOFail (Array U8);
    read_file_bytes = |path| with_file(path, "r", read_bytes);

    // Read characters from a IOHandle upto newline or EOF.
    // The returned string may include newline at its end.
    read_line : IOHandle -> IOFail String;
    read_line = _read_line_inner(true);

    // Read all bytes from an IOHandle.
    read_bytes : IOHandle -> IOFail (Array U8);
    read_bytes = |handle| (
        eval *pure();
        // Get Iterator of Arrays.
        let (iter, len) = *loop_m((Iterator::empty, 0), |(iter, len)| (
            let bytes = *read_n_bytes(handle, 1024);
            if bytes.is_empty {
                break_m $ (iter.reverse, len)
            } else {
                continue_m $ (iter.push_front(bytes), len + bytes.get_size)
            }
        ));
        // Concatenate bytes.
        let res = Array::empty(len);
        pure $ iter.fold(res, |res, bytes| res.append(bytes))
    );

    // Read at most n bytes [f]rom an IOHandle.
    read_n_bytes : IOHandle -> I64 -> IOFail (Array U8);
    read_n_bytes = |handle, n| (
        eval *pure();
        let buf = Array::empty(n);
        let len = buf.borrow_ptr(|ptr| (
            CALL_C[I64 fread(Ptr, I64, I64, Ptr), ptr, 1, n, handle._file_ptr]
        ));
        // Check error.
        let err = CALL_C[I32 ferror(Ptr), handle._file_ptr];
        if err != 0_I32 { 
            let err = "Std::IO::read_n_bytes failed!: some error occurred in fread.";
            IOFail::from_result $ Result::err(err)
        };
        let buf = buf._unsafe_set_size(len);
        IOFail::from_result $ Result::ok(buf)
    );

    // Read all characters from an IOHandle.
    read_string : IOHandle -> IOFail String;
    read_string = _read_line_inner(false);

    // The handle for standard error.
    stderr : IOHandle;
    stderr = (
        let ptr = "a".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 2_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // The handle for standard input.
    stdin : IOHandle;
    stdin = (
        let ptr = "r".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 0_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // The handle for standard output.
    stdout : IOHandle;
    stdout = (
        let ptr = "a".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 1_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // Perform a function with a file handle. The second argument is a mode string for `fopen` C function. 
    // The file handle will be closed automatically.
    with_file : Path -> String -> (IOHandle -> IOFail a) -> IOFail a;
    with_file = |path, mode, action| (
        let handle = *open_file(path, mode);
        let res = *action(handle);
        eval *IOFail::lift(close_file(handle));
        pure $ res
    );

    // Write a byte array into an IOHandle.
    write_bytes : IOHandle -> Array U8 -> IOFail ();
    write_bytes = |handle, array| (
        eval *pure();
        let res = array.borrow_ptr(|ptr| (
            let n = array.get_size;
            let res = CALL_C[I64 fwrite(Ptr, I64, I64, Ptr), ptr, 1, n, handle._file_ptr];
            if res < n { Result::err $ "Std::IO::write_bytes failed!: some error occurred in fwrite." };
            Result::ok()
        ));
        IOFail::from_result $ res
    );

    // Write a byte array into a file.
    write_file_bytes : Path -> Array U8 -> IOFail ();
    write_file_bytes = |path, content| with_file(path, "w", |handle| write_bytes(handle, content));

    // Write a string into a file.
    write_file_string : Path -> String -> IOFail ();
    write_file_string = |path, content| with_file(path, "w", |handle| write_string(handle, content));

    // Write a string into an IOHandle.
    write_string : IOHandle -> String -> IOFail ();
    write_string = |handle, content| (
        eval *pure();
        let res = content.borrow_c_str(|c_str| (
            let file_ptr = handle._file_ptr;
            let res = CALL_C[I32 fputs(Ptr, Ptr), c_str, handle._file_ptr];
            if res < 0_I32 { Result::err $ "Std::IO::write_string failed!: some error occurred in fputs." };
            Result::ok()
        ));
        IOFail::from_result $ res
    );
}

impl IO : Functor {
    map = |f, io| IO { _data : |_| f(io._unsafe_perform) };
}

impl IO : Monad {
    pure = |v| IO { _data : |_| v };
    bind = |f, io| (
        IO { _data : |_| (
            let a = io._unsafe_perform;
            f(a)._unsafe_perform
        )}
    );
}

namespace IO {
    // A handle type for read / write operations on files, stdin, stdout, stderr.
    // You can create `IOHandle` value by `IO::open_file`, and close it by `IO::close_file`. 
    // Also there are global `IO::IOHandle::stdin`, `IO::IOHandle::stdout`, `IO::IOHandle::stderr`.
    type IOHandle = unbox struct { _data : Destructor Ptr };
}

namespace IO::IOHandle {
    // Get pointer to C's `FILE` value from an `IOHandle`.
    // DO NOT call `fclose` on the pointer returned by this function.
    // To close an `IOHandle`, use `IO::close_file`.
    _file_ptr : IOHandle -> Ptr;
    _file_ptr = |handle| handle.@_data.borrow(|handle_ptr| 
        CALL_C[Ptr fixruntime_iohandle_get_file(Ptr), handle_ptr]
    );

    // Close an `IOHandle`. 
    // This is an I/O action not wrapped by `IO`; use `IO::close_file` in the usual case.
    _unsafe_close : IOHandle -> ();
    _unsafe_close = |handle| (
        eval handle.@_data.borrow(|handle_ptr| CALL_C[() fixruntime_iohandle_close(Ptr), handle_ptr]);
        ()
    );

    // Create an `IOHandle` from a file pointer (i.e., pointer to C's `FILE`).
    // DO NOT create two `IOHandle`s from a single file pointer.
    from_file_ptr : Ptr -> IOHandle;
    from_file_ptr = |file_ptr| (
        let handle_ptr = CALL_C[Ptr fixruntime_iohandle_create(Ptr), file_ptr];
        let dtor = |handle_ptr| CALL_C[() fixruntime_iohandle_delete(Ptr), handle_ptr];
        IOHandle { _data : Destructor::make(handle_ptr, dtor) }
    );
}

namespace IO {
    // The type for I/O actions which may fail.
    type IOFail a = unbox struct { _data : IO (Result ErrMsg a) };
}

namespace IO::IOFail {
    // Create an pure `IOFail` value from a `Result` value.
    from_result : Result ErrMsg a -> IOFail a;
    from_result = |res| IOFail { _data : pure(res) };

    // Lift an `IO` action to a successful `IOFail` action.
    lift : IO a -> IOFail a;
    lift = |io| IOFail { _data : io.map(pure) };

    // Create an error `IOFail` action.
    throw : ErrMsg -> IOFail a;
    throw = |e| from_result $ Result::err(e);

    // Convert an `IOFail` to an `Result` value (wrapped by `IO`).
    to_result : IOFail a -> IO (Result ErrMsg a);
    to_result = @_data;

    // Convert an `IOFail` value to an `IO` value by an error handler (i.e., a `catch`) function.
    try : (ErrMsg -> IO a) -> IOFail a -> IO a;
    try = |catch, iof| (
        let res = *iof.to_result;
        if res.is_ok { pure $ res.as_ok } else { catch(res.as_err) }
    );
}

impl IOFail : Functor {
    map = |f, iof| IOFail { _data : iof.@_data.map(map(f)) };
}

impl IOFail : Monad {
    pure = |v| IOFail { _data : pure(pure(v)) };
    bind = |f, iof| IOFail { _data : do {
        let res = *iof.@_data;
        if res.is_err { pure $ Result::err $ res.as_err };
        f(res.as_ok).@_data
    }};
}

// Iterator (a.k.a lazy list)
type Iterator a = unbox struct { next: () -> Option (a, Iterator a) };

namespace Iterator {

    // Flatten an iterator of iterators.
    // You should use `Monad::flatten` instead of this function.
    // This function is used in the implementation of `Monad::bind` for `Iterator`.
    _flatten : Iterator (Iterator a) -> Iterator a;
    _flatten = |iters| (
        let opt_iter = iters.advance;
        if opt_iter.is_none { Iterator::empty };
        let (iter, iters) = opt_iter.as_some;
        _flatten_sub(iter, iters)
    );

    _flatten_sub : Iterator a -> Iterator (Iterator a) -> Iterator a;
    _flatten_sub = |iter, iters| Iterator { next : |_| 
        let opt_elem = iter.advance;
        if opt_elem.is_none { iters._flatten.advance };
        let (elem, iter) = opt_elem.as_some;
        Option::some $ (elem, _flatten_sub(iter, iters))
    };

    // Get next value and next iterator.
    advance : Iterator a -> Option (a, Iterator a);
    advance = |iter| (iter.@next)();

    // Append an iterator to a iterator.
    // Note: Since `iter1.append(iter2)` puts `iter2` after `iter1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Iterator a -> Iterator a -> Iterator a;
    append = |rhs, lhs| (
        if lhs.is_empty { rhs };
        let next = |_| (
            lhs.advance.map(|(e, lhs)| (e, lhs.append(rhs)))
        );
        Iterator { next : next }
    );

    // Evaluate all elements of iterator.
    // TODO: add test
    bang : Iterator a -> Iterator a;
    bang = |iter| iter.to_array.to_iter;

    // Creates an iterator that counts up from a number.
    // count_up(n) = [n, n+1, n+2, ...]
    count_up : I64 -> Iterator I64;
    count_up = |i| (
        let next = |_| (
            some $ (i, Iterator::count_up(i+1))
        );
        Iterator { next: next }
    );

    // Create an empty iterator.
    empty : Iterator a;
    empty = (
        let next = |_| (none());
        Iterator { next: next }
    );

    // Filter elements by a condition function
    filter : (a -> Bool) -> Iterator a -> Iterator a;
    filter = |cond, iter| (
        let next = |_| (
            loop(iter, |iter| (
                let next = iter.advance;
                if next.is_none { break $ none() };
                let (v, iter) = next.as_some;
                if !cond(v) { continue $ iter };
                let iter = filter(cond, iter);
                break $ some((v, iter))
            ))
        );
        Iterator { next: next }
    );

    // Find the last element of an iterator.
    find_last : Iterator a -> Option a;
    find_last = |iter| (
        if iter.is_empty { none() };
        let (elem, iter) = iter.advance.as_some;
        if iter.is_empty { 
            some(elem)
        } else {
            iter.find_last
        }
    );

    // Folds iterator from left to right.
    // Example: `fold(init, op, [a0, a1, a2, ...]) = ...op(op(op(init, a0), a1), a2)...`
    fold : b -> (b -> a -> b) -> Iterator a -> b;
    fold = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none {
                break $ accum
            } else {
                let (next, iter) = next.as_some;
                continue $ (op(accum, next), iter)
            }
        )
    );

    // Folds iterator from left to right by monadic action.
    fold_m : [m : Monad] b -> (b -> a -> m b) -> Iterator a -> m b;
    fold_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)| (
            let next = iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let accum = *op(accum, next);
            continue_m $ (accum, iter)
        ))
    );

    // Create iterator from an array.
    from_array : Array a -> Iterator a;
    from_array = |arr| count_up(0).take(arr.get_size).map(|i| arr.@(i));

    // Creates iterator from mapping function.
    // from_map(f) = [f(0), f(1), f(2), ...]
    from_map : (I64 -> a) -> Iterator a;
    from_map = |f| count_up(0).map(f);

    // Generate an iterator from a state transition function.
    // - if `f(s)` is none, `generate(s, f)` is empty.
    // - if `f(s)` is some value `(e, s1)`, then `generate(s, f)` starts by `e` followed by `generate(s2, f)`.
    generate : s -> (s -> Option (a, s)) -> Iterator a;
    generate = |s, f| (
        let next = |_| f(s).map(|(e, s)| (e, Iterator::generate(s, f)));
        Iterator { next: next }
    );

    // Get the first element of an iterator. If the iterator is empty, this function returns `none`.
    // TODO: add test
    get_first : Iterator a -> Option a;
    get_first = |iter| iter.advance.map(@0);

    // Count the number of elements of an iterator.
    get_size : Iterator a -> I64;
    get_size = fold(0, |acm, _| acm + 1);

    // Remove the first element from an iterator. If the iterator is empty, this function returns `none`.
    // TODO: add test
    get_tail : Iterator a -> Option (Iterator a);
    get_tail = |iter| iter.advance.map(@1);

    // Intersperse an elemnt between elements of an iterator.
    // Example: 
    // ```
    // Iterator::from_array([1,2,3]).intersperse(0) == Iterator::from_array([1,0,2,0,3])
    // ```
    intersperse : a -> Iterator a -> Iterator a;
    intersperse = |sep, iter| (
        let next = |_| (
            if iter.is_empty { Option::none() };
            let (e, tail) = iter.advance.as_some;
            if tail.is_empty { Option::some $ (e, Iterator::empty) };
            Option::some $ (e, Iterator::push_front(sep) $ tail.intersperse(sep))
        );
        Iterator { next : next }
    );

    // Check if the iterator is empty.
    is_empty : Iterator a -> Bool;
    is_empty = |iter| iter.advance.is_none;

    // Loop along an iterator. At each iteration step, you can choose to continue or to break.
    loop_iter : b -> (b -> a -> LoopResult b b) -> Iterator a -> b;
    loop_iter = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none { break $ accum };
            let (next, iter) = next.as_some;
            let loop_res = op(accum, next);
            if loop_res.is_break { break $ loop_res.as_break };
            continue $ (loop_res.as_continue, iter)
        )
    );

    // Loop by monadic action along an iterator. At each iteration step, you can choose to continue or to break.
    loop_iter_m : [m : Monad] b -> (b -> a -> m (LoopResult b b)) -> Iterator a -> m b;
    loop_iter_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let loop_res = *op(accum, next);
            if loop_res.is_break { break_m $ loop_res.as_break };
            continue_m $ (loop_res.as_continue, iter)
        )
    );

    // The cartesian product of two iterators.
    // Example: `[1, 2, 3].to_iter.product(['a', 'b'].to_iter).to_array == [(1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b')]`
    product : Iterator a -> Iterator b -> Iterator (b, a);
    product = |as, bs| as.map(|a| bs.map(|b| (b, a)))._flatten;

    // Push an element to an iterator.
    push_front : a -> Iterator a -> Iterator a;
    push_front = |elem, iter| (
        let next = |_| (
            some $ (elem, iter)
        );
        Iterator { next: next }     
    );

    // Create a range iterator, i.e. an iterator of the form `[a, a+1, a+2, ..., b-1]`.
    range : I64 -> I64 -> Iterator I64;
    range = |a, b| (
        let next = |_| (
            if a == b {
                Option::none()
            } else {
                Option::some $ (a, Iterator::range(a+1, b))
            }
        );
        Iterator { next: next }
    );

    // Reverse an iterator.
    reverse : Iterator a -> Iterator a;
    reverse = |iter| (
        loop((Iterator::empty, iter), |(out_iter, in_iter)|(
            if in_iter.is_empty {
                break $ out_iter
            } else {
                let (elem, in_iter) = in_iter.advance.as_some;
                let out_iter = out_iter.push_front(elem);
                continue $ (out_iter, in_iter)
            }
        ))
    );

    // Generated all subsequences of an iterator.
    // `[1,2,3].to_iter.subsequences` is `[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]].to_iter.map(to_iter)`.
    subsequences : Iterator a -> Iterator (Iterator a);
    subsequences = |iter| (
        if iter.is_empty { pure $ Iterator::empty };
        let (head, iter) = iter.advance.as_some;
        let subs = iter.subsequences;
        subs.append(subs.map(push_front(head)))
    );

    // Calculate the sum of elements of an iterator.
    sum : [a : Additive] Iterator a -> a;
    sum = fold(Zero::zero, Add::add);

    // Take at most n elements from an iterator.
    take : I64 -> Iterator a -> Iterator a;
    take = |n, iter| (
        let next = |_| (
            if n == 0 { none() };
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            some $ (v, iter.take(n-1))
        );
        Iterator { next: next }
    );

    // Take elements of an iterator while a condition is satisfied.
    // TODO: add test
    take_while : (a -> Bool) -> Iterator a -> Iterator a;
    take_while = |cond, iter| (
        let next = |_| (
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            if !cond(v) { none() };
            some $ (v, iter.take_while(cond))
        );
        Iterator { next: next }        
    );

    // Convert an iterator to an array.
    to_array : Iterator a -> Array a;
    to_array = Array::from_iter;

    // Zip two iterators.
    zip : Iterator b -> Iterator a -> Iterator (a, b);
    zip = |iter0, iter1| (
        let next = |_| (
            let iter0_next = iter0.advance;
            if iter0_next.is_none { none() };
            let iter1_next = iter1.advance;
            if iter1_next.is_none { none() };
            let (v0, iter0) = iter0_next.as_some;
            let (v1, iter1) = iter1_next.as_some;
            some $ ((v1, v0), zip(iter0, iter1))
        );
        Iterator { next: next }
    );
}

impl Iterator a : Add {
    add = |lhs, rhs| lhs.append(rhs);
}

impl [a : Eq] Iterator a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_empty { rhs.is_empty };
        if rhs.is_empty { false };
        let (e, lhs) = lhs.advance.as_some;
        let (f, rhs) = rhs.advance.as_some;
        if e != f { false };
        lhs == rhs
    );
}

impl Iterator : Functor {
    map = |f, a_iter| (
        let next = |_| (
            a_iter.advance.map(
                |(a_val, a_iter)| (f(a_val), a_iter.map(f))
            )
        );
        Iterator { next: next }
    );
}

impl Iterator : Monad {
    pure = |e| Iterator::empty.push_front(e);
    bind = |f, xs| xs.map(f)._flatten;
}

// The type of lazily generated values.
// This is a type alias defined as `type Lazy a = () -> a;`
// You can create a lazy value by `|_| (...an expression to generate the value...)`, and  
// you can evaluate a lazy value `v` by `v()`.
type Lazy a = () -> a;

// LoopResult

namespace LoopResult {

    // Make a break value wrapped in a monad.
    // This is used with `loop_m` function.
    break_m : [m : Monad] r -> m (LoopResult s r);
    break_m = break >> pure;

    // Make a continue value wrapped in a monad.
    // This is used with `loop_m` function.
    continue_m : [m : Monad] s -> m (LoopResult s r);
    continue_m = continue >> pure;

}

type Option a = union { none: (), some: a };

namespace Option {

    // Unwrap an option value if it is `some`, or returns given default value if it is `none`.
    as_some_or : a -> Option a -> a;
    as_some_or = |def, opt| (
        if opt.is_none { def } else { opt.as_some }
    );

    // Returns the provided default value if the option is none, or applies a function to the contained value if the option is some.
    map_or : b -> (a -> b) -> Option a -> b;
    map_or = |def, f, opt| if opt.is_some { f(opt.as_some) } else { def };
}

impl [a : Eq] Option a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_some && rhs.is_some { lhs.as_some == rhs.as_some };
        lhs.is_none && rhs.is_none
    );
}

impl [a : ToString] Option a : ToString {
    to_string = |opt| if opt.is_some { "some(" + opt.as_some.to_string + ")" } else { "none()" };
}

impl Option : Functor {
    map = |f, opt| (
        if opt.is_none {
            Option::none()
        } else {
            Option::some $ f $ opt.as_some
        }
    );
}

impl Option : Monad {
    pure = Option::some;
    bind = |f, opt| if opt.is_none { Option::none() } else { f(opt.as_some) };
}

// The type for file path.
// TODO: give better implementation.
type Path = unbox struct { _data: String };

namespace Path {

    // Parse a string.
    parse : String -> Option Path;
    parse = |s| Option::some $ Path { _data: s };

}

impl Path : ToString {
    to_string = @_data;
}

// The type of punched arrays. 
// A punched array is an array from which a certain element has been removed.
// This is used in the implementation of `Array::act`.
type PunchedArray a = unbox struct { _data : Destructor (Array a), idx : I64 };

namespace PunchedArray {

    // Plug in an element to a punched array to get back an array.
    plug_in : a -> PunchedArray a -> Array a;
    plug_in = |elm, parr| (
        let PunchedArray { _data : data, idx : punched_idx } = parr;
        
        // Clear destructor and extract the internal array.
        // Also note that if the `parr` had been cloned, then the internal array is retained here.
        let arr = data.set_dtor(|_|()).@_value;

        let (is_unique, arr) = arr.unsafe_is_unique;
        if is_unique { 
            // If the array is unique, we directly insert the element.
            arr._unsafe_set(punched_idx, elm)
        } else {
            // If the array is shared, we create a new array and set up the elements.
            let arr_size = arr.get_size;
            let new_arr = Array::empty(arr.get_capacity)._unsafe_set_size(arr_size);
            loop((0, new_arr), |(i, new_arr)| (
                if i == arr_size { break $ new_arr };
                let elm = if i == punched_idx { elm } else { arr.@(i) };
                continue $ (i + 1, new_arr._unsafe_set(i, elm))
            ))
        }
    );

    // Creates a punched array by moving out the element at the specified index.
    // NOTE: this function assumes that the given array is unique WITHOUT CHECKING.
    // The uniqueness of the array is ensured in the `Array::act` function.
    unsafe_punch : I64 -> Array a -> (PunchedArray a, a);
    unsafe_punch = |idx, arr| (
        // Bounds check.
        let size = arr.get_size;
        eval assert(|_|"[PunchedArray::punch] Index out of range.", 0 <= idx && idx < size);

        // Move out the element.
        let elm = arr._unsafe_get(idx);

        // Create the destructor.
        let dtor = |arr| (
            // Prevent elements released by the destructor of `Array`.
            let arr = arr._unsafe_set_size(0);

            // Release elements except the punched one.
            loop((0, arr), |(i, arr)| (
                if i == size { break $ () };
                if i == idx { continue $ (i + 1, arr) };
                let _ = arr._unsafe_get(i); // Release the element.
                continue $ (i + 1, arr)
            ))
        );

        // Return the result.
        let parr = PunchedArray { _data : Destructor::make(arr, dtor), idx : idx };
        (parr, elm)
    );
}

// A type of result value for a computation that may fail.
type Result e o = unbox union { ok : o, err: e };

namespace Result {

    // Returns the containing value if the value is ok, or otherwise aborts.
    unwrap : Result e o -> o;
    unwrap = |res| (
        if res.is_err {
            abort()
        } else {
            res.as_ok
        }
    );
}

impl [e : Eq, a : Eq] Result e a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_ok && rhs.is_ok { lhs.as_ok == rhs.as_ok };
        if lhs.is_err && rhs.is_err { lhs.as_err == rhs.as_err };
        false
    );
}

impl Result e : Functor {
    map = |f, res| (
        if res.is_err {
            Result::err $ res.as_err
        } else {
            Result::ok $ f $ res.as_ok
        }
    );
}

impl Result e : Monad {
    pure = Result::ok;
    bind = |f, res| if res.is_err { Result::err $ res.as_err } else { f(res.as_ok) };
}

impl [e : ToString, a : ToString] Result e a : ToString {
    to_string = |res| if res.is_ok { "ok(" + res.as_ok.to_string + ")" } else { "err(" + res.as_err.to_string + ")" };
}

type String = unbox struct { _data : Array U8 };

namespace String {

    // Get the null-terminated C string.
    // Note that in case the string is not used after call of this function, the returned pointer will be already released.
    _get_c_str : String -> Ptr;
    _get_c_str = |s| s.@_data._get_ptr;

    // Create a string from C string (i.e., null-terminated byte array).
    // If the byte array doesn't include `\0`, this function causes undefined behavior.
    _unsafe_from_c_str : Array U8 -> String;
    _unsafe_from_c_str = |buf| (
        // Return length.
        let len = buf.borrow_ptr(|ptr| CALL_C[I64 strlen(Ptr), ptr]);
        let buf = buf._unsafe_set_size(len + 1);
        String { _data : buf }
    );

    // Create a `String` from a pointer to null-terminated C string.
    // If `ptr` is not pointing to a valid null-terminated C string, this function cause undefined behavior.
    _unsafe_from_c_str_ptr : Ptr -> String;
    _unsafe_from_c_str_ptr = |ptr| (
        let len = CALL_C[I64 strlen(Ptr), ptr];
        let buf_len = len + 1;
        let buf = Array::empty(buf_len)._unsafe_set_size(buf_len);
        let _ = CALL_C[Ptr memcpy(Ptr, Ptr, I64), buf._get_ptr, ptr, buf_len];
        String { _data : buf }
    );

    // Call a function with a null-terminated C string.
    borrow_c_str : (Ptr -> a) -> String -> a;
    borrow_c_str = |f, str| (
        let res = str.@_data.borrow_ptr(f);
        res
    );

    // Concatenate two strings.
    // Note: Since `s1.concat(s2)` puts `s2` after `s1`, `concat(lhs, rhs)` puts `lhs` after `rhs`.
    concat : String -> String -> String;
    concat = |rhs, lhs| (
        // Remove null terminator from lhs and append rhs.
        String { _data : lhs.@_data.pop_back.append(rhs.@_data) }
    );

    // Concatenate an iterator of strings.
    concat_iter : Iterator String -> String;
    concat_iter = |iter| (
        let len = iter.map(get_size).fold(0, add);
        let data_len = len + 1; // Add space for null terminator.
        let data = "".@_data.reserve(data_len);
        let data = iter.fold(data, |data, str| data.pop_back.append(str.@_data));
        String { _data : data }
    );

    // Create an empty string, which is reserved for a length.
    empty : I64 -> String;
    empty = |n| String { _data : Array::empty(n+1).push_back(0_U8) };

    // `str.find(token, start_idx)` finds the index where `token` firstly appears in `str`, starting from `start_idx`.
    // Note that this function basically returns a number less than or equal to `start_idx`, but there is an exception:
    // `str.find("", start_idx)` with `start_idx >= str.get_size` returns `str.get_size`, not `start_idx`.
    find : String -> I64 -> String -> Option I64;
    find = |tok, start, str| (
        let start = min(start, str.get_size);
        let pos = CALL_C[Ptr strstr(Ptr, Ptr), str._get_c_str.add_offset(start), tok._get_c_str];
        let _ = tok; // Prolong lifetime.
        if pos == nullptr {
            Option::none()
        };
        let pos = pos.subtract_ptr(str._get_c_str);
        let _ = str; // Prolong lifetimes.
        Option::some(pos)
    );

    // Get the byte array of a string, containing null-terminator.
    get_bytes : String -> Array U8;
    get_bytes = @_data;

    // Get the first byte of a string. Returns none if the string is empty.
    get_first_byte : String -> Option U8;
    get_first_byte = |s| (
        if s.is_empty { Option::none() };
        Option::some $ s.@_data.@(0)
    );

    // Get the last byte of a string. Returns none if the string is empty.
    get_last_byte : String -> Option U8;
    get_last_byte = |s| (
        let len = s.get_size;
        if len == 0 { Option::none() };
        Option::some $ s.@_data.@(len - 1)
    );

    // Get the length of a string.
    get_size : String -> I64;
    get_size = |s| s.@_data.get_size - 1; // exclude null terminator

    // `String` version of `Array::get_sub`.
    get_sub : I64 -> I64 -> String -> String;
    get_sub = |s, e, str| (
        let len = str.get_size;
        String::_unsafe_from_c_str $ str.get_bytes._get_sub_size_asif(len, 1, s, e).push_back('\0')
    );

    // Returns if the string is empty or not.
    is_empty : String -> Bool;
    is_empty = |s| s.get_size == 0;

    // Join strings by a separator.
    join : String -> Iterator String -> String;
    join = |sep, strs| (
        strs.intersperse(sep).concat_iter
    );

    // Removes the last byte.
    // If the string is empty, this function does nothing.
    pop_back_byte : String -> String;
    pop_back_byte = |s| (
        if s.is_empty { s };
        s.mod__data(|bytes| bytes.pop_back.pop_back.push_back(0_U8))
    );

    // `str.split(sep)` splits `str` by `sep` into an iterator.
    // - If `sep` is empty, this function returns an infinite sequence of ""s.
    // - If `sep` is non-empty and `str` is empty, this function returns an iterator with a single element "".
    split : String -> String -> Iterator String;
    split = |sep, str| (
        let n = str.get_size;
        let m = sep.get_size;
        generate(0, |idx| (
            if idx == -1 { Option::none() };
            if idx == n { Option::some $ ("", -1) };
            let opt_idx = str.find(sep, idx);
            if opt_idx.is_none { Option::some $ (str.get_sub(idx, 0), -1) };
            let idx2 = opt_idx.as_some;
            Option::some $ (str.get_sub(idx, idx2), idx2 + m)
        ))
    );

    // Removes the first byte of a string while it satisifies the specified condition.
    strip_first_bytes : (U8 -> Bool) -> String -> String;
    strip_first_bytes = |cond, str| (
        let len = str.get_size;
        let bytes = str.get_bytes;
        let n = loop(0, |i| (
            if i == len { break $ i };
            if !cond(bytes.@(i)) { break $ i };
            continue $ i + 1
        ));
        if n == 0 { str } else { str.get_sub(n, 0) }
    );

    // Removing leading whitespace characters.
    strip_first_spaces : String -> String;
    strip_first_spaces = strip_first_bytes(|c| CALL_C[I32 isspace(I32), c.to_I32] > 0_I32);

    // Removes the last byte of a string while it satisifies the specified condition.
    strip_last_bytes : (U8 -> Bool) -> String -> String;
    strip_last_bytes = |cond, s| (
        loop(s, |s|
            if s.is_empty { break $ s };
            if cond(s.get_last_byte.as_some) { 
                continue $ s.pop_back_byte
            } else {
                break $ s
            }
        )
    );

    // Removes newlines and carriage returns at the end of the string.
    strip_last_newlines : String -> String;
    strip_last_newlines = strip_last_bytes(|c| c == '\n' || c == '\r');

    // Removing trailing whitespace characters.
    strip_last_spaces : String -> String;
    strip_last_spaces = strip_last_bytes(|c| CALL_C[I32 isspace(I32), c.to_I32] > 0_I32);

    // Strip leading and trailing whitespace characters.
    strip_spaces : String -> String;
    strip_spaces = |s| s.strip_last_spaces.strip_first_spaces;
}

impl String : Add {
    // Concatenate two strings.
    add = |lhs, rhs| lhs.concat(rhs);
}

impl String : Eq {
    // Compare two strings.
    eq = |lhs, rhs| (lhs.@_data == rhs.@_data);
}

impl String : LessThan {
    less_than = |lhs, rhs| lhs.@_data < rhs.@_data;
}

impl String : LessThanOrEq {
    less_than_or_eq = |lhs, rhs| lhs.@_data <= rhs.@_data;
}

impl String : ToString {
    to_string = |s| s;
}

// Unit
impl () : Eq {
    eq = |_, _| true;
}

// Functions

// Compose two functions. Composition operators `<<` and `>>` is translated to use of `compose`. 
compose : (a -> b) -> (b -> c) -> a -> c;
compose = |f, g, a| g(f(a));

// Monadic loop function. This is similar to `loop` but can be used to perform monadic action at each loop.
loop_m : [m : Monad] s -> (s -> m (LoopResult s r)) -> m r;
loop_m = |s, f| (
    let res = *f(s);
    if res.is_break { pure $ res.as_break };
    loop_m(res.as_continue, f)
);

// Constants

namespace I8 {
    maximum : I8;
    maximum = 127_I8;

    minimum : I8;
    minimum = -128_I8;
}
impl I8 : Zero {
    zero = 0_I8;
}

namespace U8 {
    maximum : U8;
    maximum = 255_U8;

    minimum : U8;
    minimum = 0_U8;
}
impl U8 : Zero {
    zero = 0_U8;
}

namespace I16 {
    maximum : I16;
    maximum = 32767_I16;

    minimum : I16;
    minimum = -32768_I16;
}
impl I16 : Zero {
    zero = 0_I16;
}

namespace U16 {
    maximum : U16;
    maximum = 65535_U16;

    minimum : U16;
    minimum = 0_U16;
}
impl U16 : Zero {
    zero = 0_U16;
}

namespace I32 {
    maximum : I32;
    maximum = 2147483647_I32;

    minimum : I32;
    minimum = -2147483648_I32;
}
impl I32 : Zero {
    zero = 0_I32;
}

namespace U32 {
    maximum : U32;
    maximum = 4294967295_U32;

    minimum : U32;
    minimum = 0_U32;
}
impl U32 : Zero {
    zero = 0_U32;
}

namespace I64 {
    maximum : I64;
    maximum = 9223372036854775807;

    minimum : I64;
    minimum = -9223372036854775808;
}
impl I64 : Zero {
    zero = 0_I64;
}

namespace U64 {
    maximum : U64;
    maximum = 18446744073709551615_U64;

    minimum : U64;
    minimum = 0_U64;
}
impl U64 : Zero {
    zero = 0_U64;
}

impl F32 : Zero {
    zero = 0.0_F32;
}

impl F64 : Zero {
    zero = 0.0_F64;
}

// Traits

trait Additive = Add + Zero;

trait a : FromBytes {
    from_bytes : Array U8 -> Result ErrMsg a;
}

trait a : FromString {
    from_string : String -> Result ErrMsg a;
}

trait [f : *->*] f : Functor {
    map : (a -> b) -> f a -> f b;
}

namespace Functor {
    forget : [f : Functor] f a -> f ();
    forget = map(|_|());
}

namespace LessThan {
    max : [a : LessThan] a -> a -> a;
    max = |x, y| if x < y { y } else { x };

    min : [a : LessThan] a -> a -> a;
    min = |x, y| if x < y { x } else { y };
}

trait [m : *->*] m : Monad {
    bind : (a -> m b) -> m a -> m b;
    pure : a -> m a;
}

namespace Monad {
    // Flatten a nested monadic action.
    flatten : [m : Monad] m (m a) -> m a;
    flatten = Monad::bind(|x|x);

    // `unless(cond, act)` where `act` is a monadic value which returns `()` perfoms `act` only when `cond` is false.
    unless : [m : Monad] Bool -> m () -> m ();
    unless = |cond, act| if cond { pure $ () } else { act };

    // `when(cond, act)` where `act` is a monadic value which returns `()` perfoms `act` only when `cond` is true.
    when : [m : Monad] Bool -> m () -> m ();
    when = |cond, act| if cond { act } else { pure $ () };
}

trait a : ToBytes {
    to_bytes : a -> Array U8;
}

trait a : ToString {
    to_string : a -> String;
}

trait a : Zero {
    zero : a;
}

// Abs

namespace I8 {
    abs : I8 -> I8;
    abs = |f| if f < 0_I8 { -f } else { f };
}

namespace I16 {
    abs : I16 -> I16;
    abs = |f| if f < 0_I16 { -f } else { f };
}

namespace I32 {
    abs : I32 -> I32;
    abs = |f| if f < 0_I32 { -f } else { f };
}

namespace I64 {
    abs : I64 -> I64;
    abs = |f| if f < 0 { -f } else { f };
}

namespace F32 {
    abs : F32 -> F32;
    abs = |f| if f < 0.0_F32 { -f } else { f };
}

namespace F64 {
    abs : F64 -> F64;
    abs = |f| if f < 0.0 { -f } else { f };
}

// `Ptr` basic operations.
namespace Ptr {
    // Add an offset to a pointer.
    add_offset : I64 -> Ptr -> Ptr;
    add_offset = |off, ptr| CALL_C[Ptr fixruntime_ptr_add_offset(Ptr, I64), ptr, off];

    // Subtract two pointers.
    // Note that `x.subtract_ptr(y)` calculates `x - y`, so `subtract_ptr(x, y)` calculates `y - x`.
    subtract_ptr : Ptr -> Ptr -> I64;
    subtract_ptr = |rhs, lhs| CALL_C[I64 fixruntime_subtract_ptr(Ptr, Ptr), lhs, rhs];
}

// ToString, FromString implementations for fundamental types

impl Ptr : ToString {
    to_string = |v| (
        let data = Array::empty(17);
        eval CALL_C[() fixruntime_ptr_to_str(Ptr, Ptr), data._get_ptr, v];
        String::_unsafe_from_c_str(data)
    );
}
impl U8 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(1)._unsafe_set_size(1);
        eval CALL_C[() fixruntime_u8_to_bytes(Ptr, U8), data._get_ptr, v];
        data
    );
}
impl U8 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 1 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U8."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[U8 fixruntime_u8_from_bytes(Ptr), ptr])
    );
}
impl U8 : ToString {
    to_string = |v| (
        let data = Array::empty(4); // len(255) + 1
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_u8_to_str(Ptr, U8), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
impl U8 : FromString {
    from_string = |str| str.from_string.map(U64::to_U8);
}

impl U16 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(2)._unsafe_set_size(2);
        eval CALL_C[() fixruntime_u16_to_bytes(Ptr, U16), data._get_ptr, v];
        data
    );
}
impl U16 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 2 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U16."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[U16 fixruntime_u16_from_bytes(Ptr), ptr])
    );
}
impl U16 : ToString {
    to_string = |v| (
        let data = Array::empty(6); // len(65535) + 1
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_u16_to_str(Ptr, U16), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
impl U16 : FromString {
    from_string = |str| str.from_string.map(U64::to_U16);
}

impl U32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        eval CALL_C[() fixruntime_u32_to_bytes(Ptr, U32), data._get_ptr, v];
        data
    );
}
impl U32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U32."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[U32 fixruntime_u32_from_bytes(Ptr), ptr])
    );
}
impl U32 : ToString {
    to_string = |v| (
        let data = Array::empty(11);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_u32_to_str(Ptr, U32), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
impl U32 : FromString {
    from_string = |str| str.from_string.map(U64::to_U32);
}

impl U64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        eval CALL_C[() fixruntime_u64_to_bytes(Ptr, U64), data._get_ptr, v];
        data
    );
}
impl U64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U64."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[U64 fixruntime_u64_from_bytes(Ptr), ptr])
    );
}
impl U64 : ToString {
    to_string = |v| (
        let data = Array::empty(21);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_u64_to_str(Ptr, U64), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
impl U64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = CALL_C[U64 fixruntime_strtoull_10(Ptr), c_str];
            let err = CALL_C[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (invalid format): " + str) };
            let err = CALL_C[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl I8 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(1)._unsafe_set_size(1);
        eval CALL_C[() fixruntime_u8_to_bytes(Ptr, I8), data._get_ptr, v];
        data
    );
}
impl I8 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 1 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I8."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[I8 fixruntime_u8_from_bytes(Ptr), ptr])
    );
}
impl I8 : ToString {
    to_string = |v| (
        let data = Array::empty(5); // len(-128) + 1
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_i8_to_str(Ptr, I8), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
impl I8 : FromString {
    from_string = |str| str.from_string.map(I64::to_I8);
}

impl I16 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(2)._unsafe_set_size(2);
        eval CALL_C[() fixruntime_u16_to_bytes(Ptr, I16), data._get_ptr, v];
        data
    );
}
impl I16 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 2 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I16."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[I16 fixruntime_u16_from_bytes(Ptr), ptr])
    );
}
impl I16 : ToString {
    to_string = |v| (
        let data = Array::empty(7); // len(-32768) + 1
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_i16_to_str(Ptr, I16), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
impl I16 : FromString {
    from_string = |str| str.from_string.map(I64::to_I16);
}

impl I32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        eval CALL_C[() fixruntime_u32_to_bytes(Ptr, I32), data._get_ptr, v];
        data
    );
}
impl I32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I32."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[I32 fixruntime_u32_from_bytes(Ptr), ptr])
    );
}
impl I32 : ToString {
    to_string = |v| (
        let data = Array::empty(12);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_i32_to_str(Ptr, I32), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
impl I32 : FromString {
    from_string = |str| str.from_string.map(I64::to_I32);
}

impl I64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        eval CALL_C[() fixruntime_u64_to_bytes(Ptr, I64), data._get_ptr, v];
        data
    );
}
impl I64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I64."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[I64 fixruntime_u64_from_bytes(Ptr), ptr])
    );
}
impl I64 : ToString {
    to_string = |v| (
        let data = Array::empty(21);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_i64_to_str(Ptr, I64), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
impl I64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = CALL_C[I64 fixruntime_strtoll_10(Ptr), c_str];
            let err = CALL_C[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (invalid format): " + str) };
            let err = CALL_C[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl F32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        eval CALL_C[() fixruntime_f32_to_bytes(Ptr, F32), data._get_ptr, v];
        data
    );
}
impl F32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as F32."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[F32 fixruntime_f32_from_bytes(Ptr), ptr])
    );
}
impl F32 : ToString {
    to_string = |v| (
        let data = Array::empty(50);
        eval CALL_C[() fixruntime_f32_to_str(Ptr, F32), data._get_ptr, v];
        String::_unsafe_from_c_str(data)
    );
}
namespace F32 {
    // Convert a floating number to a string of exponential form.
    to_string_exp : F32 -> String;
    to_string_exp = |v| (
        let data = Array::empty(50);
        eval CALL_C[() fixruntime_f32_to_str_exp(Ptr, F32), data._get_ptr, v];
        String::_unsafe_from_c_str(data)
    );

    // Convert a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).
    to_string_exp_precision : U8 -> F32 -> String;
    to_string_exp_precision = |prec, v| (
        let data = Array::empty(50 + prec.to_I64);
        eval CALL_C[() fixruntime_f32_to_str_exp_precision(Ptr, F32, U8), data._get_ptr, v, prec];
        String::_unsafe_from_c_str(data)
    );

    // Convert a floating number to a string with specified precision (i.e., number of digits after the decimal point).
    to_string_precision : U8 -> F32 -> String;
    to_string_precision = |prec, v| (
        let data = Array::empty(50 + prec.to_I64);
        eval CALL_C[() fixruntime_f32_to_str_precision(Ptr, F32, U8), data._get_ptr, v, prec];
        String::_unsafe_from_c_str(data)
    );
}
impl F32 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = CALL_C[F32 fixruntime_strtof(Ptr), c_str];
            let err = CALL_C[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to number (invalid format): " + str) };
            let err = CALL_C[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to number (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl F64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        eval CALL_C[() fixruntime_f64_to_bytes(Ptr, F64), data._get_ptr, v];
        data
    );
}
impl F64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as F64."
        };
        Result::ok $ bs.borrow_ptr(|ptr| CALL_C[F64 fixruntime_f64_from_bytes(Ptr), ptr])
    );
}
impl F64 : ToString {
    to_string = |v| (
        let data = Array::empty(500);
        eval data.borrow_ptr(|ptr| (
            CALL_C[() fixruntime_f64_to_str(Ptr, F64), ptr, v]
        ));
        String::_unsafe_from_c_str(data)
    );
}
namespace F64 {
    // Convert a floating number to a string of exponential form.
    to_string_exp : F64 -> String;
    to_string_exp = |v| (
        let data = Array::empty(500);
        eval CALL_C[() fixruntime_f64_to_str_exp(Ptr, F64), data._get_ptr, v];
        String::_unsafe_from_c_str(data)
    );

    // Convert a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).
    to_string_exp_precision : U8 -> F64 -> String;
    to_string_exp_precision = |prec, v| (
        let data = Array::empty(500 + prec.to_I64);
        eval CALL_C[() fixruntime_f64_to_str_exp_precision(Ptr, F64, U8), data._get_ptr, v, prec];
        String::_unsafe_from_c_str(data)
    );

    // Convert a floating number to a string with specified precision (i.e., number of digits after the decimal point).
    to_string_precision : U8 -> F64 -> String;
    to_string_precision = |prec, v| (
        let data = Array::empty(500 + prec.to_I64);
        eval CALL_C[() fixruntime_f64_to_str_precision(Ptr, F64, U8), data._get_ptr, v, prec];
        String::_unsafe_from_c_str(data)
    );
}
impl F64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = CALL_C[F64 fixruntime_strtod(Ptr), c_str];
            let err = CALL_C[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to number (invalid format): " + str) };
            let err = CALL_C[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to number (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

// ToString implementations for fundamental types
impl () : ToString {
    to_string = |_| "()";
}