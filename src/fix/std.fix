// Module `Std` provides basic types, traits and values.
// 
// This module is special in the sense that: 
//
// - It is always imported implicitly. If you don't want to import some or all of entities in this module, you should write `import Std {...entities...}` explicitly.
// - It contains built-in types or values which are defined or implemented directly by Fix compiler, not by Fix source code.
// 
// NOTE on tuples: 
// The tuple types `Std::TupleN` are defined on demand, i.e., if the user uses N-tuple in the source code, 
// the compiler generates definition `TupleN` and related functions / trait implementations.
// The document for `Std` module describes about them up to N=3, but you can use larger tuples in the same way.
module Std;

// A union type with variants `continue` and `break`.
// 
// This type is used to represent the result of a loop body function passed to `Std::loop` or other similar functions.
type LoopState s r = unbox union { continue : s, break : r };

// `loop` enables you to make a loop. `LoopState` is a union type defined as follows: 
// 
// ```
// type LoopState s r = unbox union { continue : s, break : r };
// ```
// 
// `loop` takes two arguments: the initial state of the loop `s0` and the loop body function `body`. 
// It first calls `body` on `s0`. 
// If `body` returns `break(r)`, then the loop ends and returns `r` as the result. 
// If `body` returns `continue(s)`, then the loop calls again `body` on `s`.
// 
// Example:
// ```
// module Main;
//  
// main : IO ();
// main = (
//     let sum = loop((0, 0), |(i, sum)|
//         if i == 100 { break $ sum };
//         continue $ (i + 1, sum + i)
//     );
//     println $ sum.to_string
// ); // evaluates to 0 + 1 + ... + 99 
// ```
// 
// # Parameters
// 
// * `s0` - The initial state of the loop.
// * `body` - The loop body function. It takes the current state of the loop and returns either `continue(s)` or `break(r)`.
loop : s -> (s -> LoopState s r) -> r;
loop = |s, body| (
    match body(s) {
        continue(s) => loop(s, body),
        break(b) => b
    }
);

namespace Array {

    // A function like `get_sub`, but behaves as if the size of the array is the specified value, 
    // and has a parameter to specify additional capacity of the returned `Array`.
    _get_sub_size_with_length_and_additional_capacity : I64 -> I64 -> I64 -> I64 -> Array a -> Array a;
    _get_sub_size_with_length_and_additional_capacity = |len, additional_capacity, s, e, arr| (
        let s = max(0, s);
        let e = min(len, e);
        let n = if e > s { e - s } else { 0 };
        let res = Array::empty(n + additional_capacity);
        if n == 0 || len == 0 { res };
        loop((s, res), |(i, res)| (
            if i == e { break $ res };
            let res = res.push_back(arr.@(i));
            continue $ (i + 1, res)
        ))
    ); 

    // Updates an array by applying a function to the element at the specified index.
    //
    // This function clones the given array if it is shared.
    // 
    // If you call `arr.mod(i, f)` when both of `arr` and `arr.@(i)` are unique, it is assured that `f` receives the element value which is unique. 
    // 
    // # Parameters
    // 
    // * `i` - The index of the element to modify.
    // * `modifier` - The function to apply to the element.
    // * `array` - The array to modify.
    mod : I64 -> (a -> a) -> Array a -> Array a;
    mod = |idx, fun, arr| (
        let size = arr.get_size;
        if !(0 <= idx && idx < size) { undefined("Index out of range.") };
        let arr = arr._unsafe_force_unique;
        let (arr, elm) = arr._unsafe_get_linear(idx);
        let elm = fun(elm);
        arr._unsafe_set(idx, elm)
    );

    // Modifies an array by a functorial action. 
    // 
    // Semantically, `arr.act(idx, fun)` is equivalent to `fun(arr.@(idx)).map(|elm| arr.set(idx, elm))`.
    // 
    // This function can be defined for any functor `f` in general, but it is easier to understand the behavior when `f` is a monad: 
    // the monadic action `act(idx, fun, arr)` first performs `fun(arr.@(idx))` to get a value `elm`, and returns a pure value `arr.set(idx, elm)`. 
    // 
    // If you call `arr.act(idx, fun)` when both of `arr` and `arr.@(idx)` are unique, it is assured that `fun` receives the unique value.
    // 
    // If you call `act` on an array which is shared, this function clones the given array when inserting the result of your action into the array. 
    // This means that you don't need to pay cloning cost when your action failed, as expected.
    // 
    // # Parameters
    //
    // * `i` - The index of the element to be acted on.
    // * `action` - The functorial action to be performed on the element at index `idx`.
    // * `array` - The array.
    act : [f : Functor] I64 -> (a -> f a) -> Array a -> f (Array a);
    act = |idx, fun, arr| (
        let (unique, arr) = arr.unsafe_is_unique;
        if unique {
            let (parr, elm) = PunchedArray::unsafe_punch(idx, arr);
            fun(elm).map(|elm| parr.plug_in(elm))
        } else {
            fun(arr.@(idx)).map(|elm| arr.set(idx, elm))
        }
    );

    // Appends an array to an array.
    // 
    // Note: Since `a1.append(a2)` puts `a2` after `a1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    // 
    // # Parameters
    // 
    // * `second` - The array to be appended.
    // * `first` - The array to which `second` is appended.
    append : Array a -> Array a -> Array a;
    append = |v2, v1| (
        let v1_len = v1.get_size;
        let v2_len = v2.get_size;

        // Reserve v1's buffer and force uniqueness.        
        let len = v1_len + v2_len;
        let v1 = if v1.get_capacity < len {
            v1.reserve(max(len, 2 * v1.get_capacity))
        } else {
            v1._unsafe_force_unique
        };
        
        // Set length.
        let v1 = v1._unsafe_set_size(len);

        // Copy elements of v2 to v1.
        loop((0, v1), |(idx, v1)|(
            if idx >= v2_len { break $ v1 };
            let v1 = v1._unsafe_set(v1_len + idx, v2.@(idx));
            continue $ (idx+1, v1)
        ))
    );

    // Finds the first index at which the element satisfies a condition.
    // 
    // # Parameters
    //
    // * `cond` - The condition to be satisfied.
    // * `array` - The array to be searched.
    find_by : (a -> Bool) -> Array a -> Option I64;
    find_by = |cond, arr| (
        let len = arr.get_size;
        loop(0, |idx| (
            if idx == len { break $ Option::none $ () };
            if cond(arr.@(idx)) { break $ Option::some $ idx };
            continue $ idx + 1
        ))
    );

    // Create an array from an iterator.
    // 
    // # Parameters
    // 
    // * `it` - The iterator to be converted to an array.
    from_iter : [it : Iterator, Item it = a] it -> Array a;
    from_iter = Iterator::to_array;

    // Creates an array by a mapping function.
    // 
    // # Parameters
    // 
    // * `size` - The size of the array to be created.
    // * `map` - The mapping function. It takes an index and returns the value at that index.
    from_map : I64 -> (I64 -> a) -> Array a;
    from_map = |size, map| (
        let arr = Array::empty(size)._unsafe_set_size(size);
        loop((0, arr), |(idx, arr)|(
            if idx == size {
                break $ arr
            } else {
                let arr = arr._unsafe_set(idx, map(idx));
                continue $ (idx + 1, arr)
            }
        ))
    );

    // Gets the first element of an array. Returns none if the array is empty.
    // 
    // # Parameters
    // 
    // * `arr` - The array.
    get_first : Array a -> Option a;
    get_first = |arr| (
        if arr.is_empty { Option::none() };
        Option::some $ arr.@(0)
    );

    // Gets the last element of an array. Returns none if the array is empty.
    // 
    // # Parameters
    // 
    // * `arr` - The array.
    get_last : Array a -> Option a;
    get_last = |arr| (
        let len = arr.get_size;
        if len == 0 { Option::none() };
        Option::some $ arr.@(len - 1)
    );

    // `arr.get_sub(s, e)` returns an array `[ arr.@(i) | i âˆˆ [s, e) ]`.
    // 
    // `s` and `e` are clamped to the range `[0, arr.get_size]`.
    // 
    // # Parameters
    // 
    // * `start` - The start index of the subarray.
    // * `end` - The end index of the subarray.
    // * `array` - The array to be sliced.
    get_sub : I64 -> I64 -> Array a -> Array a;
    get_sub = |s, e, arr| arr._get_sub_size_with_length_and_additional_capacity(arr.get_size, 0, s, e);

    // Gets whether the array is empty.
    // 
    // # Parameters
    // 
    // * `array` - The array to be checked.
    is_empty : Array a -> Bool;
    is_empty = |arr| ( arr.get_size == 0 );

    // Pops an element at the back of an array.
    // If the array is empty, this function does nothing.
    // 
    // # Parameters
    // 
    // * `array` - The array to be popped.
    pop_back : Array a -> Array a;
    pop_back = |arr| (
        let len = arr.get_size;
        if len == 0 { arr };
        arr._unsafe_force_unique._unsafe_set_size(len-1)._unsafe_get_linear(len-1).@0
    );

    // Pushes an element to the back of an array.
    // 
    // # Parameters
    // 
    // * `element` - The element to be pushed.
    // * `array` - The array to which the element is pushed.
    push_back : a -> Array a -> Array a;
    push_back = |e, arr| (
        let len = arr.get_size;
        let arr = if arr.get_capacity < len + 1 {
            arr.reserve(2*(len + 1))
        } else {
            arr
        };
        arr._unsafe_force_unique._unsafe_set_size(len+1)._unsafe_set(len, e)
    );

    // Reserves the memory region for an array.
    // 
    // # Parameters
    // 
    // * `capacity` - The capacity to be reserved.
    // * `array` - The array to be reserved.
    reserve : I64 -> Array a -> Array a;
    reserve = |cap, arr| (
        if cap <= arr.get_capacity { arr };
        let len = arr.get_size;
        let new = Array::empty(cap)._unsafe_set_size(len);
        loop((0, new), |(idx, new)|(
            if idx == len {
                break $ new
            } else {
                let new = new._unsafe_set(idx, arr.@(idx));
                continue $ (idx + 1, new)
            }
        ))
    );

    // Sort by "less than" comparator.
    //
    // Note: this is not a stable sort.
    //
    // # Parameters
    // - `less_than`: A function that takes two elements and returns true if the first is
    //   less than the second.
    // - `arr`: An array of elements to be sorted.
    sort_by : ((a, a) -> Bool) -> Array a -> Array a;
    sort_by = |less_than, arr| (
        let depth = loop((arr.get_size, 0_U8), |(n, depth)| if n == 0 { break $ depth } else { continue $ (n/2, depth+1_U8) } );
        arr._unsafe_force_unique._introsort_by_internal(less_than, 0, arr.get_size, depth)
    );

    // Quicksort for the specified range in an array.
    //
    // # Parameters
    // - `less_than`: A function that takes two elements and returns true if the first is
    //   less than the second.
    // - `start`: The starting index of the range to sort.
    // - `end`: The ending index of the range to sort.
    // - `arr`: An array of elements to be sorted.
    // - `depth`: The depth of the recursion.
    _introsort_by_internal : ((a, a) -> Bool) -> I64 -> I64 -> U8 -> Array a -> Array a;
    _introsort_by_internal = |less_than, start, end, depth, arr| (
        if end - start <= 1 { arr };
        if end - start <= 12 { arr._insertion_sort_by_ranged(less_than, start, end) };
        if depth == 0_U8 { arr._heap_sort_by_ranged(less_than, start, end) };

        let pivot_i = (start + end) / 2;
        let pivot = arr.@(pivot_i);

        // Move pivot to the last.
        let arr = arr._unsafe_swap(pivot_i, end - 1);

        let (arr, pivot_i) = range(start, end).fold((arr, start), |j, (arr, i)|
            if less_than((arr.@(j), pivot)) {
                // Found j such that `arr.@(j)` < pivot, then move it to the left.
                (arr._unsafe_swap(i, j), i + 1)
            } else {
                (arr, i)
            }
        );

        // Move pivot to pivot_i.
        let arr = arr._unsafe_swap(pivot_i, end - 1);

        let arr = arr._introsort_by_internal(less_than, start, pivot_i, depth - 1_U8);
        let arr = arr._introsort_by_internal(less_than, pivot_i + 1, end, depth - 1_U8);

        arr
    );

    // Insertion sort for the specified range in an array.
    //
    // # parameters
    // - `less_than`: A function that takes two elements and returns true if the first is
    //   less than the second.
    // - `start`
    // - `end`
    // - `arr`: An array of elements to be sorted.
    _insertion_sort_by_ranged : ((a, a) -> Bool) -> I64 -> I64 -> Array a -> Array a;
    _insertion_sort_by_ranged = |less_than, start, end, arr| (
        let n = end - start;
        if n <= 1 { arr };
        range(start + 1, start + n).fold(arr, |i, arr| (
            let v = arr.@(i);
            loop((arr, i), |(arr, j)|
                if j == start { 
                    break $ arr.set(start, v)
                };
                let w = arr.@(j-1);
                if less_than((v, w)) {
                    continue $ (arr.set(j, w), j-1)
                } else {
                    break $ arr.set(j, v)
                }
            )
        ))
    );

    // Heap sort for the specified range in an array.
    // 
    // # parameters
    // - `less_than`: A function that takes two elements and returns true if the first is
    //   less than the second.
    // - `start`
    // - `end`
    // - `arr`: An array of elements to be sorted.
    _heap_sort_by_ranged : ((a, a) -> Bool) -> I64 -> I64 -> Array a -> Array a;
    _heap_sort_by_ranged = |less_than, start, end, arr| (
        let n = end - start;
        if n <= 1 { arr };

        // Build the heap.
        let heap = range_step(n/2-1, -1, -1).fold(arr, |i, arr| arr._heap_down_ranged(less_than, start + i, start + n, start, end));

        // Extract elements from the heap one by one.
        range_step(n-1, 0, -1).fold(heap, |i, heap|
            let heap = heap._unsafe_swap(start + 0, start + i);

            // Call sift down on the reduced heap.
            heap._heap_down_ranged(less_than, start + 0, start + i, start, end)
        )
    );

    // Down-heap (sift down) operation to maintain the heap property.
    //
    // # parameters
    // - `less_than`: A function that takes two elements and returns true if the first is
    //   less than the second.
    // - `i`: The index of the element to sift down.
    // - `n`: The end index of the heap.
    // - `start`: the range of an array.
    // - `end`: the range of an array.
    // - `heap`: An array representing the heap.
    _heap_down_ranged : ((a, a) -> Bool) -> I64 -> I64 -> I64 -> I64 -> Array a -> Array a;
    _heap_down_ranged = |less_than, i, n, start, end, heap| (
        let left = 2 * (i - start) + 1 + start;
        let right = 2 * (i - start) + 2 + start;

        let largest = i;
        let largest = if left < n && less_than((heap.@(i), heap.@(left))) { left } else largest;
        let largest = if right < n && less_than((heap.@(largest), heap.@(right))) { right } else largest;

        if largest == i { heap };

        let heap = heap._unsafe_swap(i, largest);
        heap._heap_down_ranged(less_than, largest, n, start, end)
    );

    // Swaps two elements in an array at indices `i` and `j`.
    // 
    // This function is unsafe in the sense that it does not check the uniqueness of the array, and it does not check the bounds of `i` and `j`.
    //
    // # parameters
    // - `arr`: The array in which to swap elements.
    // - `i`: The index of the first element to swap.
    // - `j`: The index of the second element to swap.
    _unsafe_swap : I64 -> I64 -> Array a -> Array a;
    _unsafe_swap = |i, j, arr| (
        let arr = arr;
        let (arr, a) = arr._unsafe_get_linear(i);
        let (arr, b) = arr._unsafe_get_linear(j);
        arr._unsafe_set(i, b)._unsafe_set(j, a)
    );

    // Stable sort by "less than" comparator.
    // 
    // Note: Currently this is implemented by merge sort, which is not in-place.
    // 
    // # Parameters
    // 
    // * `less_than` - The comparator function.
    // * `array` - The array to be sorted.
    sort_stable_by : ((a, a) -> Bool) -> Array a -> Array a;
    sort_stable_by = |less_than, vec| (
        let buffer = Array::empty(vec.get_size);
        let (vec, buffer) = vec._mergesort_range_using_buffer(buffer, 0, vec.get_size, less_than);
        vec
    );

    // Sorts elements in a range of a vector by "less than" comparator.
    // 
    // This function receives a working buffer as the first argument to reduce memory allocation, and returns it as second element.
    _mergesort_range_using_buffer : Array a -> I64 -> I64 -> ((a, a) -> Bool) -> Array a -> (Array a, Array a);
    _mergesort_range_using_buffer = |buffer, begin, end, less_than, vec| (
        // Merge sorting.
        let len = end - begin;
        if len <= 1 { (vec, buffer) };
        // Divide into intervals.
        let former_len = len / 2;
        let former_begin = begin;
        let former_end = begin + former_len;
        let latter_len = len - former_len;
        let latter_begin = former_end;
        let latter_end = end;
        let (vec, buffer) = vec._mergesort_range_using_buffer(buffer, former_begin, former_end, less_than);
        let (vec, buffer) = vec._mergesort_range_using_buffer(buffer, latter_begin, latter_end, less_than);
        // Merge former and latter to buffer.
        let buffer = buffer.truncate(0);
        let former_pos = former_begin;
        let latter_pos = latter_begin;
        let buffer = loop((former_pos, latter_pos, buffer), |(former_pos, latter_pos, buffer)|(
            if former_pos == former_end { // If former_pos reached to the end,
                if latter_pos == latter_end { break $ buffer };
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(vec.@(latter_pos));
                continue $ (former_pos, latter_pos + 1, buffer)
            };
            if latter_pos == latter_end { // If latter_pos reached to the end,
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(vec.@(former_pos));
                continue $ (former_pos + 1, latter_pos, buffer)
            };
            let former_elem = vec.@(former_pos);
            let latter_elem = vec.@(latter_pos);
            if !less_than((latter_elem, former_elem)) { // Essential for stability.
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(former_elem);
                continue $ (former_pos + 1, latter_pos, buffer)
            } else {
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(latter_elem);
                continue $ (former_pos, latter_pos + 1, buffer)
            }
        ));
        // Copy buffer to vec.
        loop((0, vec), |(idx, vec)|(
            if idx == len { break $ (vec, buffer) };
            let vec = vec.set(begin + idx, buffer.@(idx));
            continue $ (idx + 1, vec)
        ))
    );

    // Converts an array to an iterator.
    // 
    // # Parameters
    // 
    // * `array` - The array to be converted.
    to_iter : Array a -> ArrayIterator a;
    to_iter = Iterator::from_array;

    // Truncates an array, keeping the given number of first elements.
    // 
    // `truncante(len, arr)` does nothing if `len >= arr.get_size`.
    // 
    // # Parameters
    // 
    // * `new_length` - The number of elements to be kept.
    // * `array` - The array to be truncated.
    truncate : I64 -> Array a -> Array a;
    truncate = |length, vec| (
        if length < 0 { undefined("[Std::Array::truncate] Negative size is not allowed.") };
        loop(vec, |vec|(
            if length >= vec.get_size { break $ vec };
            continue $ vec.pop_back
        ))
    );

    // Resizes an array to the given size, filling with the given value if the new size is larger than the current size, 
    // or truncating if the new size is smaller than the current size.
    // 
    // # Parameters
    // * `new_size` - The new size of the array.
    // * `fill_value` - The value to fill if the new size is larger than the current size.
    // * `array` - The array to be resized.
    resize : I64 -> a -> Array a -> Array a;
    resize = |n, x, xs| (
        if n <= xs.get_size { xs.truncate(n) };
        let m = xs.get_size;
        let xs = xs.reserve(n)._unsafe_force_unique._unsafe_set_size(n);
        range(m, n).fold(xs, |i, xs| xs._unsafe_set(i, x) )
    );

    // `arr.search_partition_point(pred)` returns an index x such that `pred` is true on [0, x) and false on [x, n) by binary search.
    // 
    // When we put an order on `Bool` as `false < true`, `pred` must be monotonically decreasing on `arr`.
    // 
    // The returned value x satisfies 0 <= x <= `arr.get_size`. If `arr` is empty, it returns 0.
    // 
    // Added in v1.1.0.
    // 
    // # Parameters
    // 
    // * `predicate` - The predicate function.
    // * `array` - The array to be searched.
    search_partition_point : (a -> Bool) -> Array a -> I64;
    search_partition_point = |pred, arr| (
        let n = arr.get_size;
        if n == 0 { 0 };
        if !pred(arr.@(0)) { 0 };
        loop((0, n), |(left, right)|
            if right - left <= 1 { break $ right };
            let mid = (left + right) / 2;
            continue $ if pred(arr.@(mid)) { (mid, right) } else { (left, mid) }
        )
    );
}

// The empty array with zero capacity.
impl Array a : Zero {
    zero = Array::empty(0);
}

// Concatenates two arrays.
impl Array a : Add {
    add = |lhs, rhs| lhs.append(rhs);
}

impl [a : Eq] Array a : Eq {
    eq = |lhs, rhs| (
        if lhs.get_size != rhs.get_size { false };
        let len = lhs.get_size;
        loop(0, |idx| (
            if idx == len { break $ true };
            if lhs.@(idx) != rhs.@(idx) { break $ false };
            continue $ idx + 1
        ))
    );
}

// `LessThan` implementation for `Array a`.
// 
// Compares two arrays by lexicographic order.
impl [a : Eq, a : LessThan] Array a : LessThan {
    less_than = |lhs, rhs| (
        loop(0, |i| (
            if i == lhs.get_size && i == rhs.get_size { break $ false };
            if i == lhs.get_size { break $ true };
            if i == rhs.get_size { break $ false };
            let l = lhs.@(i);
            let r = rhs.@(i);
            if l != r { break $ l < r };
            continue $ i + 1
        ))
    );
}

// `LessThanOrEq` implementation for `Array a`.
// 
// Compares two arrays by lexicographic order.
impl [a : Eq, a : LessThanOrEq] Array a : LessThanOrEq {
    less_than_or_eq = |lhs, rhs| (
        loop(0, |i| (
            if i == lhs.get_size && i == rhs.get_size { break $ true };
            if i == lhs.get_size { break $ true };
            if i == rhs.get_size { break $ false };
            let l = lhs.@(i);
            let r = rhs.@(i);
            if l != r { break $ l <= r };
            continue $ i + 1
        ))
    );
}

impl Array : Functor {
    map = |f, arr| (
        let n = arr.get_size;
        let res = Array::empty(n);
        loop((0, res), |(i, res)| (
            if i == n { break $ res };
            let e = f $ arr.@(i);
            continue $ (i+1, res.push_back(e))
        ))
    );
}

impl Array : Monad {
    pure = |e| [e];
    bind = |f, arr| (
        let size = arr.get_size;
        let arr_arr = Array::empty(size);
        let (arr_arr, count) = loop((0, arr_arr, 0), |(idx, arr_arr, count)| (
            if idx == size { break $ (arr_arr, count) };
            let inner = f $ arr.@(idx);
            let count = count + inner.get_size;
            let arr_arr = arr_arr.push_back(inner);
            continue $ (idx + 1, arr_arr, count)
        ));
        let ret = Array::empty(count);
        loop((0, ret), |(i, ret)| (
            if i == size { break $ ret };
            let inner = arr_arr.@(i);
            continue $ loop((0, ret), |(j, ret)|(
                if j == inner.get_size {
                    break $ (i + 1, ret)
                } else {
                    let ret = ret.push_back(inner.@(j));
                    continue $ (j + 1, ret)
                }
            ))
        ))
    );
}

impl [a : ToString] Array a : ToString {
    to_string = |arr| ("[" + arr.to_iter.map(to_string).join(", ") + "]");
}

impl Arrow a : Functor {
    map = |f, a| a >> f;
}

impl Arrow a : Monad {
    pure = |x| |_| x;
    bind = |f, a| |x| f(a(x)) $ x;
}

impl Bool : ToString {
    to_string = |lhs| (
        if lhs { "true" } else { "false" }
    );
}

// Boxed wrapper for a type.
type Box a = box struct { value : a };

namespace Box {
    make : a -> Box a;
    make = |val| Box { value : val };
}

// Marker trait for boxed types.
// 
// This trait is automatically implemented for all boxed types.
// Implementing this trait manually is not allowed.
trait a : Boxed {}

// A type (alias) for error message. 
type ErrMsg = String;

namespace FFI {

    // `x.mutate_boxed_io(io)` gets a pointer `ptr` to the data that `x` points to, executes `io(ptr)`, and then returns mutated `x` paired with the result of `io(ptr)`.
    // 
    // Similar to `mutate_boxed`, but this function is used when you want to run the IO action in the existing IO context.
    // 
    // For more details on the pointer passed to `io`, see the document of `borrow_boxed`.
    // 
    // For more details, see the document of `mutate_boxed`.
    // 
    // See also: `borrow_boxed`, `borrow_boxed_io`, `mutate_boxed`.
    // 
    // # Parameters
    // 
    // * `action` - The IO action to be performed on the pointer.
    // * `value` - The boxed value to be mutated.
    mutate_boxed_io : [a : Boxed] (Ptr -> IO b) -> a -> IO (a, b);
    mutate_boxed_io = |act, val| IO::from_runner $ |ios| mutate_boxed_ios(act, val, ios);

    // Borrows a pointer to the data of a boxed value.
    // 
    // The returned pointer points to:
    // 
    // - if the value is an `Array`, the first element of the array,
    // - if the value is a struct, the first field,
    // - if the value is an union, the data field (not the tag field).
    // 
    // The difference from `boxed_to_retained_ptr` is that this function returns a pointer to region where the payload of a boxed value is stored;
    // on the other hand, `boxed_to_retained_ptr` returns a pointer to the boxed value itself (which currently points to the reference counter of the boxed value).
    // 
    // It is not allowed to mutate a boxed value through the borrowed pointer. If you want to do so, use `mutate_boxed`.
    // 
    // See also: `borrow_boxed_io`, `mutate_boxed`, `mutate_boxed_io`.
    // 
    // # Parameters
    // 
    // * `borrower` - The action to be performed on the pointer.
    // * `value` - The boxed value to be borrowed.
    borrow_boxed : [a : Boxed] (Ptr -> b) -> a -> b;
    borrow_boxed = |act, val| val.with_retained(|val| act(val._get_boxed_ptr));

    // Performs an IO action borrowing a pointer to the data of a boxed value.
    // 
    // For the details of the pointer, see the document of `borrow_boxed`.
    //
    // It is not allowed to mutate a boxed value through the borrowed pointer. If you want to do so, use `mutate_boxed`.
    // 
    // See also: `borrow_boxed`, `mutate_boxed`, `mutate_boxed_io`.
    // 
    // # Parameters
    // 
    // * `action` - The IO action to be performed on the pointer.
    // * `value` - The boxed value to be borrowed.
    borrow_boxed_io : [a : Boxed] (Ptr -> IO b) -> a -> IO b;
    borrow_boxed_io = |act, val| IO::from_runner $ |ios| val.borrow_boxed(|ptr| (act(ptr).@runner)(ios));

    // Gets errno which is set by C functions.
    get_errno : IO CInt;
    get_errno = FFI_CALL_IO[CInt fixruntime_get_errno()];

    // Sets errno to zero.
    clear_errno : IO ();
    clear_errno = FFI_CALL_IO[() fixruntime_clear_errno()];

    // `Destructor a` is a wrapper type for `a`, which can have a destructor function `a -> IO a`.
    // Just before a value of type `Destructor a` is dropped, the destructor function is called on the contained value, and the value can be modified by the `IO` action.
    // 
    // This type is used to create a Fix's type that wraps a resource allocated by FFI. In such cases, the destructor release the resource by FFI.
    // 
    // NOTE: In the destructor, only IO actions for finalizing the passed value are allowed, and you should not perform other IO actions such as writing standard output.
    // 
    // NOTE: Of course, if the value stored in `Destructor` also exists outside of `Destructor`, the value still exists in the Fix program even after the destructor function is called, 
    // and there is a possibility that the value is used after the destructor function is called.
    type Destructor a = box struct { _value : a, dtor : a -> IO a };    

    namespace Destructor {
        // Borrow the contained value.
        // 
        // `borrow(worker, dtor)` calls `worker` on the contained value captured by `dtor`, and returns the value returned by `worker`.
        // 
        // It is guaranteed that the `dtor` is alive during the call of `worker`.
        // In other words, the `worker` receives the contained value for which the destructor is not called yet.
        // 
        // # Parameters
        // 
        // * `borrower` - The function to be called on the contained value.
        // * `dtor` - The destructor value.
        borrow : (a -> b) -> Destructor a -> b;
        borrow = |worker, dtor| dtor.with_retained(|dtor| worker(dtor.@_value));

        // Performs an IO action borrowing the contained value.
        // 
        // # Parameters
        // 
        // * `action` - The IO action to be performed on the contained value.
        // * `dtor` - The destructor value.
        borrow_io : (a -> IO b) -> Destructor a -> IO b;
        borrow_io = |act, dtor| IO::from_runner $ |ios| dtor.borrow(|val| (act(val).@runner)(ios));

        // Make a destructor value.
        // 
        // # Parameters
        // 
        // * `value` - The value to be wrapped.
        // * `dtor` - The destructor function to be called on the value.
        make : a -> (a -> IO a) -> Destructor a;
        make = |val, dtor| Destructor { _value : val, dtor : dtor };

        // Apply an IO action which mutates the semantics of the value.
        //
        // `dtor.mutate_unique(ctor, action)` applies `action` to `dtor` if `dtor` is unique. 
        // If `dtor` is shared, it creates a new `Destructor` value using `ctor` and applies `action` to the new value.
        // 
        // The `action` is allowed to modify the external resource stored in `dtor` (e.g., if `value` is a pointer, it can modify the value pointed by the pointer).
        // Also, `ctor` should be a "copy constructor" (e.g., memcpy) of the external resource stored in `dtor`.
        // 
        // # Parameters
        //
        // * `clone` - The constructor function of the contained value.
        // * `action` - The action to be performed on the contained value.
        // * `dtor` - The destructor value.
        mutate_unique : (a -> IO a) -> (a -> IO b) -> Destructor a -> (Destructor a, b);
        mutate_unique = |ctr, action, dtor| dtor.mutate_unique_io(ctr, action).unsafe_perform;

        // Apply an IO action which mutates the semantics of the value.
        // 
        // This is similar to `mutate_unique`, but the `ctor` and `action` is executed in the context of the external `IO` context.
        // 
        // # Parameters
        // 
        // * `clone` - The constructor function of the contained value.
        // * `action` - The action to be performed on the contained value.
        // * `dtor` - The destructor value.
        mutate_unique_io : (a -> IO a) -> (a -> IO b) -> Destructor a -> IO (Destructor a, b);
        mutate_unique_io = |ctor, action, dtor| (
            let (unique, dtor) = dtor.unsafe_is_unique;
            if unique {
                let val = dtor.@_value;
                let res = *action(val);
                pure $ (dtor, res)
            } else {
                let val = dtor.@_value;
                let val = *ctor(val);
                let res = *action(val);
                let dtor = Destructor::make(val, dtor.@dtor);
                pure $ (dtor, res)
            }
        );
    }
}

// `IO a` is a type representing I/O actions which return values of type `a`.
type IO a = unbox struct { runner : IOState -> (IOState, a) };

namespace IO {
    // Reads characters from an IOHandle.
    // 
    // If the first argument `upto_newline` is true, this function reads a file upto newline or EOF.
    _read_line_inner : Bool -> IOHandle -> IOFail String;
    _read_line_inner = |upto_newline, handle| (
        IOFail::from_io_result $ do {
            let file_ptr = *handle.get_file_ptr;
            if file_ptr == nullptr {
                pure $ Result::err("`Std::IO::_read_line_inner` failed!: the IOHandle is already closed.")
            };
            loop_m("", |str|
                let buf_size = 1024;
                let buf = Array::empty(buf_size);
                let (buf, fgets_res) = *buf.mutate_boxed_io(|buf_ptr| (
                    FFI_CALL_IO[Ptr fgets(Ptr, I32, Ptr), buf_ptr, buf_size.to_I32, file_ptr]
                ));
                if fgets_res == nullptr {
                    let err = *FFI_CALL_IO[I32 ferror(Ptr), file_ptr];
                    if err != 0_I32 { 
                        let err = "`Std::IO::_read_line_inner` failed!: an error occurred in `fgets`.";
                        break_m $ Result::err(err)
                    } else {
                        break_m $ Result::ok(str)
                    }
                };
                let str = str + String::_unsafe_from_c_str(buf);
                if upto_newline {
                    // If the last character is \n, break.
                    let last_byte = str.get_last_byte.as_some;
                    if last_byte == '\n' { 
                        break_m $ Result::ok(str)
                    };
                    continue_m $ str
                } else {
                    continue_m $ str
                }
            )
        }
    );

    // Closes a file.
    // 
    // Unlike C's `fclose`, closing an already closed `IOHandle` is safe and does nothing.
    // 
    // # Parameters
    // 
    // * `handle` - The IOHandle to be closed.
    close_file : IOHandle -> IO ();
    close_file = |handle| handle.@_data.borrow_io(|handle_ptr| FFI_CALL_IO[() fixruntime_iohandle_close(Ptr), handle_ptr]);

    // Prints a string to stderr.
    // 
    // # Parameters
    // 
    // * `msg` - The string to be printed.
    eprint : String -> IO ();
    eprint = |str| str.borrow_c_str_io(|c_str| FFI_CALL_IO[I32 fputs(Ptr, Ptr), c_str, *stderr.get_file_ptr]);; pure();

    // Prints a string followed by a newline to stderr.
    // 
    // # Parameters
    // 
    // * `msg` - The string to be printed.
    eprintln : String -> IO ();
    eprintln = |str| eprint(str + "\n");

    // Exits the program with an error code.
    // 
    // # Parameters
    // 
    // * `code` - The error code to be returned.
    exit : I64 -> IO a;
    exit = |code| FFI_CALL_IO[() exit(I32), code.to_I32];; pure $ undefined("");

    // Exits the program with an error message and an error code.
    //  
    // The error message is written to the standard error output.
    // 
    // # Parameters
    // 
    // * `code` - The error code to be returned.
    // * `msg` - The error message to be printed.
    exit_with_msg : I64 -> String -> IO a;
    exit_with_msg = |code, msg| eprintln(msg);; exit(code);

    // Flushes an `IOHandle`.
    // 
    // # Parameters
    // * `handle` - The `IOHandle` to be flushed.
    flush : IOHandle -> IO I32;
    flush = |handle| (
        let file_ptr = *handle.get_file_ptr;
        let res = *FFI_CALL_IO[I32 fflush(Ptr), file_ptr];
        res.to_I32.pure
    );

    // Creates an IO action from a IO runner function, which is a function of type `IOState -> (IOState, a)`.
    // 
    // # Parameters
    //
    // * `io_runner` - The IO runner function.
    from_runner : (IOState -> (IOState, a)) -> IO a;
    from_runner = |runner| IO { runner : runner };

    // `get_arg(i)` returns the i-th (0-indexed) command line argument.
    // 
    // If i is greater than or equal to the number of command line arguments, this function returns none.
    // 
    // # Parameters
    // 
    // * `i` - The index of the command line argument.
    get_arg : I64 -> IO (Option String);
    get_arg = |n| (
        let argc = *get_arg_count;
        if n >= argc { pure $ Option::none() };
        let arg_ptr = *(FFI_CALL_IO[Ptr fixruntime_get_argv(I64), n]);
        pure $ Option::some(String::_unsafe_from_c_str_ptr(arg_ptr))
    );

    // Gets the number of command line arguments.
    get_arg_count : IO I64;
    get_arg_count = (
        let argc = *(FFI_CALL_IO[I32 fixruntime_get_argc()]);
        pure $ argc.to_I64
    );

    // Gets command line arguments.
    get_args : IO (Array String);
    get_args = (
        let argc = *get_arg_count;
        let args = Array::empty(argc);
        loop_m((args, 0), |(args, idx)| (
            if idx == argc { break_m $ args };
            let arg = (*get_arg(idx)).as_some;
            continue_m $ (args.push_back(arg), idx + 1)
        ))
    );

    // Reads a line from stdin. 
    //
    // This function's return value contains a newline code.
    // 
    // If an error occurs while reading from stdin, this function exits the program.
    // If you want to handle errors, use `read_line(stdin)` instead.
    input_line : IO String;
    input_line = (
        let res = *read_line(stdin).to_result;
        if res.is_ok {
            pure $ res.as_ok
        } else {
            pure $ undefined(res.as_err.to_string)
        }
    );

    // Reads a line from stdin. 
    //
    // This function strips the newline code at the end of the line.
    // 
    // If an error occurs while reading from stdin, this function exits the program.
    // If you want to handle errors, use `read_line(stdin)` instead.
    input_line_s : IO String;
    input_line_s = (
        let line = *input_line;
        pure $ line.strip_last_newlines
    );

    // Checks if an `IOHandle` reached to the EOF.
    // 
    // # Parameters
    // 
    // * `handle` - The IOHandle to be checked.
    is_eof : IOHandle -> IO Bool;
    is_eof = |handle| FFI_CALL_IO[I32 feof(Ptr), *handle.get_file_ptr].map(|res| res != 0_I32);

    // Loop on lines read from an `IOHandle`.
    // 
    // `loop_lines(handle, initial_state, worker)` calls `worker` on the pair of current state and a line string read from `handle`.
    // The function `worker` should return an updated state as `LoopState` value, i.e., a value created by `continue` or `break`.
    // When the `handle` reaches to the EOF or `worker` returns a `break` value, `loop_lines` returns the last state value.
    // 
    // Note that the line string passed to `worker` may contain a newline code at the end. To remove it, use `String::strip_last_spaces`.
    // 
    // # Parameters
    // 
    // * `handle` - The IOHandle to be read.
    // * `s0` - The initial state.
    // * `work` - The function to be called on the pair of current state and a line string read from `handle`.
    loop_lines : IOHandle -> s -> (s -> String -> LoopState s s) -> IOFail s;
    loop_lines = |handle, state, worker| (
        if *is_eof(handle).lift {
            pure $ state
        };
        let line = *read_line(handle);
        let res = worker(state, line);
        if res.is_break {
            pure $ res.as_break
        };
        let next_state = res.as_continue;
        loop_lines(handle, next_state, worker)
    );

    // Loop on lines read from an `IOHandle`.
    // 
    // Similar to `loop_lines`, but the worker function can perform an IO action.
    // 
    // # Parameters
    //
    // * `handle` - The IOHandle to be read.
    // * `s0` - The initial state.
    // * `work` - The function to be called on the pair of current state and a line string read from `handle`.
    loop_lines_io : IOHandle -> s -> (s -> String -> IOFail (LoopState s s)) -> IOFail s;
    loop_lines_io = |handle, state, worker| (
        if *is_eof(handle).lift {
            pure $ state
        };
        let line = *read_line(handle);
        let res = *worker(state, line);
        if res.is_break {
            pure $ res.as_break
        };
        let next_state = res.as_continue;
        loop_lines_io(handle, next_state, worker)
    );

    // Openes a file. The second argument is a mode string for `fopen` C function.
    // 
    // # Parameters
    //
    // * `path` - The path to the file to be opened.
    // * `mode` - The mode string for `fopen` C function.
    open_file : Path -> String -> IOFail IOHandle;
    open_file = |path, mode| (
        let path = path.to_string;
        IOFail::from_io_result $ path.borrow_c_str_io(|path_ptr| mode.borrow_c_str_io(|mode_ptr|
            let file_ptr = *FFI_CALL_IO[Ptr fopen(Ptr, Ptr), path_ptr, mode_ptr];
            if file_ptr == nullptr { 
                pure $ Result::err $ "Failed to open a file: " + path
            } else {
                pure $ Result::ok $ IOHandle::from_file_ptr $ file_ptr
            }
        ))
    );

    // Prints a string to stdout.
    // 
    // # Parameters
    //
    // * `msg` - The string to be printed.
    print : String -> IO ();
    print = |str| str.borrow_c_str_io(|c_str| FFI_CALL_IO[I32 fputs(Ptr, Ptr), c_str, *stdout.get_file_ptr]);; pure();

    // Prints a string followed by a newline to stdout.
    // 
    // # Parameters
    //
    // * `msg` - The string to be printed.
    println : String -> IO ();
    println = |str| print(str + "\n");

    // Raads all characters from a file.
    // 
    // # Parameters
    //
    // * `path` - The path to the file to be read.
    read_file_string : Path -> IOFail String;
    read_file_string = |path| with_file(path, "r", read_string);

    // Reads all bytes from a file.
    // 
    // # Parameters
    //
    // * `path` - The path to the file to be read.
    read_file_bytes : Path -> IOFail (Array U8);
    read_file_bytes = |path| with_file(path, "r", read_bytes);

    // Reads characters from a IOHandle upto newline or EOF.
    // The returned string may include newline at its end.
    // 
    // # Parameters
    // 
    // * `handle` - The IOHandle to be read.
    read_line : IOHandle -> IOFail String;
    read_line = _read_line_inner(true);

    // Reads all bytes from an IOHandle.
    // 
    // # Parameters
    // 
    // * `handle` - The IOHandle to be read.
    read_bytes : IOHandle -> IOFail (Array U8);
    read_bytes = |handle| (
        // Get all bytes into an array of buffers.
        let (bufs, len) = *loop_m(([], 0), |(bufs, len)| (
            let buf = *read_n_bytes(handle, 1024);
            if buf.is_empty {
                break_m $ (bufs, len)
            } else {
                continue_m $ (bufs.push_back(buf), len + buf.get_size)
            }
        ));
        // Concatenate all buffers.
        let res = Array::empty(len);
        pure $ bufs.to_iter.fold(res, |bytes, res| res.append(bytes))
    );

    // Reads at most n bytes from an IOHandle.
    // 
    // # Parameters
    //
    // * `handle` - The IOHandle to be read.
    // * `num_bytes` - The number of bytes to be read.
    read_n_bytes : IOHandle -> I64 -> IOFail (Array U8);
    read_n_bytes = |handle, n| IOFail::from_io_result $ do {
        // Get the file pointer.
        let file_ptr = *handle.get_file_ptr;

        // Read n bytes into a buffer.
        let buf = Array::empty(n);
        let (buf, len) = buf.mutate_boxed(|buf| FFI_CALL_IO[I64 fread(Ptr, I64, I64, Ptr), buf, 1, n, file_ptr]);

        // Check error.
        let err = *FFI_CALL_IO[I32 ferror(Ptr), file_ptr];
        if err != 0_I32 { 
            let err = "`Std::IO::read_n_bytes` failed!: Some error occurred in `fread`.";
            pure $ Result::err(err)
        };

        // Return the result.
        let buf = buf._unsafe_set_size(len);
        pure $ Result::ok(buf)
    };

    // Reads all characters from an IOHandle.
    // 
    // # Parameters
    //
    // * `handle` - The IOHandle to be read.
    read_string : IOHandle -> IOFail String;
    read_string = _read_line_inner(false);

    // The handle for standard error.
    stderr : IOHandle;
    stderr = (
        // This implementation is not good because it calls a function with side effects, fdopen, in a pure function.
        // However, the current implementation works because global values are cached and not inlined.
        let ptr = "a".borrow_c_str(|mode| FFI_CALL[Ptr fdopen(I32, Ptr), 2_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // The handle for standard input.
    stdin : IOHandle;
    stdin = (
        // This implementation is not good because it calls a function with side effects, fdopen, in a pure function.
        // However, the current implementation works because global values are cached and not inlined.
        let ptr = "r".borrow_c_str(|mode| FFI_CALL[Ptr fdopen(I32, Ptr), 0_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // The handle for standard output.
    stdout : IOHandle;
    stdout = (
        // This implementation is not good because it calls a function with side effects, fdopen, in a pure function.
        // However, the current implementation works because global values are cached and not inlined.
        let ptr = "a".borrow_c_str(|mode| FFI_CALL[Ptr fdopen(I32, Ptr), 1_I32, mode]);
        IOHandle::from_file_ptr $ ptr
    );

    // Performs a function with a file handle. The second argument is a mode string for `fopen` C function. 
    // 
    // The file handle will be closed automatically.
    // 
    // # Parameters
    //
    // * `path` - The path to the file to be opened.
    // * `mode` - The mode string for `fopen` C function.
    // * `work` - The function to be called on the opened file handle.
    with_file : Path -> String -> (IOHandle -> IOFail a) -> IOFail a;
    with_file = |path, mode, action| (
        let handle = *open_file(path, mode);
        let res = *action(handle);
        IOFail::lift(close_file(handle));;
        pure $ res
    );

    // Writes a byte array into an IOHandle.
    // 
    // # Parameters
    // 
    // * `handle` - The IOHandle to be written.
    // * `array` - The byte array to be written.
    write_bytes : IOHandle -> Array U8 -> IOFail ();
    write_bytes = |handle, array| IOFail::from_io_result $ do {
        let file_ptr = *handle.get_file_ptr;
        let arr_size = array.get_size;
        array.borrow_boxed_io(|array_buf|
            let written = *FFI_CALL_IO[I64 fwrite(Ptr, I64, I64, Ptr), array_buf, 1, arr_size, file_ptr];
            if written < arr_size { pure $ Result::err $ "`Std::IO::write_bytes` failed!: some error occurred in `fwrite`." };
            pure $ Result::ok()
        )
    };

    // Writes a byte array into a file.
    // 
    // # Parameters
    //
    // * `path` - The path to the file to be written.
    // * `content` - The byte array to be written.
    write_file_bytes : Path -> Array U8 -> IOFail ();
    write_file_bytes = |path, content| with_file(path, "w", |handle| write_bytes(handle, content));

    // Writes a string into a file.
    // 
    // # Parameters
    //
    // * `path` - The path to the file to be written.
    // * `content` - The string to be written.
    write_file_string : Path -> String -> IOFail ();
    write_file_string = |path, content| with_file(path, "w", |handle| write_string(handle, content));

    // Writes a string into an IOHandle.
    // 
    // # Parameters
    //
    // * `handle` - The IOHandle to be written.
    // * `content` - The string to be written.
    write_string : IOHandle -> String -> IOFail ();
    write_string = |handle, content| IOFail::from_io_result $ do {
        let file_ptr = *handle.get_file_ptr;
        content.borrow_c_str_io(|c_str|
            let res = *FFI_CALL_IO[I32 fputs(Ptr, Ptr), c_str, file_ptr];
            if res < 0_I32 { pure $ Result::err $ "`Std::IO::write_string` failed!: some error occurred in fputs." };
            pure $ Result::ok()
        )
    };
}

impl IO : Functor {
    map = |f, io| IO::from_runner $ |iostate| (
        let (iostate, a) = (io.@runner)(iostate);
        (iostate, f(a))
    );
}

impl IO : Monad {
    pure = |v| IO { runner : |iostate| (iostate, v) };
    bind = |f, io| (
        IO::from_runner $ |iostate| (
            let (iostate, a) = (io.@runner)(iostate);
            (f(a).@runner)(iostate)
        )
    );
}

namespace IO {
    // A handle type for read / write operations on files, stdin, stdout, stderr.
    // 
    // You can create `IOHandle` value by `IO::open_file`, and close it by `IO::close_file`. 
    // There are also global `IO::IOHandle::stdin`, `IO::IOHandle::stdout`, `IO::IOHandle::stderr`.
    // 
    // `IOHandle` is different from C's `FILE` structure in that it is safe to close it twice.
    // If you try to get a file pointer by `file_ptr` from a closed `IOHandle`, you will get `nullptr`.
    //
    // NOTE: 
    // `IOHandle` is implemented by `Destructor`, but the destructor function does not close the file pointer.
    // (The destructor function only frees the management memory area.)
    // You should explicitly close the file pointer by `IO::close_file`.
    type IOHandle = unbox struct { _data : Destructor Ptr };
}

namespace IO::IOHandle {
    // Gets pointer to C's `FILE` value from an `IOHandle`.
    //
    // If the `IOHandle` is already closed, the function returns `nullptr`.
    // 
    // NOTE: 
    // Do not directly close the file pointer by `fclose` or other functions.
    // Instead you should close `IOHandle` by `IO::close_file`.
    //
    // DEPRECATED: 
    // Use `get_file_ptr` instead.
    // This function is deprecated because it has a pure function interface, but the value of `_file_ptr` changes by calling `IO::close_file`.
    _file_ptr : IOHandle -> Ptr;
    _file_ptr = |handle| handle.@_data.borrow(|handle_ptr| FFI_CALL[Ptr fixruntime_iohandle_get_file(Ptr), handle_ptr]);

    // Gets pointer to C's `FILE` value from an `IOHandle`.
    //
    // If the `IOHandle` is already closed, the function returns `nullptr`.
    // 
    // NOTE: 
    // Do not directly close the file pointer by `fclose` or other functions.
    // Instead you should close `IOHandle` by `IO::close_file`.
    // 
    // NOTE: 
    // If `IO::close` is called while using the `Ptr` obtained by this function, the `Ptr` becomes invalid and may cause undefined behavior.
    //
    // # Parameters
    //
    // * `handle` - The IOHandle to get the file pointer from.
    get_file_ptr : IOHandle -> IO Ptr;
    get_file_ptr = |handle| handle.@_data.borrow_io(|handle_ptr| FFI_CALL_IO[Ptr fixruntime_iohandle_get_file(Ptr), handle_ptr]);

    // Creates an `IOHandle` from a file pointer (i.e., pointer to C's `FILE`).
    // 
    // Creating two `IOHandle`s from a single file pointer is forbidden.
    // 
    // # Parameters
    // 
    // * `file_ptr` - The file pointer to be wrapped.
    from_file_ptr : Ptr -> IOHandle;
    from_file_ptr = |file_ptr| (
        let handle_ptr = FFI_CALL[Ptr fixruntime_iohandle_create(Ptr), file_ptr];
        let dtor = |handle_ptr| FFI_CALL_IO[() fixruntime_iohandle_delete(Ptr), handle_ptr];; pure $ nullptr;
        IOHandle { _data : Destructor::make(handle_ptr, dtor) }
    );
}

namespace IO {
    // The type for I/O actions which may fail.
    type IOFail a = unbox struct { _data : IO (Result ErrMsg a) };
}

namespace IO::IOFail {
    // Create from IO action of which returns `Result ErrMsg a`.
    // 
    // # Parameters
    //
    // * `io_res` - The IO action to be converted.
    from_io_result : IO (Result ErrMsg a) -> IOFail a;
    from_io_result = |io_res| IOFail { _data : io_res };

    // Creates an pure `IOFail` value from a `Result` value.
    // 
    // # Parameters
    // 
    // * `res` - The result value to be converted.
    from_result : Result ErrMsg a -> IOFail a;
    from_result = |res| IOFail { _data : pure(res) };

    // Lifts an `IO` action to a successful `IOFail` action.
    // 
    // # Parameters
    //
    // * `io` - The IO action to be lifted.
    lift : IO a -> IOFail a;
    lift = |io| IOFail { _data : io.map(pure) };

    // Creates an error `IOFail` action.
    // 
    // # Parameters
    //
    // * `err_msg` - The error message to be thrown.
    throw : ErrMsg -> IOFail a;
    throw = |e| from_result $ Result::err(e);

    // Converts an `IOFail` to an `Result` value (wrapped by `IO`).
    //
    // # Parameters
    //
    // * `io_fail` - The `IOFail` value to be converted.
    to_result : IOFail a -> IO (Result ErrMsg a);
    to_result = @_data;

    // Converts an `IOFail` value to an `IO` value by an error handler (i.e., a `catch`) function.
    // 
    // # Parameters
    // 
    // * `catch` - The error handler function to be called on the error.
    // * `io_fail` - The `IOFail` value to be run.
    try : (ErrMsg -> IO a) -> IOFail a -> IO a;
    try = |catch, iof| (
        let res = *iof.to_result;
        if res.is_ok { pure $ res.as_ok } else { catch(res.as_err) }
    );
}

impl IOFail : Functor {
    map = |f, iof| IOFail { _data : iof.@_data.map(map(f)) };
}

impl IOFail : Monad {
    pure = |v| IOFail { _data : pure(pure(v)) };
    bind = |f, iof| IOFail { _data : do {
        let res = *iof.@_data;
        if res.is_err { pure $ Result::err $ res.as_err };
        f(res.as_ok).@_data
    }};
}

// The trait of iterators.
// 
// Iterator is a concept of a sequence of elements that can be iterated.
// More precisely, an iterator is a type whose data is "the current state" and has a method `advance` which returns the next element and the next state.
trait iter : Iterator {
    type Item iter;
    advance : iter -> Option (iter, Item iter);
}

namespace Iterator {
    /*
        Folding and looping.
    */

    // Fold the elements of an iterator from left to right.
    //
    // Conceptually, `[a0, a1, a2, ...].to_iter.fold(s, op) = s.op(a0).op(a1).op(a2)...`.
    // 
    // # Parameters
    //
    // * `s` - The initial state.
    // * `body` - The function to be called on the pair of an element and the current state.
    // * `iter` - The iterator to be folded.
    fold : [iter : Iterator, Item iter = a] s -> (a -> s -> s) -> iter -> s;
    fold = |s, op, iter| (
        match iter.advance {
            none() => s,
            some((iter, a)) => iter.fold(op(a, s), op)
        }
    );

    // Fold the elements of an iterator from left to right by monadic action.
    // 
    // # Parameters
    //
    // * `s` - The initial state.
    // * `body` - The function to be called on the pair of an element and the current state.
    // * `iter` - The iterator to be folded.
    fold_m : [m : Monad, iter : Iterator, Item iter = a] s -> (a -> s -> m s) -> iter -> m s;
    fold_m = |s, op, iter| (
        match iter.advance {
            none() => pure(s),
            some((iter, a)) => op(a, s).bind(|s| iter.fold_m(s, op))
        }
    );

    // Loop over the elements of an iterator.
    // 
    // This function is similar to `fold` but a more general version of it. It allows the user to break out of the loop at any point.
    // 
    // # Parameters
    //
    // * `s` - The initial state.
    // * `body` - The function to be called on the pair of an element and the current state.
    // * `iter` - The iterator to be looped.
    loop_iter : [iter : Iterator, Item iter = a] s -> (a -> s -> LoopState s s) -> iter -> s;
    loop_iter = |s, body, iter| (
        match iter.advance {
            none() => s,
            some((iter, a)) => match body(a, s) {
                break(s) => s,
                continue(s) => iter.loop_iter(s, body),
            }
        }
    );

    // Loop over the elements of an iterator.
    // 
    // This function is similar to `loop_iter`, but it returns a `LoopState`. 
    // This allows you to return different types for `break` and `continue`.
    // 
    // Added in v1.1.0.
    // 
    // # Parameters
    //
    // * `s` - The initial state.
    // * `body` - The function to be called on the pair of an element and the current state.
    // * `iter` - The iterator to be looped.
    loop_iter_s : [iter : Iterator, Item iter = a] s -> (a -> s -> LoopState s b) -> iter -> LoopState s b;
    loop_iter_s = |s, body, iter| (
        match iter.advance {
            none() => continue(s),
            some((iter, a)) => match body(a, s) {
                break(s) => break(s),
                continue(s) => iter.loop_iter_s(s, body),
            }
        }
    );

    // Loop over the elements of an iterator by monadic action.
    // 
    // # Parameters
    //
    // * `s` - The initial state.
    // * `body` - The function to be called on the pair of an element and the current state.
    // * `iter` - The iterator to be looped.
    loop_iter_m : [m : Monad, iter : Iterator, Item iter = a] s -> (a -> s -> m (LoopState s s)) -> iter -> m s;
    loop_iter_m = |s, body, iter| (
        match iter.advance {
            none() => pure(s),
            some((iter, a)) => body(a, s).bind(|state| match state {
                break(s) => pure(s),
                continue(s) => iter.loop_iter_m(s, body),
            })
        }
    );

    // Loop over the elements of an iterator by monadic action.
    //
    // This function is similar to `loop_iter_s`, but it returns a `LoopState`.
    // This allows you to return different types for `break_m` and `continue_m`.
    //
    // Added in v1.1.0.
    // 
    // # Parameters
    //
    // * `s` - The initial state.
    // * `body` - The function to be called on the pair of an element and the current state.
    // * `iter` - The iterator to be looped.
    loop_iter_ms : [m : Monad, iter : Iterator, Item iter = a] s -> (a -> s -> m (LoopState s b)) -> iter -> m (LoopState s b);
    loop_iter_ms = |s, body, iter| (
        match iter.advance {
            none() => pure(continue(s)),
            some((iter, a)) => body(a, s).bind(|state| match state {
                break(s) => pure(break(s)),
                continue(s) => iter.loop_iter_ms(s, body),
            })
        }
    );

    // Executes monadic actions and collects the results into an array.
    //
    // # Parameters
    //
    // * `iter` - The iterator of monads to be collected.
    collect_m : [m : Monad, iter : Iterator, Item iter = m a] iter -> m (Array a);
    collect_m = |iter| iter.fold_m([], |act, acm| pure $ acm.push_back(*act));

    // Calcculate sum of the elements of an iterator.
    //
    // # Parameters
    //
    // * `iter` - The iterator of elements to be summed.
    sum : [iter : Iterator, Item iter = a, a : Additive] iter -> a;
    sum = |iter| iter.fold(zero, |a, acc| acc + a);

    // Compare two iterators by their elements.
    //
    // # Parameters
    //
    // * `iter1` - The first iterator to be compared.
    // * `iter2` - The second iterator to be compared.
    is_equal : [iter1 : Iterator, iter2 : Iterator, Item iter1 = a, Item iter2 = a, a : Eq] iter1 -> iter2 -> Bool;
    is_equal = |iter1, iter2| (
        match iter1.advance {
            none() => match iter2.advance {
                none() => true,
                some(_) => false
            },
            some((iter1, a1)) => match iter2.advance {
                none() => false,
                some((iter2, a2)) => a1 == a2 && iter1.is_equal(iter2)
            }
        }
    );

    /*
        Conversion to arrays.
    */

    // Convert an iterator to an array.
    // 
    // # Parameters
    //
    // * `iter` - The iterator to be converted.
    to_array : [iter : Iterator, Item iter = a] iter -> Array a;
    to_array = |iter| iter.fold([], |a, acc| acc.push_back(a));

    // Create an iterator from an array.
    // 
    // # Parameters
    //
    // * `array` - The array to be converted to an iterator.
    from_array : Array a -> ArrayIterator a;
    from_array = |arr| ArrayIterator { arr: arr, idx: 0 };

    // Iterators that yields elements of an array.
    type ArrayIterator a = unbox struct { arr : Array a, idx : I64 };

    impl ArrayIterator a : Iterator {
        type Item (ArrayIterator a) = a;
        advance = |ArrayIterator { arr : arr, idx : idx }| (
            if idx == arr.get_size { none() };
            let v = arr.@(idx);
            some((ArrayIterator { arr: arr, idx: idx + 1 }, v))
        );
    }

    // Convert any iterator to an array iterator.
    // 
    // All elements of the input iterator are collected into an array. Therefore, this function may consume a lot of memory.
    // On the other hand, iteration may be faster by banging.
    //
    // # Parameters
    //
    // * `iter` - The iterator.
    bang : [iter : Iterator, Item iter = a] iter -> ArrayIterator a;
    bang = |iter| iter.to_array.to_iter;

    /*
        Basic iterators.
    */

    // Iterators that yields no elements.
    type EmptyIterator a = unbox struct {};
    impl EmptyIterator a : Iterator {
        type Item (EmptyIterator a) = a;
        advance = |_| none();
    }

    // An iterator that yields no elements.
    // 
    // NOTE: When using this iterator, you may need to specify the type of the iterator explicitly, e.g, `(empty : EmptyIterator I64)`.
    empty : EmptyIterator a;
    empty = EmptyIterator {};

    // Iterators that yields reversed elements of an iterator.
    type RangeIterator = unbox struct { next : I64, end : I64 };

    impl RangeIterator : Iterator {
        type Item RangeIterator = I64;
        advance = |RangeIterator { next : next, end : end }| (
            if next == end { Option::none() }
            else { Option::some $ (RangeIterator { next: next + 1, end: end }, next) }
        );
    }

    // Create an iterator that generates a range of numbers.
    // 
    // `range(a, b)` generates a range of numbers from `a` to `b - 1`.
    // 
    // If `a` is greater than or equal to `b`, the iterator will an empty iterator.
    // 
    // # Parameters
    //
    // * `start` - The start of the range.
    // * `end` - The end of the range.
    range : I64 -> I64 -> RangeIterator;
    range = |start, end| (
        if start >= end {
            RangeIterator { next: start, end: start } // Return an empty iterator.
        };
        RangeIterator { next: start, end: end }
    );

    type RangeStepIterator = unbox struct { next : I64, end : I64, step : I64 };

    impl RangeStepIterator : Iterator {
        type Item RangeStepIterator = I64;
        advance = |RangeStepIterator { next : next, end : end, step : step }| (
            if next == end { Option::none() }
            else { Option::some $ (RangeStepIterator { next: next + step, end: end, step: step }, next) }
        );
    }

    // Create an iterator that generates a range of numbers with a step.
    // 
    // # Parameters
    //
    // * `start` - The start of the range.
    // * `end` - The end of the range.
    // * `step` - The step of the range.
    range_step : I64 -> I64 -> I64 -> RangeStepIterator;
    range_step = |start, end, step| (
        if (step > 0 && (start - end) > 0) || (step < 0 && (start - end) < 0) {
            RangeStepIterator { next: start, end: start, step: step } // Return an empty iterator.
        };
        // Adjust end so that `start + n * step == end` for some integer `n` (when `step` is not 0).
        let end = if step == 0 { 
            undefined("[range_step] step must not be 0!")
        } else if step > 0 {
            // step > 0
            start + (end - start + step - 1) / step * step
        } else {
            // step < 0
            start + (start - end - step - 1) / (-step) * step
        };
        RangeStepIterator { next: start, end: end, step: step }
    );

    type CountUpIterator = unbox struct { next : I64 };

    impl CountUpIterator : Iterator {
        type Item CountUpIterator = I64;
        advance = |CountUpIterator { next : next }| some((CountUpIterator { next: next + 1 }, next));
    }

    // Create an iterator that counts up from a number.
    // 
    // `count_up(start)` generates an infinite sequence of numbers starting from `start`.
    //
    // # Parameters
    //
    // * `start` - The start of the count.
    count_up : I64 -> CountUpIterator;
    count_up = |start| CountUpIterator { next: start };

    type StateIterator s a = unbox struct {
        state : Option s,
        transit : s -> Option (s, a)
    };

    impl StateIterator s a : Iterator {
        type Item (StateIterator s a) = a;    
        advance = |StateIterator { state : s, transit : f }| (
            match s {
                none() => none(),
                some(s) => match f(s) {
                    none() => none(),
                    some((s, a)) => some((generate(s, f), a))
                }
            }
        );
    }

    // Create an iterator that generates elements by the state transition function.
    // 
    // # Parameters
    //
    // * `state` - The initial state.
    // * `transition` - The state transition function that takes the current state and returns the next state and the next element.
    generate : s -> (s -> Option (s, a)) -> StateIterator s a;
    generate = |state, transit| StateIterator { state: some(state), transit: transit };

    // Create an iterator by a function that returns element at each index.
    // 
    // # Parameters
    //
    // * `map` - The function that takes an index and returns the element at that index.
    from_map : (I64 -> a) -> MapIterator CountUpIterator I64 a;
    from_map = |f| count_up(0).map(f);

    /*
        Extract information from iterators.
    */

    // Get the number of elements in an iterator.
    // 
    // # Parameters
    //
    // * `iter` - The iterator to be counted.
    get_size : [iter : Iterator] iter -> I64;
    get_size = |iter| iter.fold(0, |_, acc| acc + 1);

    // Get the first element of an iterator.
    // 
    // If the iterator is empty, this function returns `none`.
    //
    // # Parameters
    //
    // * `iter` - The iterator.
    get_first : [iter : Iterator] iter -> Option (Item iter);
    get_first = |iter| iter.advance.map(|(_, a)| a);

    // Get the tail of an iterator.
    // 
    // If the iterator is empty, this function returns `none`.
    // 
    // # Parameters
    //
    // * `iter` - The iterator.
    get_tail : [iter : Iterator] iter -> Option iter;
    get_tail = |iter| iter.advance.map(|(iter, _)| iter);

    // Remove the first element of an iterator.
    // 
    // If the iterator is empty, this function does nothing.
    //
    // # Parameters
    //
    // * `iter` - The iterator.
    pop_first : [iter : Iterator] iter -> iter;
    pop_first = |iter| (
        match iter.advance {
            none() => iter,
            some((iter, _)) => iter
        }
    );

    // Is an iterator empty?
    //
    // # Parameters
    //
    // * `iter` - The iterator.
    is_empty : [iter : Iterator] iter -> Bool;
    is_empty = |iter| iter.advance.is_none;

    /*
        Transforming iterators.
    */

    type MapIterator i a b = unbox struct { iter : i, f : a -> b };
    impl [i : Iterator, Item i = a] MapIterator i a b : Iterator {
        type Item (MapIterator i a b) = b;
        advance = |MapIterator { iter : iter, f : f }| (
            match iter.advance {
                none() => none(),
                some((iter, a)) => some((MapIterator { iter: iter, f: f }, f(a)))
            }
        );
    }

    // Map a function over an iterator.
    // 
    // `iter.map(f)` returns an iterator that applies `f` to each element of `iter`.
    //
    // # Parameters
    //
    // * `f` - The function to be applied to each element of the iterator.
    // * `iter` - The iterator to be mapped.
    map : [i : Iterator, Item i = a] (a -> b) -> i -> MapIterator i a b;
    map = |f, iter| MapIterator { iter: iter, f: f };

    type FilterIterator i a = unbox struct { iter : i, pred : a -> Bool };
    impl [i : Iterator, Item i = a] FilterIterator i a : Iterator {
        type Item (FilterIterator i a) = Item i;
        advance = |FilterIterator { iter : iter, pred : pred }| (
            match iter.advance {
                none() => none(),
                some((iter, a)) => if pred(a) { 
                    some((FilterIterator { iter: iter, pred: pred }, a))
                } else {
                    FilterIterator { iter: iter, pred: pred }.advance
                }
            }
        );
    }

    // Filter the elements of an iterator by a predicate.
    // 
    // `iter.filter(pred)` returns an iterator that only yields elements of `iter` for which `pred` returns `true`.
    // 
    // # Parameters
    //
    // * `predicate` - The predicate function to be applied to each element of the iterator.
    // * `iter` - The iterator to be filtered.
    filter : [i : Iterator, Item i = a] (a -> Bool) -> i -> FilterIterator i a;
    filter = |pred, iter| FilterIterator { iter: iter, pred: pred };

    type FilterMapIterator i a b = unbox struct { iter : i, f : a -> Option b };
    impl [i : Iterator, Item i = a] FilterMapIterator i a b : Iterator {
        type Item (FilterMapIterator i a b) = b;
        advance = |FilterMapIterator { iter : iter, f : f }| (
            match iter.advance {
                none() => none(),
                some((iter, a)) => match f(a) {
                    none() => FilterMapIterator { iter: iter, f: f }.advance,
                    some(b) => some((FilterMapIterator { iter: iter, f: f }, b))
                }
            }
        );
    }

    // Filter and map the elements of an iterator.
    // 
    // `iter.filter_map(f)` returns an iterator that applies `f` to each element of `iter` and yields the result if it is `some`.
    // 
    // # Parameters
    //
    // * `f` - The function to be applied to each element of the iterator.
    // * `iter` - The iterator to be filtered and mapped.
    filter_map : [i : Iterator, Item i = a] (a -> Option b) -> i -> FilterMapIterator i a b;
    filter_map = |f, iter| FilterMapIterator { iter: iter, f: f };

    type FlattenIterator i2 i1 = unbox struct { i2 : i2, i1 : Option i1 };
    impl [i2 : Iterator, i1: Iterator, Item i2 = i1] FlattenIterator i2 i1 : Iterator {
        type Item (FlattenIterator i2 i1) = Item i1;
        advance = |FlattenIterator { i2 : i2, i1 : i1 }| (
            match i1 {
                none() => (
                    match i2.advance {
                        none() => none(),
                        some((i2, i1)) => FlattenIterator { i2: i2, i1: some(i1) }.advance
                    }
                ),
                some(i1) => (
                    match i1.advance {
                        none() => FlattenIterator { i2: i2, i1: none() }.advance,
                        some((i1, a)) => some $ (FlattenIterator { i2: i2, i1: some(i1) }, a)
                    }
                )
            }
        );
    }

    // Flatten an iterator of iterators.
    // 
    // # Parameters
    //
    // * `iter_iter` - The iterator of iterators.
    flatten : [i2 : Iterator, i1 : Iterator, Item i2 = i1] i2 -> FlattenIterator i2 i1;
    flatten = |i2| FlattenIterator { i2: i2, i1: none() };

    type FlatMapIterator i1 a i2 = FlattenIterator (MapIterator i1 a i2) i2;

    // Apply a function to each element of an iterator and flatten the result.
    //
    // # Parameters
    //
    // * `f` - The function to be applied to each element of the iterator.
    // * `iter` - The iterator.
    flat_map : [i1 : Iterator, Item i1 = a, i2 : Iterator, Item i2 = b] (a -> i2) -> i1 -> FlatMapIterator i1 a i2;
    flat_map = |f, iter| iter.map(f).flatten;

    type ProductIterator i1 i2 a b = unbox struct { iter1 : i1, iter2 : i2, e2 : Option b, iter1_org : i1 };
    impl [i1 : Iterator, i2 : Iterator, Item i1 = a, Item i2 = b] ProductIterator i1 i2 a b : Iterator {
        type Item (ProductIterator i1 i2 a b) = (Item i1, Item i2);
        advance = |ProductIterator { iter1 : iter1, iter2 : iter2, e2 : e2, iter1_org : iter1_org }| (
            match e2 {
                some(e2) => (
                    match iter1.advance {
                        some((iter1, e1)) => some $ (ProductIterator { iter1: iter1, iter2: iter2, e2: some(e2), iter1_org : iter1_org }, (e1, e2)),
                        none() => match iter2.advance {
                            none() => none(),
                            some((iter2, e2)) => ProductIterator { iter1: iter1_org, iter2: iter2, e2: some(e2), iter1_org : iter1_org }.advance
                        },
                    }
                ),
                none() => (
                    match iter2.advance {
                        none() => none(),
                        some((iter2, e2)) => ProductIterator { iter1: iter1, iter2: iter2, e2: some(e2), iter1_org : iter1_org }.advance
                    }
                ),
            }
        );
    }

    // Create an iterator that yields the Cartesian product of two iterators.
    // 
    // NOTE: Since this function is designed so that `iter1.product(iter2)` yields the Cartesian product, the elements of `product(iter2, iter1)` are in the opposite order.
    // 
    // Example:
    // ```
    // assert_eq(|_|"", range(1, 4).product(['a', 'b'].from_array).to_array, [(1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b')]);;
    // ```
    //
    // # Parameters
    //
    // * `second` - The second iterator.
    // * `first` - The first iterator.
    product : [i1 : Iterator, i2 : Iterator, Item i1 = a, Item i2 = b] i2 -> i1 -> ProductIterator i1 i2 a b;
    product = |iter2, iter1| ProductIterator { iter1: iter1, iter2: iter2, e2: none(), iter1_org: iter1 };

    type AppendIterator i1 i2 = unbox struct { iter1 : Option i1, iter2 : i2 };

    impl [i1 : Iterator, i2 : Iterator, Item i1 = a, Item i2 = a] AppendIterator i1 i2 : Iterator {
        type Item (AppendIterator i1 i2) = Item i2;
        advance = |AppendIterator { iter1 : iter1, iter2 : iter2 }| (
            match iter1 {
                none() => (
                    match iter2.advance {
                        none() => none(),
                        some((iter2, a)) => some $ (AppendIterator { iter1: none(), iter2: iter2 }, a)
                    }
                ),
                some(iter1) => (
                    match iter1.advance {
                        none() => AppendIterator { iter1: none(), iter2: iter2 }.advance,
                        some((iter1, a)) => some $ (AppendIterator { iter1: some(iter1), iter2: iter2 }, a)
                    }
                )
            }
        );
    }

    // Append two iterators.
    // 
    // NOTE: Since this function is designed so that `iter1.append(iter2)` appends `iter2` after `iter1`, `append(iter1, iter2)` appends iterators in the opposite order.
    //
    // # Parameters
    //
    // * `second` - The second iterator.
    // * `first` - The first iterator.
    append : [i1 : Iterator, i2 : Iterator, Item i1 = a, Item i2 = a] i2 -> i1 -> AppendIterator i1 i2;
    append = |iter2, iter1| AppendIterator { iter1 : some(iter1), iter2 : iter2 };

    type IntersperseIterator i a = unbox struct { iter : i, sep : a, next_is_sep : Bool };

    impl [i : Iterator, Item i = a] IntersperseIterator i a : Iterator {
        type Item (IntersperseIterator i a) = a;
        advance = |IntersperseIterator { iter : iter, sep : sep, next_is_sep : next_is_sep }| (
            if next_is_sep {
                some((IntersperseIterator { iter: iter, sep: sep, next_is_sep: false }, sep))
            } else {
                match iter.advance {
                    none() => none(),
                    some((iter, a)) => some((IntersperseIterator { iter: iter, sep: sep, next_is_sep: !iter.is_empty }, a))
                }
            }
        );
    }

    // Intersperse an element between elements of an iterator.
    //
    // Example:
    // ```
    // assert_eq(|_|"", [1, 2, 3].from_array.intersperse(0).to_array, [1, 0, 2, 0, 3]);;
    // ```
    //
    // # Parameters
    //
    // * `sep` - The element to be interspersed.
    // * `iter` - The iterator.
    intersperse : [i : Iterator, Item i = a] a -> i -> IntersperseIterator i a;
    intersperse = |sep, iter| IntersperseIterator { iter: iter, sep: sep, next_is_sep: false };

    type ConsIterator i a = unbox struct { head : Option a, tail : i };
    impl [i : Iterator, Item i = a] ConsIterator i a : Iterator {
        type Item (ConsIterator i a) = a;
        advance = |ConsIterator { head : head, tail : tail }| (
            match head {
                none() => none(),
                some(v) => match tail.advance {
                    none() => some $ (ConsIterator { head: none(), tail: tail }, v),
                    some((tail, a)) => some $ (ConsIterator { head: some(a), tail: tail }, v)
                }
            }
        );
    }

    // Push an element to the front of an iterator.
    //
    // # Parameters
    //
    // * `head` - The element to be pushed.
    // * `tail` - The iterator to be pushed to.
    push_front : [i : Iterator, Item i = a] a -> i -> ConsIterator i a;
    push_front = |head, tail| ConsIterator { head: some(head), tail: tail };

    type ReverseIterator i a = unbox struct { idx : I64, arr : Array a };
    impl [i : Iterator, Item i = a] ReverseIterator i a : Iterator {
        type Item (ReverseIterator i a) = a;
        advance = |ReverseIterator { idx : idx, arr : arr }| (
            if idx == -1 { none() }
            else { some $ (ReverseIterator { idx: idx - 1, arr: arr }, arr.@(idx)) }
        );
    }

    // Reverses an iterator.
    // 
    // NOTE: This function puts all elements of the iterator into an array, so it may consume a lot of memory.
    //
    // # Parameters
    //
    // * `iter` - The iterator to be reversed.
    reverse : [i : Iterator, Item i = a] i -> ReverseIterator i a;
    reverse = |iter| (
        let arr = iter.to_array;
        let n = arr.get_size;
        ReverseIterator { idx: n - 1, arr: arr }
    );

    type TakeIterator i = unbox struct { iter : i, n : I64 };
    impl [i : Iterator] TakeIterator i : Iterator {
        type Item (TakeIterator i) = Item i;
        advance = |TakeIterator { iter : iter, n : n }| (
            if n <= 0 { none() };
            match iter.advance {
                none() => none(),
                some((iter, a)) => some((TakeIterator { iter: iter, n: n - 1 }, a))
            }
        );
    }

    // Take the first `n` elements of an iterator.
    // 
    // # Parameters
    //
    // * `n` - The number of elements to be taken.
    // * `iter` - The iterator to be taken from.
    take : [i : Iterator] I64 -> i -> TakeIterator i;
    take = |n, iter| TakeIterator { iter: iter, n: n };

    type TakeWhileIterator i a = unbox struct { iter : i, pred : a -> Bool };
    impl [i : Iterator, Item i = a] TakeWhileIterator i a : Iterator {
        type Item (TakeWhileIterator i a) = a;
        advance = |TakeWhileIterator { iter : iter, pred : pred }| (
            match iter.advance {
                none() => none(),
                some((iter, a)) => if pred(a) { 
                    some((TakeWhileIterator { iter: iter, pred: pred }, a))
                } else {
                    none()
                }
            }
        );
    }

    // Take elements from an iterator while a predicate holds.
    //
    // # Parameters
    //
    // * `predicate` - The predicate function to be applied to each element of the iterator.
    // * `iter` - The iterator to be taken from.
    take_while : [i : Iterator, Item i = a] (a -> Bool) -> i -> TakeWhileIterator i a;
    take_while = |pred, iter| TakeWhileIterator { iter: iter, pred: pred };

    type ZipIterator i1 i2 = unbox struct { iter1 : i1, iter2 : i2 };
    impl [i1 : Iterator, i2 : Iterator] ZipIterator i1 i2 : Iterator {
        type Item (ZipIterator i1 i2) = (Item i1, Item i2);
        advance = |ZipIterator { iter1 : iter1, iter2 : iter2 }| (
            match iter1.advance {
                none() => none(),
                some((iter1, a)) => match iter2.advance {
                    none() => none(),
                    some((iter2, b)) => some((ZipIterator { iter1: iter1, iter2: iter2 }, (a, b)))
                }
            }
        );
    }

    // Zip two iterators.
    // 
    // NOTE: Since this function is designed so that `iter1.zip(iter2)` zips `iter1` and `iter2`, the elements of `zip(iter2, iter1)` are in the opposite order.
    //
    // # Parameters
    //
    // * `second` - The second iterator.
    // * `first` - The first iterator.
    zip : [i1 : Iterator, i2 : Iterator] i2 -> i1 -> ZipIterator i1 i2;
    zip = |iter2, iter1| ZipIterator { iter1: iter1, iter2: iter2 };

    // Check if all elements of an iterator satisfy a given predicate.
    // 
    // Added in v1.1.0.
    // 
    // # Parameters
    //
    // * `pred` - The predicate function to be applied to each element of the iterator.
    check_all : [it : Iterator, Item it = a] (a -> Bool) -> it -> Bool;
    check_all = |pred, iter| (
        match iter.advance {
            none() => true,
            some((iter, a)) => if pred(a) { iter.check_all(pred) } else { false }
        }
    );

    // Check if any element of an iterator satisfies a given predicate.
    // 
    // Added in v1.1.0.
    //
    // # Parameters
    // 
    // * `pred` - The predicate function to be applied to each element of the iterator.
    check_any : [it : Iterator, Item it = a] (a -> Bool) -> it -> Bool;
    check_any = |pred, iter| (
        match iter.advance {
            none() => false,
            some((iter, a)) => if pred(a) { true } else { iter.check_any(pred) }
        }
    );

    /*
        Dynamic iterator.
    */

    // The type of dynamic iterators.
    // 
    // `DynIterator` has a field, `next`, which is a function that returns the next element and the next iterator.
    // Therefore, the process to advance `DynIterator` can be determined dynamically at runtime, not at compile time.
    // 
    // The main advantage of dynamic iterator is that since it has a simple type, `DynIterator a`,
    // - `DynIterator` can be instances of traits such as `Monad`, `Eq`, etc.
    // - it is possible to return two dynamic iterators with different constructions depending on the branch.
    // 
    // However, iterating over `DynIterator` are much slower than iterating over other iterators provided in this namespace.
    // Therefore, if performance is important, you should avoid using `DynIterator`.
    // In particular, if you iterate over the same `DynIterator` multiple times,
    // consider converting it to an `ArrayIterator` using `bang` before iterating.
    type DynIterator a = unbox struct { next: () -> Option (DynIterator a, a) };

    // Convert an iterator into a dynamic iterator.
    //
    // # Parameters
    //
    // * `iter` - The iterator to be converted.
    to_dyn : [iter : Iterator, Item iter = a] iter -> DynIterator a;
    to_dyn = |iter| DynIterator { next: |_| iter.advance.map(|(iter, elm)| (iter.to_dyn, elm)) };

    impl DynIterator a : Iterator {
        type Item (DynIterator a) = a;
        advance = |iter| (iter.@next)();
    }

    namespace DynIterator {
        // Creates an empty dynamic iterator.
        empty : DynIterator a;
        empty = DynIterator { next: |_| none() };

        // Creates an empty dynamic iterator.
        impl DynIterator a : Zero {
            zero = DynIterator::empty;
        }

        // Concatenates two dynamic iterators.
        impl DynIterator a : Add {
            add = |lhs, rhs| lhs.append(rhs).to_dyn;
        }

        impl [a : Eq] DynIterator a : Eq {
            eq = |lhs, rhs| lhs.is_equal(rhs);
        }

        impl DynIterator : Functor {
            map = |f, iter| iter.Iterator::map(f).to_dyn;
        }

        impl DynIterator : Monad {
            pure = |e| Iterator::empty.push_front(e).to_dyn;
            bind = |f, xs| xs.Iterator::map(f).flatten.to_dyn;
        }
    }
}

// The type of lazily generated values.
//
// You can create a lazy value by `|_| (...an expression to generate the value...)`, 
// and you can evaluate a lazy value `v` by `v()`.
type Lazy a = () -> a;

namespace LoopState {
    // Make a break value wrapped in a monad.
    // 
    // This is used with `loop_m` function.
    break_m : [m : Monad] r -> m (LoopState s r);
    break_m = break >> pure;

    // Make a continue value wrapped in a monad.
    // 
    // This is used with `loop_m` function.
    continue_m : [m : Monad] s -> m (LoopState s r);
    continue_m = continue >> pure;

}

type Option a = union { none: (), some: a };

namespace Option {

    // Unwrap an option value if it is `some`, or returns given default value if it is `none`.
    //
    // # Parameters
    //
    // * `default` - The default value to be returned if the option is `none`.
    // * `opt` - The option value to be unwrapped.
    as_some_or : a -> Option a -> a;
    as_some_or = |def, opt| (
        if opt.is_none { def } else { opt.as_some }
    );

    // Returns the provided default value if the option is none, or applies a function to the contained value if the option is some.
    //
    // # Parameters
    //
    // * `default` - The default value to be returned if the option is `none`.
    // * `f` - The function to be applied to the contained value if the option is `some`.
    map_or : b -> (a -> b) -> Option a -> b;
    map_or = |def, f, opt| if opt.is_some { f(opt.as_some) } else { def };

    // Converts an option into an iterator.
    to_iter : Option a -> OptionIterator (Option a);
    to_iter = |opt| OptionIterator { opt: opt };

    type OptionIterator opt = unbox struct { opt : opt };
    impl OptionIterator (Option a) : Iterator {
        type Item (OptionIterator (Option a)) = a;
        advance = |OptionIterator { opt : opt }| (
            match opt {
                none() => none(),
                some(a) => some((OptionIterator { opt: none() }, a))
            }
        );
    }
}

impl [a : Eq] Option a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_some && rhs.is_some { lhs.as_some == rhs.as_some };
        lhs.is_none && rhs.is_none
    );
}

impl [a : ToString] Option a : ToString {
    to_string = |opt| if opt.is_some { "some(" + opt.as_some.to_string + ")" } else { "none()" };
}

impl Option : Functor {
    map = |f, opt| (
        if opt.is_none {
            Option::none()
        } else {
            Option::some $ f $ opt.as_some
        }
    );
}

impl Option : Monad {
    pure = Option::some;
    bind = |f, opt| if opt.is_none { Option::none() } else { f(opt.as_some) };
}

// The type for file path.
type Path = String;

// The type of punched arrays. 
// 
// A punched array is an array from which a certain element has been removed.
// This is used in the implementation of `Array::act`.
type PunchedArray a = unbox struct { _arr : Array a, idx : I64 };

namespace PunchedArray {

    // Plug in an element to a punched array to get back an array.
    //
    // # Parameters
    //
    // * `element` - The element to be plugged in.
    // * `parray` - The punched array to be plugged in.
    plug_in : a -> PunchedArray a -> Array a;
    plug_in = |elm, parr| (
        let PunchedArray { _arr : arr, idx : idx } = parr;
        let size = arr.get_size + 1;

        // Increment the size.
        let arr = arr._unsafe_force_unique._unsafe_set_size(size);

        // Move the element at the `idx` to the last.
        let arr = if idx == size - 1 { arr } else {
            let (arr, last) = arr._unsafe_get_linear(idx);
            arr._unsafe_set(size - 1, last)
        };

        // Insert the element.
        arr._unsafe_set(idx, elm)
    );

    // Creates a punched array by moving out the element at the specified index.
    // 
    // NOTE: this function assumes that the given array is unique WITHOUT CHECKING.
    // The uniqueness of the array is ensured in the `Array::act` function.
    //
    // # Parameters
    //
    // * `i` - The index of the element to be punched.
    // * `array` - The array to be punched.
    unsafe_punch : I64 -> Array a -> (PunchedArray a, a);
    unsafe_punch = |idx, arr| (
        // Bounds check.
        let size = arr.get_size;
        if !(0 <= idx && idx < size) { undefined("Index out of range.") };

        // Decrement the size.
        let (arr, elm) = arr._unsafe_set_size(size - 1)._unsafe_get_linear(idx);

        // Move the last element to the punched index.
        let arr = if idx == size - 1 {
            arr
        } else {
            let (arr, last) = arr._unsafe_get_linear(size-1);
            arr._unsafe_set(idx, last)
        };

        let parr = PunchedArray { _arr : arr, idx : idx };
        (parr, elm)
    );
}

// A type of result value for a computation that may fail.
type Result e o = unbox union { ok : o, err: e };

namespace Result {

    // Returns the containing value if the value is ok, or otherwise aborts the program.
    //
    // # Parameters
    //
    // * `res` - The result value to be unwrapped.
    unwrap : Result e o -> o;
    unwrap = |res| (
        if res.is_err {
            undefined("[Std::Result::unwrap] Try to unwrap an error value.")
        } else {
            res.as_ok
        }
    );
}

impl [e : Eq, a : Eq] Result e a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_ok && rhs.is_ok { lhs.as_ok == rhs.as_ok };
        if lhs.is_err && rhs.is_err { lhs.as_err == rhs.as_err };
        false
    );
}

impl Result e : Functor {
    map = |f, res| (
        if res.is_err {
            Result::err $ res.as_err
        } else {
            Result::ok $ f $ res.as_ok
        }
    );
}

impl Result e : Monad {
    pure = Result::ok;
    bind = |f, res| if res.is_err { Result::err $ res.as_err } else { f(res.as_ok) };
}

impl [e : ToString, a : ToString] Result e a : ToString {
    to_string = |res| if res.is_ok { "ok(" + res.as_ok.to_string + ")" } else { "err(" + res.as_err.to_string + ")" };
}

type String = unbox struct { _data : Array U8 };

namespace String {

    // Get the null-terminated C string.
    // 
    // NOTE: 
    // This function is dangerous because it returns a dangling pointer if `_get_c_str` is the last use of `s`.
    // To avoid this problem, you should use `borrow_c_str` or `borrow_c_str_io` instead.
    _get_c_str : String -> Ptr;
    _get_c_str = |s| s.@_data._get_boxed_ptr;

    // Create a string from C string (i.e., null-terminated byte array).
    // 
    // If the byte array doesn't include `\0`, this function causes undefined behavior.
    _unsafe_from_c_str : Array U8 -> String;
    _unsafe_from_c_str = |buf| (
        // Calculate length.
        let len = buf.borrow_boxed(|ptr| FFI_CALL[I64 strlen(Ptr), ptr]);
        let buf = buf._unsafe_set_size(len + 1);
        String { _data : buf }
    );

    // Create a `String` from a pointer to a null-terminated C string.
    // 
    // If the pointer is not pointing to a valid null-terminated C string, this function causes undefined behavior.
    // 
    // This function is private, but it should be public. Therefore, `unsafe_from_c_str_ptr` is created, and this function is deprecated.
    _unsafe_from_c_str_ptr : Ptr -> String;
    _unsafe_from_c_str_ptr = |ptr| (
        let len = FFI_CALL[I64 strlen(Ptr), ptr];
        let buf_len = len + 1;
        let buf = Array::empty(buf_len)._unsafe_set_size(buf_len);
        let (buf, _) = buf.mutate_boxed(|buf_ptr| FFI_CALL_IO[Ptr memcpy(Ptr, Ptr, I64), buf_ptr, ptr, buf_len]);
        String { _data : buf }
    );

    // Create a `String` from a pointer to a null-terminated C string.
    // 
    // If the pointer is not pointing to a valid null-terminated C string, this function cause undefined behavior.
    //
    // # Parameters
    //
    // * `ptr` - The pointer to a null-terminated C string.
    unsafe_from_c_str_ptr : Ptr -> String;
    unsafe_from_c_str_ptr = _unsafe_from_c_str_ptr;

    // Call a function with a null-terminated C string.
    //
    // # Parameters
    //
    // * `borrower` - The function to be called with the C string.
    // * `str` - The string.
    borrow_c_str : (Ptr -> a) -> String -> a;
    borrow_c_str = |f, str| str.@_data.borrow_boxed(f);

    // Call an IO action with a null-terminated C string.
    //
    // # Parameters
    //
    // * `borrower` - The IO action to be called with the C string.
    // * `str` - The string.
    borrow_c_str_io : (Ptr -> IO a) -> String -> IO a;
    borrow_c_str_io = |act, str| IO::from_runner $ |ios| (
        str.borrow_c_str(|c_str| (act(c_str).@runner)(ios))
    );

    // Concatenate two strings.
    // 
    // Note: Since `s1.concat(s2)` puts `s2` after `s1`, `concat(lhs, rhs)` puts `lhs` after `rhs`.
    //
    // # Parameters
    //
    // * `first` - The first string.
    // * `second` - The second string.
    concat : String -> String -> String;
    concat = |rhs, lhs| (
        // Remove null terminator from lhs and append rhs.
        String { _data : lhs.@_data.pop_back.append(rhs.@_data) }
    );

    // Concatenate an iterator of strings.
    //
    // # Parameters
    //
    // * `iter_strs` - The iterator of strings.
    concat_iter : [strs : Iterator, Item strs = String] strs -> String;
    concat_iter = |iter| (
        let len = iter.map(get_size).fold(0, add);
        let data_len = len + 1; // Add space for null terminator.
        let data = "".@_data.reserve(data_len);
        let data = iter.fold(data, |str, data| data.pop_back.append(str.@_data));
        String { _data : data }
    );

    // Create an empty string with a given capacity.
    //
    // # Parameters
    //
    // * `capacity` - The capacity of the string to be created.
    empty : I64 -> String;
    empty = |n| String { _data : Array::empty(n+1).push_back(0_U8) };

    // `str.find(token, start_idx)` finds the index where `token` firstly appears in `str`, starting from `start_idx`.
    // 
    // Note that this function basically returns a number less than or equal to `start_idx`, but there is an exception:
    // `str.find("", start_idx)` with `start_idx >= str.get_size` returns `str.get_size`, not `start_idx`.
    //
    // # Parameters
    //
    // * `token` - The token to be searched.
    // * `start_idx` - The index to start searching from.
    // * `str` - The string to be searched.
    find : String -> I64 -> String -> Option I64;
    find = |tok, start, str| (
        str.borrow_c_str(|c_str|
            let start = min(start, str.get_size);
            let pos = tok.borrow_c_str(|tok_c_str| FFI_CALL[Ptr strstr(Ptr, Ptr), c_str.add_offset(start), tok_c_str]);
            if pos == nullptr {
                Option::none()
            };
            let pos = pos.subtract_ptr(c_str);
            Option::some(pos)
        )
    );

    // Gets the byte array of a string, containing null-terminator.
    //
    // # Parameters
    //
    // * `str` - The string to be converted.
    get_bytes : String -> Array U8;
    get_bytes = @_data;

    // Gets the first byte of a string. Returns none if the string is empty.
    //
    // # Parameters
    //
    // * `str` - The string to be converted.
    get_first_byte : String -> Option U8;
    get_first_byte = |s| (
        if s.is_empty { Option::none() };
        Option::some $ s.@_data.@(0)
    );

    // Gets the last byte of a string. Returns none if the string is empty.
    // 
    // # Parameters
    //
    // * `str` - The string to be converted.
    get_last_byte : String -> Option U8;
    get_last_byte = |s| (
        let len = s.get_size;
        if len == 0 { Option::none() };
        Option::some $ s.@_data.@(len - 1)
    );

    // Gets the length of a string.
    //
    // # Parameters
    //
    // * `str` - The string to be converted.
    get_size : String -> I64;
    get_size = |s| s.@_data.get_size - 1; // exclude null terminator

    // `String` version of `Array::get_sub`.
    //
    // # Parameters
    //
    // * `start` - The start index of the substring.
    // * `end` - The end index of the substring.
    // * `str` - The string to be sliced.
    get_sub : I64 -> I64 -> String -> String;
    get_sub = |s, e, str| (
        let len = str.get_size;
        String::_unsafe_from_c_str $ str.get_bytes._get_sub_size_with_length_and_additional_capacity(len, 1, s, e).push_back('\0')
    );

    // Returns if the string is empty or not.
    //
    // # Parameters
    //
    // * `str` - The string to be checked.
    is_empty : String -> Bool;
    is_empty = |s| s.get_size == 0;

    // Joins (an iterator of) strings by a separator.
    //
    // # Parameters
    //
    // * `sep` - The separator to be used for joining.
    // * `iter_strs` - The iterator of strings to be joined.
    join : [ss : Iterator, Item ss = String] String -> ss -> String;
    join = |sep, ss| (
        ss.intersperse(sep).concat_iter
    );

    // Removes the last byte.
    // 
    // If the string is empty, this function does nothing.
    //
    // # Parameters
    //
    // * `str` - The string to be modified.
    pop_back_byte : String -> String;
    pop_back_byte = |s| (
        if s.is_empty { s };
        s.mod__data(|bytes| bytes.pop_back.pop_back.push_back(0_U8))
    );

    // `str.split(sep)` splits `str` by `sep` into an iterator.
    // 
    // Example:
    // ```
    // assert_eq(|_|"Ex. 1", "ab,c,".split(",").to_array, ["ab", "c", ""]);;
    // assert_eq(|_|"Ex. 2", "abc".split(",").to_array, ["abc"]);;
    // assert_eq(|_|"Ex. 3", "abc".split("").to_array, ["a", "b", "c"]);; // Special behavior when the separator is empty.
    // ```
    //
    // # Parameters
    //
    // * `sep` - The separator to be used for splitting.
    // * `str` - The string to be split.
    split : String -> String -> StringSplitIterator;
    split = |sep, str| StringSplitIterator { idx: 0, str: str, strlen: str.get_size, sep: sep, sep_len: sep.get_size };

    type StringSplitIterator = unbox struct { idx : I64, str : String, strlen : I64, sep : String, sep_len : I64 };

    impl StringSplitIterator : Iterator {
        type Item StringSplitIterator = String;
        advance = |iter| (
            let StringSplitIterator { idx: idx, str: str, strlen: strlen, sep: sep, sep_len: sep_len } = iter;
            if sep_len == 0 {
                if idx == strlen { none() };
                let c_str = String::from_U8 $ str.get_bytes.@(idx);
                some $ (iter.set_idx(idx + 1), c_str)
            };
            if idx == -1 { none() };
            match str.find(sep, idx) {
                none() => some $ (iter.set_idx(-1), str.get_sub(idx, strlen)),
                some(pos) => some $ (iter.set_idx(pos + sep_len), str.get_sub(idx, pos))
            }
        );
    }

    // Creates a string from a byte.
    // 
    // Example:
    // ```
    // assert_eq(|_|"", String::from_U8('a'), "a");;
    // assert_eq(|_|"", String::from_U8('\x00'), "");;
    // ```
    //
    // # Parameters
    //
    // * `byte` - The byte to be converted.
    from_U8 : U8 -> String;
    from_U8 = |b| String::_unsafe_from_c_str([b, '\x00']);

    // Removes the first byte of a string while it satisifies the specified condition.
    //
    // # Parameters
    //
    // * `cond` - The condition for the byte to be removed.
    // * `str` - The string to be modified.
    strip_first_bytes : (U8 -> Bool) -> String -> String;
    strip_first_bytes = |cond, str| (
        let len = str.get_size;
        let bytes = str.get_bytes;
        let n = loop(0, |i| (
            if i == len { break $ i };
            if !cond(bytes.@(i)) { break $ i };
            continue $ i + 1
        ));
        str.get_sub(n, len)
    );

    // Removes leading whitespace characters.
    //
    // # Parameters
    //
    // * `str` - The string to be modified.
    strip_first_spaces : String -> String;
    strip_first_spaces = strip_first_bytes(|c| FFI_CALL[I32 isspace(I32), c.to_I32] > 0_I32);

    // Removes the last byte of a string while it satisifies the specified condition.
    // 
    // # Parameters
    //
    // * `cond` - The condition for the byte to be removed.
    strip_last_bytes : (U8 -> Bool) -> String -> String;
    strip_last_bytes = |cond, s| (
        loop(s, |s|
            if s.is_empty { break $ s };
            if cond(s.get_last_byte.as_some) { 
                continue $ s.pop_back_byte
            } else {
                break $ s
            }
        )
    );

    // Removes newlines and carriage returns at the end of the string.
    //
    // # Parameters
    //
    // * `str` - The string to be modified.
    strip_last_newlines : String -> String;
    strip_last_newlines = strip_last_bytes(|c| c == '\n' || c == '\r');

    // Removes trailing whitespace characters.
    //
    // # Parameters
    //
    // * `str` - The string to be modified.
    strip_last_spaces : String -> String;
    strip_last_spaces = strip_last_bytes(|c| FFI_CALL[I32 isspace(I32), c.to_I32] > 0_I32);

    // Strips leading and trailing whitespace characters.
    //
    // # Parameters
    //
    // * `str` - The string to be modified.
    strip_spaces : String -> String;
    strip_spaces = |s| s.strip_last_spaces.strip_first_spaces;

    // Populate strings into a template string, similar to "format" function in other languages.
    //
    // i-th "{}" in the template string is replaced by i-th string.
    //
    // Example:
    // `"{}, {}!".populate(["Hello", "world"])` => "Hello, world!"
    //
    //  "{{" and "}}" are escaped to "{" and "}".
    // 
    // Example:
    // `"{{ x = {}, y = {} }}".populate([1.to_string, 2.to_string])` => "{ x = 1, y = 2 }",
    // 
    // If the number of placeholders does not match with the number of strings, this function halts the program.
    // 
    // Added in v1.1.0.
    //
    // # Parameters
    // - `vs`: The array of strings ("values") to be inserted into the template string.
    // - `template`: The template string.
    populate : Array String -> String -> String;
    populate = |vs, template| (
        let template = template.get_bytes;
        let end = template.get_size - 1;
        let out = [];
        let (out, vi) = loop((out, 0, 0), |(out, i, vi)|
            if i == end { break $ (out, vi) };
            let c = template.@(i);

            // replace "{{" to "{"
            if c == '{' &&
            i + 1 < end && template.@(i+1) == '{' {
                continue $ (out.push_back('{'), i + 2, vi)
            };

            // replace "}}" to "}"
            if c == '}' &&
            i + 1 < end && template.@(i+1) == '}' {
                continue $ (out.push_back('}'), i + 2, vi)
            };

            // replace "{}" to `vs.@(vi)`
            if c == '{' &&
            i + 1 < end && template.@(i+1) == '}' {
                if vi >= vs.get_size { undefined("[populate] Too many placeholders!") };
                let out = out.append(vs.@(vi).get_bytes.pop_back);
                continue $ (out, i + 2, vi + 1)
            };

            // raise error for other usage of '{' and '}'
            if c == '{' || c == '}' {
                undefined("[populate] Invalid template string!")
            };

            let out = out.push_back(c);
            
            continue $ (out, i + 1, vi)
        );

        if vi < vs.get_size {
            undefined("[populate] Not enough placeholders!")
        };

        String { _data : out.push_back('\0') }
    );
}

// The empty string.
impl String : Zero {
    zero = "";
}

// Concatenates two strings.
impl String : Add {
    add = |lhs, rhs| lhs.concat(rhs);
}

impl String : Eq {
    eq = |lhs, rhs| (lhs.@_data == rhs.@_data);
}

impl String : LessThan {
    less_than = |lhs, rhs| lhs.@_data < rhs.@_data;
}

impl String : LessThanOrEq {
    less_than_or_eq = |lhs, rhs| lhs.@_data <= rhs.@_data;
}

impl String : ToString {
    to_string = |s| s;
}

impl () : Eq {
    eq = |_, _| true;
}

// Creates a string from a byte array.
// 
// The byte array must include a null terminator (`'\0'`). If not, `from_bytes` returns an error.
// 
// The length of the string is the number of bytes until the first null character.
impl String : FromBytes {
    from_bytes = |buf| (
        // Search for null terminator.
        let buf_n = buf.get_size;
        let null_idx = range(0, buf_n).loop_iter(buf_n, |i, _|
            if buf.@(i) == '\0' { break $ i };
            continue $ buf_n
        );
        // If the byte array doesn't include a null terminator, return an error.
        if null_idx == buf_n { Result::err("The byte array doesn't include a null terminator.") };

        // Create a string.
        let buf = buf._unsafe_set_size(null_idx + 1);
        Result::ok $ String { _data : buf }
    );
}

// Converts a string into a byte array.
// 
// The byte array ends with a null terminator (`'\0'`).
impl String : ToBytes {
    to_bytes = |s| s.@_data;
}

// Functions

// Composes two functions. Composition operators `<<` and `>>` is translated to use of `compose`. 
//
// # Parameters
//
// * `first` - The first function to be composed.
// * `second` - The second function to be composed.
compose : (a -> b) -> (b -> c) -> a -> c;
compose = |f, g, a| g(f(a));

// Monadic loop function. This is similar to `loop` but can be used to perform monadic action at each loop.
// 
// It is convenient to use `continue_m` and `break_m` to create monadic loop body function.
// 
// The following program prints "Hello World! (i)" for i = 0, 1, 2.
// 
// ```
// module Main;
// 
// main : IO ();
// main = (
//     loop_m(0, |i| (
//         if i == 3 { break_m $ () };
//         println("Hello World! (" + i.to_string + ")");;
//         continue_m $ i + 1
//     ))
// );
// ```
//
// # Parameters
//
// * `s0` - The initial state of the loop.
// * `body` - The body of the loop. It takes the current state and returns a monadic action that produces a new state or a break value.
loop_m : [m : Monad] s -> (s -> m (LoopState s r)) -> m r;
loop_m = |s, f| (
    let res = *f(s);
    if res.is_break { pure $ res.as_break };
    loop_m(res.as_continue, f)
);

// Constants

namespace I8 {
    maximum : I8;
    maximum = 127_I8;

    minimum : I8;
    minimum = -128_I8;
}
impl I8 : Zero {
    zero = 0_I8;
}

namespace U8 {
    maximum : U8;
    maximum = 255_U8;

    minimum : U8;
    minimum = 0_U8;
}
impl U8 : Zero {
    zero = 0_U8;
}

namespace I16 {
    maximum : I16;
    maximum = 32767_I16;

    minimum : I16;
    minimum = -32768_I16;
}
impl I16 : Zero {
    zero = 0_I16;
}

namespace U16 {
    maximum : U16;
    maximum = 65535_U16;

    minimum : U16;
    minimum = 0_U16;
}
impl U16 : Zero {
    zero = 0_U16;
}

namespace I32 {
    maximum : I32;
    maximum = 2147483647_I32;

    minimum : I32;
    minimum = -2147483648_I32;
}
impl I32 : Zero {
    zero = 0_I32;
}

namespace U32 {
    maximum : U32;
    maximum = 4294967295_U32;

    minimum : U32;
    minimum = 0_U32;
}
impl U32 : Zero {
    zero = 0_U32;
}

namespace I64 {
    maximum : I64;
    maximum = 9223372036854775807;

    minimum : I64;
    minimum = -9223372036854775808;
}
impl I64 : Zero {
    zero = 0_I64;
}

namespace U64 {
    maximum : U64;
    maximum = 18446744073709551615_U64;

    minimum : U64;
    minimum = 0_U64;
}
impl U64 : Zero {
    zero = 0_U64;
}

impl F32 : Zero {
    zero = 0.0_F32;
}

impl F64 : Zero {
    zero = 0.0_F64;
}

// Traits

// Trait for prefix operator `-`.
trait a : Neg {
    // Negates a value. An expression `-x` is translated to `neg(x)`.
    neg : a -> a;
}

// Trait for prefix operator `!`.
trait a : Not {
    // Logical NOT of a value. An expression `!x` is translated to `not(x)`.
    not : a -> a;
}

// Trait for infix operator `==`.
trait a : Eq {
    // Checks equality of two values. An expression `x == y` is translated to `eq(x, y)`.
    //
    // # Parameters
    //
    // * `lhs`
    // * `rhs`
    eq : a -> a -> Bool;
}

// Trait for infix operator `<`.
trait a : LessThan {
    // Compares two values. An expression `x < y` is translated to `less_than(x, y)`.
    // 
    // # Parameters
    //
    // * `lhs`
    // * `rhs`
    less_than : a -> a -> Bool;
}

// Trait for infix operator `<=`.
trait a : LessThanOrEq {
    // Compares two values. An expression `x <= y` is translated to `less_than_or_eq(x, y)`.
    //
    // # Parameters
    //
    // * `lhs`
    // * `rhs`
    less_than_or_eq : a -> a -> Bool;
}

// Trait for infix operator `+`.
trait a : Add {
    // Adds two values. An expression `x + y` is translated to `add(x, y)`.
    //
    // # Parameters
    //
    // * `lhs`
    // * `rhs`
    add : a -> a -> a;
}

// Trait for infix operator `-`.
trait a : Sub {
    // Subtracts a value from another value. An expression `x - y` is translated to `sub(x, y)`.
    //
    // # Parameters
    //
    // * `lhs`
    // * `rhs`    
    sub : a -> a -> a;
}

// Trait for infix operator `*`.
trait a : Mul {
    // Multiplies a value by another value. An expression `x * y` is translated to `mul(x, y)`.
    //
    // # Parameters
    //
    // * `lhs`
    // * `rhs`    
    mul : a -> a -> a;
}

// Trait for infix operator `/`.
trait a : Div {
    // Divides a value by another value. An expression `x / y` is translated to `div(x, y)`.
    //
    // # Parameters
    //
    // * `lhs`
    // * `rhs`
    div : a -> a -> a;
}

// Trait for infix operator `%`.
trait a : Rem {
    // Calculate remainder of a value dividing another value. An expression `x % y` is translated to `rem(x, y)`.
    //
    // # Parameters
    //
    // * `lhs`
    // * `rhs`
    rem : a -> a -> a;
}

trait Additive = Add + Zero;

trait a : FromBytes {
    // Converts a byte array into a value by parsing it.
    // 
    // # Parameters
    //
    // * `byte_array` - The byte array to be converted.
    from_bytes : Array U8 -> Result ErrMsg a;
}

trait a : FromString {
    // Converts a string into a value by parsing it.
    //
    // # Parameters
    //
    // * `str` - The string to be converted.
    from_string : String -> Result ErrMsg a;
}

// The trait for functors.
trait [f : *->*] f : Functor {
    // Applies a function to the value inside the functor.
    //
    // # Parameters
    //
    // * `f` - The function to be applied.
    // * `value` - The functor value to be transformed.
    map : (a -> b) -> f a -> f b;
}

namespace Functor {
    // Discards the value inside the functor and returns a functor containing `()`.
    //
    // # Parameters
    //
    // * `value` - The functor value.
    forget : [f : Functor] f a -> f ();
    forget = map(|_|());
}

namespace LessThan {
    // The maximum of two values.
    //
    // # Parameters
    //
    // * `lhs` - The first value.
    // * `rhs` - The second value.
    max : [a : LessThan] a -> a -> a;
    max = |x, y| if x < y { y } else { x };

    // The minimum of two values.
    //
    // # Parameters
    //
    // * `lhs` - The first value.
    // * `rhs` - The second value.
    min : [a : LessThan] a -> a -> a;
    min = |x, y| if x < y { x } else { y };
}

// The trait for monads.
trait [m : *->*] m : Monad {
    // Evaluate a monadic action, and pass the result to the next action.
    //
    // # Parameters
    //
    // * `continuation` - The following action.
    // * `action` - The first action. 
    bind : (a -> m b) -> m a -> m b;
    // Creates a pure monadic action which just returns a specified value.
    //
    // # Parameters
    //
    // * `value`
    pure : a -> m a;
}

namespace Monad {
    // Flattens a nested monadic action.
    //
    // # Parameters
    //
    // * `nested_monad`
    flatten : [m : Monad] m (m a) -> m a;
    flatten = Monad::bind(|x|x);

    // `unless(cond, act)` where `act` is a monadic value which returns `()` perfoms `act` only when `cond` is false.
    //
    // # Parameters
    //
    // * `condition`
    // * `action`
    unless : [m : Monad] Bool -> m () -> m ();
    unless = |cond, act| if cond { pure $ () } else { act };

    // `when(cond, act)` where `act` is a monadic value which returns `()` perfoms `act` only when `cond` is true.
    //
    // # Parameters
    //
    // * `condition`
    // * `action`
    when : [m : Monad] Bool -> m () -> m ();
    when = |cond, act| if cond { act } else { pure $ () };
}

trait a : ToBytes {
    to_bytes : a -> Array U8;
}

trait a : ToString {
    to_string : a -> String;
}

trait a : Zero {
    zero : a;
}

// Abs

namespace I8 {
    abs : I8 -> I8;
    abs = |f| if f < 0_I8 { -f } else { f };
}

namespace I16 {
    abs : I16 -> I16;
    abs = |f| if f < 0_I16 { -f } else { f };
}

namespace I32 {
    abs : I32 -> I32;
    abs = |f| if f < 0_I32 { -f } else { f };
}

namespace I64 {
    abs : I64 -> I64;
    abs = |f| if f < 0 { -f } else { f };
}

namespace F32 {
    abs : F32 -> F32;
    abs = |f| if f < 0.0_F32 { -f } else { f };
}

namespace F64 {
    abs : F64 -> F64;
    abs = |f| if f < 0.0 { -f } else { f };
}

namespace Ptr {
    // Adds an offset to a pointer.
    //
    // # Parameters
    //
    // * `offset`
    // * `ptr`
    add_offset : I64 -> Ptr -> Ptr;
    add_offset = |off, ptr| FFI_CALL[Ptr fixruntime_ptr_add_offset(Ptr, I64), ptr, off];

    // Subtracts two pointers.
    // 
    // Note that `x.subtract_ptr(y)` calculates `x - y`, so `subtract_ptr(x, y)` calculates `y - x`.
    //
    // # Parameters
    //
    // * `rhs`
    // * `lhs`
    subtract_ptr : Ptr -> Ptr -> I64;
    subtract_ptr = |rhs, lhs| FFI_CALL[I64 fixruntime_subtract_ptr(Ptr, Ptr), lhs, rhs];
}

impl Ptr : ToString {
    to_string = |v| (
        let data = Array::empty(17);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_ptr_to_str(Ptr, Ptr), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U8 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(1)._unsafe_set_size(1);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u8_to_bytes(Ptr, U8), ptr, v]);
        data
    );
}
impl U8 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 1 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U8."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[U8 fixruntime_u8_from_bytes(Ptr), ptr])
    );
}
impl U8 : ToString {
    to_string = |v| (
        let data = Array::empty(4); // len(255) + 1
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u8_to_str(Ptr, U8), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U8 : FromString {
    from_string = |str| str.from_string.map(U64::to_U8);
}

impl U16 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(2)._unsafe_set_size(2);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u16_to_bytes(Ptr, U16), ptr, v]);
        data
    );
}
impl U16 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 2 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U16."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[U16 fixruntime_u16_from_bytes(Ptr), ptr])
    );
}
impl U16 : ToString {
    to_string = |v| (
        let data = Array::empty(6); // len(65535) + 1
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u16_to_str(Ptr, U16), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U16 : FromString {
    from_string = |str| str.from_string.map(U64::to_U16);
}

impl U32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u32_to_bytes(Ptr, U32), ptr, v]);
        data
    );
}
impl U32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U32."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[U32 fixruntime_u32_from_bytes(Ptr), ptr])
    );
}
impl U32 : ToString {
    to_string = |v| (
        let data = Array::empty(11);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u32_to_str(Ptr, U32), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U32 : FromString {
    from_string = |str| str.from_string.map(U64::to_U32);
}

impl U64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u64_to_bytes(Ptr, U64), ptr, v]);
        data
    );
}
impl U64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as U64."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[U64 fixruntime_u64_from_bytes(Ptr), ptr])
    );
}
impl U64 : ToString {
    to_string = |v| (
        let data = Array::empty(21);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u64_to_str(Ptr, U64), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl U64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = FFI_CALL[U64 fixruntime_strtoull_10(Ptr), c_str];
            let err = FFI_CALL[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (invalid format): " + str) };
            let err = FFI_CALL[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl I8 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(1)._unsafe_set_size(1);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u8_to_bytes(Ptr, I8), ptr, v]);
        data
    );
}
impl I8 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 1 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I8."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[I8 fixruntime_u8_from_bytes(Ptr), ptr])
    );
}
impl I8 : ToString {
    to_string = |v| (
        let data = Array::empty(5); // len(-128) + 1
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_i8_to_str(Ptr, I8), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl I8 : FromString {
    from_string = |str| str.from_string.map(I64::to_I8);
}

impl I16 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(2)._unsafe_set_size(2);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u16_to_bytes(Ptr, I16), ptr, v]);
        data
    );
}
impl I16 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 2 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I16."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[I16 fixruntime_u16_from_bytes(Ptr), ptr])
    );
}
impl I16 : ToString {
    to_string = |v| (
        let data = Array::empty(7); // len(-32768) + 1
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_i16_to_str(Ptr, I16), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl I16 : FromString {
    from_string = |str| str.from_string.map(I64::to_I16);
}

impl I32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u32_to_bytes(Ptr, I32), ptr, v]);
        data
    );
}
impl I32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I32."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[I32 fixruntime_u32_from_bytes(Ptr), ptr])
    );
}
impl I32 : ToString {
    to_string = |v| (
        let data = Array::empty(12);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_i32_to_str(Ptr, I32), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl I32 : FromString {
    from_string = |str| str.from_string.map(I64::to_I32);
}

impl I64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_u64_to_bytes(Ptr, I64), ptr, v]);
        data
    );
}
impl I64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as I64."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[I64 fixruntime_u64_from_bytes(Ptr), ptr])
    );
}
impl I64 : ToString {
    to_string = |v| (
        let data = Array::empty(21);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_i64_to_str(Ptr, I64), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
impl I64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = FFI_CALL[I64 fixruntime_strtoll_10(Ptr), c_str];
            let err = FFI_CALL[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (invalid format): " + str) };
            let err = FFI_CALL[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to integer (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl F32 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(4)._unsafe_set_size(4);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_bytes(Ptr, F32), ptr, v]);
        data
    );
}
impl F32 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 4 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as F32."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[F32 fixruntime_f32_from_bytes(Ptr), ptr])
    );
}
impl F32 : ToString {
    to_string = |v| (
        let data = Array::empty(50);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_str(Ptr, F32), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
namespace F32 {
    // Converts a floating number to a string of exponential form.
    // 
    // # Parameters
    // * `v` - The floating number to be converted to a string.
    to_string_exp : F32 -> String;
    to_string_exp = |v| (
        let data = Array::empty(50);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_str_exp(Ptr, F32), ptr, v]);
        String::_unsafe_from_c_str(data)
    );

    // Converts a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).
    // 
    // # Parameters
    // * `prec` - The number of digits after the decimal point.
    // * `v` - The floating number to be converted to a string.
    to_string_exp_precision : U8 -> F32 -> String;
    to_string_exp_precision = |prec, v| (
        let data = Array::empty(50 + prec.to_I64);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_str_exp_precision(Ptr, F32, U8), ptr, v, prec]);
        String::_unsafe_from_c_str(data)
    );

    // Converts a floating number to a string with specified precision (i.e., number of digits after the decimal point).
    // 
    // # Parameters
    // * `prec` - The number of digits after the decimal point.
    // * `v` - The floating number to be converted to a string.
    to_string_precision : U8 -> F32 -> String;
    to_string_precision = |prec, v| (
        let data = Array::empty(50 + prec.to_I64);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f32_to_str_precision(Ptr, F32, U8), ptr, v, prec]);
        String::_unsafe_from_c_str(data)
    );
}
impl F32 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = FFI_CALL[F32 fixruntime_strtof(Ptr), c_str];
            let err = FFI_CALL[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to number (invalid format): " + str) };
            let err = FFI_CALL[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to number (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

impl F64 : ToBytes {
    to_bytes = |v| (
        let data = Array::empty(8)._unsafe_set_size(8);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_bytes(Ptr, F64), ptr, v]);
        data
    );
}
impl F64 : FromBytes {
    from_bytes = |bs| (
        if bs.get_size != 8 {
            Result::err $ "Byte array of length " + bs.get_size.to_string + " cannot be interpreted as F64."
        };
        Result::ok $ bs.borrow_boxed(|ptr| FFI_CALL[F64 fixruntime_f64_from_bytes(Ptr), ptr])
    );
}
impl F64 : ToString {
    to_string = |v| (
        let data = Array::empty(500);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_str(Ptr, F64), ptr, v]);
        String::_unsafe_from_c_str(data)
    );
}
namespace F64 {
    // Converts a floating number to a string of exponential form.
    // 
    // # Parameters
    // * `v` - The floating number to be converted to a string.
    to_string_exp : F64 -> String;
    to_string_exp = |v| (
        let data = Array::empty(500);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_str_exp(Ptr, F64), ptr, v]);
        String::_unsafe_from_c_str(data)
    );

    // Converts a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).
    //
    // # Parameters
    // * `prec` - The number of digits after the decimal point.
    // * `v` - The floating number to be converted to a string.
    to_string_exp_precision : U8 -> F64 -> String;
    to_string_exp_precision = |prec, v| (
        let data = Array::empty(500 + prec.to_I64);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_str_exp_precision(Ptr, F64, U8), ptr, v, prec]);
        String::_unsafe_from_c_str(data)
    );

    // Converts a floating number to a string with specified precision (i.e., number of digits after the decimal point).
    // 
    // # Parameters
    // * `prec` - The number of digits after the decimal point.
    // * `v` - The floating number to be converted to a string.
    to_string_precision : U8 -> F64 -> String;
    to_string_precision = |prec, v| (
        let data = Array::empty(500 + prec.to_I64);
        let (data, _) = data.mutate_boxed(|ptr| FFI_CALL_IO[() fixruntime_f64_to_str_precision(Ptr, F64, U8), ptr, v, prec]);
        String::_unsafe_from_c_str(data)
    );
}
impl F64 : FromString {
    from_string = |str| (
        str.borrow_c_str(|c_str| (
            let v = FFI_CALL[F64 fixruntime_strtod(Ptr), c_str];
            let err = FFI_CALL[U8 fixruntime_is_einval()];
            if err != 0_U8 { Result::err("Failed to convert string to number (invalid format): " + str) };
            let err = FFI_CALL[U8 fixruntime_is_erange()];
            if err != 0_U8 { Result::err("Failed to convert string to number (out of range): " + str) };
            Result::ok(v)
        ))
    );
}

// Returns "()".
impl () : ToString {
    to_string = |_| "()";
}

namespace Debug {

    // Asserts that a condition (boolean value) is true. 
    // 
    // If the assertion failed, prints a message to the stderr and aborts the program.
    //
    // # Parameters
    //
    // * `lazy_msg`
    // * `condition`
    assert : Lazy String -> Bool -> IO ();
    assert = |msg, b| IO::from_runner $ |state| (
        if b {
            (state, ())
        } else {
            undefined("Assertion failed!: " + msg())
        }
    );

    // Asserts that two values are equal.
    // 
    // If the assertion failed, prints a message to the stderr and aborts the program.
    //
    // # Parameters
    //
    // * `lazy_msg`
    // * `lhs`
    // * `rhs`
    assert_eq : [a: Eq] Lazy String -> a -> a -> IO ();
    assert_eq = |msg, lhs, rhs| assert(msg, lhs == rhs);

    // Asserts that the given value is unique, and returns the given value.
    // If the assertion failed, prints a message to the stderr and aborts the program.
    // 
    // The main use of this function is to check whether a boxed value given as an argument is unique.
    //
    // # Parameters
    //
    // * `lazy_msg`
    // * `value`
    assert_unique : Lazy String -> a -> a;
    assert_unique = |msg, x| (
        let (unique, x) = x.unsafe_is_unique;
        if !unique { undefined("Value is not unique: " + msg()) };
        x
    );

    // Get clocks (cpu time) elapsed while executing an I/O action.
    //
    // # Parameters
    //
    // * `action`
    consumed_time_while_io : IO a -> IO (a, F64);
    consumed_time_while_io = |io| (
        let s = *FFI_CALL_IO[I64 fixruntime_clock()];
        let r = *io;
        let t = *FFI_CALL_IO[I64 fixruntime_clock()];
        let t = FFI_CALL[F64 fixruntime_clocks_to_sec(I64), t - s];
        pure $ (r, t)
    );

    // Get clocks (cpu time) elapsed while evaluating a lazy value.
    // 
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    //
    // # Parameters
    //
    // * `lazy_value`
    consumed_time_while_lazy : Lazy a -> (a, F64);
    consumed_time_while_lazy = |l| (
        let s = FFI_CALL[I64 fixruntime_clock()];
        let r = l();
        let t = FFI_CALL[I64 fixruntime_clock()];
        let t = FFI_CALL[F64 fixruntime_clocks_to_sec(I64), t - s];
        (r, t)
    );

    // Prints a string to stderr and flushes.
    // 
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    //
    // # Parameters
    //
    // * `msg`    
    debug_eprint : String -> ();
    debug_eprint = |msg| _debug_print_to_stream(stderr, msg);

    // Prints a string followed by a newline to stderr and flushes.
    //
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    //
    // # Parameters
    //
    // * `msg`    
    debug_eprintln : String -> ();
    debug_eprintln = |msg| debug_eprint(msg + "\n");

    // Prints a string to stdout and flushes.
    // 
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    //
    // # Parameters
    //
    // * `msg`        
    debug_print : String -> ();
    debug_print = |msg| _debug_print_to_stream(stdout, msg);

    // Prints a string followed by a newline to stdout and flushes.
    //
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    //
    // # Parameters
    //
    // * `msg`        
    debug_println : String -> ();
    debug_println = |msg| debug_print(msg + "\n");

    // Prints a string to the specified stream and flushes the stream.
    // 
    // NOTE: This function is not pure and should only be used for temporary debugging purposes.
    _debug_print_to_stream : IOHandle -> String -> ();
    _debug_print_to_stream = |handle, msg| (
        msg.borrow_c_str_io(|str|
            let file_ptr = *handle.get_file_ptr;
            FFI_CALL_IO[I32 fputs(Ptr, Ptr), str, file_ptr];;
            FFI_CALL_IO[I32 fflush(Ptr), file_ptr];;
            pure()
        ).unsafe_perform
    );
}